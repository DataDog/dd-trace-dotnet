trigger:
  branches:
    include:
      - master
      - release/*
      - hotfix/*
      - refs/tags/*
    exclude:
      - refs/pull/*/head
  paths:
    exclude:
      - docs/*
      - .github/*
      - tracer/dependabot/*
# The following is a list of shared asset locations.
# This is the config for the Tracer CI pipeline,
# so we are excluding shared assets that are not currently used by the Tracer.
# We make this list granular, rather than catch-all, on purpose.
# It makes it easier to selectively remove items from the list, once the Tracer starts using them.
#     - The Managed Loader:
      - shared/samples/Datadog.AutoInstrumentation.ManagedLoader.Demo/*
      - shared/src/managed-lib/ManagedLoader/*
#     - Dynamic Bindings for DiagnosticSource:
      - shared/samples/Datadog.DynamicDiagnosticSourceBindings.Demo/*
      - shared/src/managed-lib/DynamicDiagnosticSourceBindings/*
#     - Logging damo samples:
      - shared/samples/Datadog.Logging.Demo/*
#     - Managed utility APIs (may be used transitively):
      - shared/src/managed-src/Datadog.Collections/*
      - shared/src/managed-src/Datadog.Util/*
#     - Managed Logging APIs (may be used transitively):
      - shared/src/managed-src/Datadog.Logging.Emission/*
      - shared/src/managed-src/Datadog.Logging.Composition/*
      - shared/src/managed-src/Datadog.Logging/*
#     - Fmt lib:
      - shared/src/native-lib/fmt_x64-windows-static/*
      - shared/src/native-lib/fmt_x86-windows-static/*
#     - Spdlob lib:
      - shared/src/native-lib/spdlog/*
#     - Mics common native sources:
      - shared/src/native-src/*

pr:
  branches:
    include:
      - '*' # default
  paths:
    exclude:
      - tracer/dependabot/*

schedules:
  - cron: "0 3 * * *"
    displayName: Daily 3am (UTC) build
    branches:
      include:
        - master
        - release/*
        - hotfix/*
        - /benchmarks/*
    always: true

# Global variables
variables:
  buildConfiguration: Release
  dotnetCoreSdkLatestVersion: 6.0.100
  relativeTracerHome: /tracer/src/bin/windows-tracer-home
  relativeArtifacts: /tracer/src/bin/artifacts
  ddTracerHome: $(System.DefaultWorkingDirectory)/tracer/src/bin/dd-tracer-home
  tracerHome: $(System.DefaultWorkingDirectory)/tracer/src/bin/windows-tracer-home
  profilerSrcDirectory: $(System.DefaultWorkingDirectory)/../dd-continuous-profiler-dotnet
  profilerHome: $(System.DefaultWorkingDirectory)/profiler/bin/profiler-home # Important, put the profiler assets into the working directory so it can be saved across build stages more easily
  monitoringHome: $(System.DefaultWorkingDirectory)/shared/bin/monitoring-home
  artifacts: $(System.DefaultWorkingDirectory)/tracer/src/bin/artifacts
  ddApiKey: $(DD_API_KEY)
  isMainBranch: $[in(variables['Build.SourceBranch'], 'refs/heads/master', 'refs/heads/main')]
  isMainOrReleaseBranch: $[or(in(variables['Build.SourceBranch'], 'refs/heads/master', 'refs/heads/main'), startsWith(variables['Build.SourceBranch'], 'refs/heads/release/'))]
  isPullRequest: $[eq(variables['Build.Reason'], 'PullRequest')]
  DD_DOTNET_TRACER_MSBUILD:
  NugetPackageDirectory: $(System.DefaultWorkingDirectory)/packages
  relativeNugetPackageDirectory: packages
  # For scheduled builds, only run benchmarks and crank (and deps).
  isScheduledBuild: ${{ eq(variables['Build.Reason'], 'Schedule') }} # only works if you have a main branch
  dotnetToolTag: build-dotnet-tool
  Verify_DisableClipboard: true
  DiffEngine_Disabled: true
  OriginalCommitId: $[coalesce(variables['System.PullRequest.SourceCommitId'], variables['Build.SourceVersion'])]
  NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY: true

# Declare the datadog agent as a resource to be used as a pipeline service
resources:
  containers:
  - container: dd_agent
    image: datadog/agent
    ports:
    - 8126:8126
    env:
      DD_API_KEY: $(ddApiKey)
      DD_INSIDE_CI: true
  repositories:
  - repository: dd-continuous-profiler-dotnet
    type: github
    endpoint: DataDog
    name: DataDog/dd-continuous-profiler-dotnet

# Stages
stages:
- stage: build_windows
  dependsOn: []
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build]

  - job: build
    pool:
      vmImage: windows-2019
    steps:
    - checkout: self
      path: s

    - template: steps/install-latest-dotnet-sdk.yml

    # workaround for "Unable move and reuse existing repository to required location."
    # https://github.com/microsoft/azure-pipelines-yaml/issues/403
    - powershell: |
        New-Item -Path . -Name "dd-continuous-profiler-dotnet" -ItemType "directory"
      displayName: "Create repository folder (workaround)"

    - checkout: dd-continuous-profiler-dotnet
      path: dd-continuous-profiler-dotnet

    - powershell: |
        New-Item -Path $(System.DefaultWorkingDirectory)\..\dd-trace-dotnet -ItemType SymbolicLink -Value $(System.DefaultWorkingDirectory)
      displayName: Create symlink from $(System.DefaultWorkingDirectory)\..\dd-trace-dotnet to $(System.DefaultWorkingDirectory)

    - powershell: |
        $sha = git rev-parse --short HEAD
        Write-Host "SHA is $sha"
        echo "##vso[task.setvariable variable=BetaMsiSuffix;isOutput=true]v$(Build.BuildId)-$sha"
        Write-Host "BetaMsiSuffix set to v$(Build.BuildId)-$sha"
      workingDirectory: $(System.DefaultWorkingDirectory)\..\dd-continuous-profiler-dotnet
      displayName: Persist the commit sha for the dd-continuous-profiler repo (temporary)
      name: SetMsiSuffix # because we're going to depend on the variable output, we need to name the step

    - script: tracer\build.cmd BuildTracerHome
      displayName: Build tracer home

    - script: tracer\build.cmd BuildProfilerHome
      displayName: Build profiler home

    - script: tracer\build.cmd BuildMonitoringHome
      displayName: Build monitoring home

    - publish: $(tracerHome)
      displayName: Upload Windows tracer home directory
      artifact: windows-tracer-home

    - publish: $(System.DefaultWorkingDirectory)/../_build/DDProf-Deploy
      displayName: Upload Windows profiler home directory
      artifact: windows-profiler-home

    - publish: $(System.DefaultWorkingDirectory)
      displayName: Upload working directory after the managed build
      artifact: build-windows-working-directory

- stage: build_linux
  dependsOn: []
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build]

  - job: build
    dependsOn: []
    strategy:
      matrix:
        debian:
          baseImage: debian
        alpine:
          baseImage: alpine
    pool:
      vmImage: ubuntu-18.04

    steps:

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: $(baseImage)
        command: "Clean BuildTracerHome ZipTracerHome"

    - publish: $(tracerHome)
      displayName: Uploading linux tracer home artifact
      artifact: linux-tracer-home-$(baseImage)

    - publish: $(artifacts)/linux-x64
      displayName: Upload linux-x64 packages
      artifact: linux-packages-$(baseImage)

    - publish: $(System.DefaultWorkingDirectory)
      displayName: Upload working directory after the build
      artifact: build-linux-$(baseImage)-working-directory

- stage: build_arm64
  dependsOn: []
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build]

  - job: build
    dependsOn: []
    pool:
      name: Arm64
    workspace:
      clean: all
    steps:
    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: debian
        command: "Clean BuildTracerHome ZipTracerHome"

    - publish: $(tracerHome)
      displayName: Uploading linux tracer home artifact
      artifact: linux-tracer-home-arm64

    - publish: $(artifacts)/linux-arm64
      displayName: Upload linux-arm64 packages
      artifact: linux-packages-arm64

    - publish: $(System.DefaultWorkingDirectory)
      displayName: Upload working directory after the build
      artifact: build-linux-arm64-working-directory

- stage: build_macos
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'))
  dependsOn: []
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build]

  - job: build
    dependsOn: [ ]
    pool:
      vmImage: macOS-10.15
    steps:
    - template: steps/install-latest-dotnet-sdk.yml

    - script: ./tracer/build.sh BuildTracerHome
      displayName: Build tracer home

    - publish: $(tracerHome)
      displayName: Uploading macos profiler artifact
      artifact: macos-tracer-home

    - publish: $(System.DefaultWorkingDirectory)
      displayName: Upload working directory after the build
      artifact: build-macos-working-directory

- stage: package_windows
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'))
  dependsOn: build_windows
  pool:
    vmImage: windows-2019
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [msi_and_pack]

  - job: msi_and_pack
    variables:
      # Temporarily use the profiling repo's commit hash for the beta MSI's filename
      BetaMsiSuffix: $[ stageDependencies.build_windows.build.outputs['SetMsiSuffix.BetaMsiSuffix']]
    steps:
      - template: steps/install-latest-dotnet-sdk.yml
      - template: steps/restore-working-directory.yml
      - script: echo $(BetaMsiSuffix) # TODO Remove

      - task: DownloadPipelineArtifact@2
        displayName: Download windows profiler home
        inputs:
          artifact: windows-profiler-home
          path: $(profilerHome)

      - script: tracer\build.cmd PackageTracerHome
        displayName: Build MSI and Tracer home

      - script: tracer\build.cmd PackageMonitoringHomeBeta
        displayName: Build beta MSI

      - publish: $(artifacts)/windows-tracer-home.zip
        displayName: Publish tracer-home.zip
        artifact: windows-tracer-home.zip

      - publish: $(artifacts)/x86/en-us
        displayName: Publish Windows x86 MSI
        artifact: windows-msi-x86

      - publish: $(artifacts)/x64/en-us
        displayName: Publish Windows x64 MSI
        artifact: windows-msi-x64

      - publish: $(artifacts)/nuget
        displayName: Publish NuGet packages
        artifact: nuget-packages

- stage: unit_tests_windows
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'))
  dependsOn: build_windows
  pool:
    vmImage: windows-2019
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [managed, native]

    - job: managed
      steps:
      - template: steps/install-dotnet.yml
      - template: steps/restore-working-directory.yml

      - script: tracer\build.cmd BuildAndRunManagedUnitTests --code-coverage
        displayName: Build and Test

      - publish: tracer/build_data
        artifact: profiler-logs_unit_tests_windows_$(System.JobAttempt)
        condition: succeededOrFailed()
        continueOnError: true

      - task: PublishTestResults@2
        displayName: publish test results
        inputs:
          testResultsFormat: VSTest
          testResultsFiles: tracer/build_data/results/**/*.trx
        condition: succeededOrFailed()

    - job: native
      steps:
      - template: steps/install-dotnet.yml
      - template: steps/restore-working-directory.yml

      - script: tracer\build.cmd BuildAndRunNativeUnitTests
        displayName: Build and Test

      - task: PublishTestResults@2
        displayName: publish test results
        inputs:
          testResultsFiles: tracer/test/**/test*.xml
        condition: succeededOrFailed()

- stage: unit_tests_macos
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'))
  dependsOn: build_macos
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [managed]

  - job: managed
    pool:
      vmImage: macOS-10.15
    steps:
      - template: steps/install-dotnet.yml
      - template: steps/restore-working-directory.yml
        parameters:
          artifact: build-macos-working-directory

      - script: ./tracer/build.sh BuildAndRunManagedUnitTests --code-coverage
        displayName: Build and Test

      - publish: tracer/build_data
        artifact: profiler-logs_unit_tests_macos_$(System.JobAttempt)
        condition: succeededOrFailed()
        continueOnError: true

      - task: PublishTestResults@2
        displayName: publish test results
        inputs:
          testResultsFormat: VSTest
          testResultsFiles: tracer/build_data/results/**/*.trx
        condition: succeededOrFailed()

- stage: unit_tests_linux
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'))
  dependsOn: [build_linux]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [test]

  - job: test
    strategy:
      matrix:
        debian:
          baseImage: debian
        alpine:
          baseImage: alpine
    pool:
      vmImage: ubuntu-18.04

    steps:
    - template: steps/restore-working-directory.yml
      parameters:
        artifact: build-linux-$(baseImage)-working-directory

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: $(baseImage)
        command: "BuildAndRunManagedUnitTests --code-coverage"

    - publish: tracer/build_data
      artifact: profiler-logs_unit_tests_linux_$(Agent.JobName)_$(System.JobAttempt)
      condition: succeededOrFailed()
      continueOnError: true

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: tracer/build_data/results/**/*.trx
      condition: succeededOrFailed()

- stage: unit_tests_arm64
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'))
  dependsOn: [build_arm64]
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [test]

    - job: test
      pool:
        name: Arm64
      workspace:
        clean: all
      steps:
        - template: steps/restore-working-directory.yml
          parameters:
            artifact: build-linux-arm64-working-directory

        - template: steps/run-in-docker.yml
          parameters:
            build: true
            baseImage: debian
            command: "BuildAndRunManagedUnitTests"

        - publish: tracer/build_data
          artifact: profiler-logs_unit_tests_linux_$(Agent.JobName)_$(System.JobAttempt)
          condition: succeededOrFailed()
          continueOnError: true

        - task: PublishTestResults@2
          displayName: publish test results
          inputs:
            testResultsFormat: VSTest
            testResultsFiles: tracer/build_data/results/**/*.trx
          condition: succeededOrFailed()

- stage: integration_tests_windows
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'))
  dependsOn: build_windows

  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Win]

  - job: generator
    pool:
      vmImage: ubuntu-18.04
    steps:
    - checkout: none
    - bash: |
        matrix="{"
        for framework in "net461" "netcoreapp2.1" "netcoreapp3.0" "netcoreapp3.1" "net5.0" "net6.0"; do
          for platform in "x64" "x86"; do
            name="${platform}_${framework//./_}"
            if [ $target == "BuildAndRunWindowsIntegrationTests" ]; then cosmos=true; else cosmos=false; fi
            matrix="${matrix} '${name}':"
            matrix="${matrix} { 'framework': '${framework}', "
            matrix="${matrix} 'targetPlatform': '${platform}' },"
          done
        done
        matrix="${matrix::-1} }"
        echo "##vso[task.setVariable variable=values;isOutput=true]${matrix}"
      name: mtrx

  - job: Win
    dependsOn: generator
    pool:
      vmImage: windows-2019
    timeoutInMinutes: 100
    strategy:
      matrix: $[ dependencies.generator.outputs['mtrx.values'] ]

    steps:
    - template: steps/install-dotnet-sdks.yml
      parameters:
        includeX86: true
    - template: steps/restore-working-directory.yml

    - powershell: |
        Write-Host "Starting CosmosDB Emulator"
        Import-Module "C:/Program Files/Azure Cosmos DB Emulator/PSModules/Microsoft.Azure.CosmosDB.Emulator"
        Start-CosmosDbEmulator -Timeout 300
      displayName: 'Start CosmosDB Emulator'
      workingDirectory: $(Pipeline.Workspace)

    - powershell: |
        Write-Host "Initializing LocalDB"
        sqllocaldb.exe start
        sqlcmd.exe -S "(localdb)\MSSQLLocalDB" -i $(Build.Repository.LocalPath)\.azure-pipelines\prepare_localdb.sql
      displayName: 'Initialize LocalDB'
      workingDirectory: $(Build.Repository.LocalPath)

    - script: tracer\build.cmd BuildAndRunWindowsIntegrationTests BuildAndRunWindowsRegressionTests -Framework $(framework) --PrintDriveSpace --code-coverage
      displayName: Run integration tests

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: tracer/build_data/results/**/*.trx
      condition: succeededOrFailed()

    - publish: tracer/build_data
      displayName: Uploading integration_tests_windows tracer logs
      artifact: integration_tests_windows_tracer_logs_$(targetPlatform)_$(framework)_$(System.JobAttempt)
      condition: succeededOrFailed()
      continueOnError: true

    - script: tracer\build.cmd CheckBuildLogsForErrors
      displayName: Check logs for errors

- stage: integration_tests_windows_iis
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'))
  dependsOn: [build_windows, package_windows]

  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [IIS]

  - job: generator
    pool:
      vmImage: ubuntu-18.04
    steps:
      - checkout: none
      - bash: |
          matrix="{"
          for framework in "net461" "netcoreapp2.1" "netcoreapp3.0" "netcoreapp3.1" "net5.0" "net6.0"; do
            for platform in "x64" "x86"; do
              name="${framework//./_}_${platform}"
              if [ $platform == "x86" ]; then enable32bit=true; else enable32bit=false; fi
              matrix="${matrix} '${name}':"
              matrix="${matrix} { 'framework': '${framework}', "
              matrix="${matrix} 'targetPlatform': '${platform}', "
              matrix="${matrix} 'enable32bit': ${enable32bit} },"
            done
          done
          matrix="${matrix::-1} }"
          echo "##vso[task.setVariable variable=values;isOutput=true]${matrix}"
        name: mtrx

  - job: IIS
    timeoutInMinutes: 100
    dependsOn: generator
    strategy:
      matrix: $[ dependencies.generator.outputs['mtrx.values'] ]
    pool:
      vmImage: windows-2019
    variables:
      relativeMsiOutputDirectory: $(relativeArtifacts)/$(targetPlatform)/en-us

    steps:

    - template: steps/install-dotnet-sdks.yml
      parameters:
        includeX86: true
    - template: steps/restore-working-directory.yml

    - task: DownloadPipelineArtifact@2
      displayName: Download MSI
      inputs:
        artifact: windows-msi-$(targetPlatform)
        patterns: '**/*.msi'
        path: $(System.DefaultWorkingDirectory)/$(relativeMsiOutputDirectory)

    - script: tracer\build.cmd BuildWindowsIntegrationTests -Framework $(framework)
      displayName: BuildWindowsIntegrationTests

    - powershell: |
        $Iterations = 5
        do {
            Try{
              docker-compose build --build-arg dotnet_tracer_msi=.$(relativeMsiOutputDirectory)/*.msi --build-arg ENABLE_32_BIT=$(enable32bit) IntegrationTests.IIS
              docker-compose up -d IntegrationTests.IIS
              $Iterations = 0
          } catch { 
            echo "Retrying... "
            Start-Sleep -s 1
            $Iterations = $Iterations - 1 }
        } while ($Iterations -gt 0)
      displayName: docker-compose start IntegrationTests.IIS

    - script: tracer\build.cmd RunWindowsIisIntegrationTests -Framework $(framework) --code-coverage
      displayName: RunWindowsIisIntegrationTests

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: tracer/build_data/results/**/*.trx
      condition: succeededOrFailed()

    - task: DockerCompose@0
      displayName: docker-compose stop services
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: down
      condition: succeededOrFailed()

    - publish: tracer/build_data
      displayName: Uploading integration_tests_windows_iis tracer logs
      artifact: integration_tests_windows_iis_tracer_logs_$(targetPlatform)_$(framework)
      condition: succeededOrFailed()
      continueOnError: true

    - script: tracer\build.cmd CheckBuildLogsForErrors
      displayName: Check logs for errors

- stage: integration_tests_linux
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'))
  dependsOn: [build_linux]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Test]

  - job: Test
    strategy:
      matrix:
        debian_netcoreapp2_1:
          publishTargetFramework: netcoreapp2.1
          baseImage: debian
        debian_netcoreapp3_0:
          publishTargetFramework: netcoreapp3.0
          baseImage: debian
        debian_netcoreapp3_1:
          publishTargetFramework: netcoreapp3.1
          baseImage: debian
        debian_net5_0:
          publishTargetFramework: net5.0
          baseImage: debian
        debian_net6_0:
          publishTargetFramework: net6.0
          baseImage: debian
        alpine_netcoreapp2_1:
          publishTargetFramework: netcoreapp2.1
          baseImage: alpine
        alpine_netcoreapp3_0:
          publishTargetFramework: netcoreapp3.0
          baseImage: alpine
        alpine_netcoreapp3_1:
          publishTargetFramework: netcoreapp3.1
          baseImage: alpine
        alpine_net5_0:
          publishTargetFramework: net5.0
          baseImage: alpine
        alpine_net6_0:
          publishTargetFramework: net6.0
          baseImage: alpine

    variables:
      TestAllPackageVersions: true
      IncludeMinorPackageVersions:  $[or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.perform_comprehensive_testing, 'true'))]

    pool:
      vmImage: ubuntu-18.04

    steps:
    # Doing a clean of obj files _before_ restore to remove build output from previous runs
    # Can't do a full clean, as otherwise restore-working-directory fails
    # Only necessary for ARM64, but shouldn't cause any harm on others
    # Can't ifdef it as depends on a matrix variable
    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: $(baseImage)
        command: "CleanObjFiles"

    - template: steps/restore-working-directory.yml
      parameters:
        artifact: build-linux-$(baseImage)-working-directory

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: $(baseImage)
        command: "BuildLinuxIntegrationTests --framework $(publishTargetFramework)"

    - script: |
        # retry up to 5 times to pull the docker images
        for i in 1 2 3 4 5; do 
          docker-compose -p ddtrace_$(Build.BuildNumber) build --build-arg baseImage=$(baseImage) --build-arg framework=$(publishTargetFramework) IntegrationTests && \
          docker-compose -p ddtrace_$(Build.BuildNumber) run --rm StartDependencies && \
          break || sleep 5; 
        done
      env:
        baseImage: $(baseImage)
        framework: $(publishTargetFramework)
      displayName: docker-compose build IntegrationTests and run StartDependencies

    - task: DockerCompose@0
      displayName: docker-compose run IntegrationTests
      inputs:
        containerregistrytype: Container Registry
        dockerComposeFileArgs: |
          baseImage=$(baseImage)
          framework=$(publishTargetFramework)
        dockerComposeCommand: run --rm -e baseImage=$(baseImage) -e framework=$(publishTargetFramework) IntegrationTests
        projectName: ddtrace_$(Build.BuildNumber)

    - task: DockerCompose@0
      displayName: docker-compose stop services
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: down
      condition: succeededOrFailed()

    - publish: tracer/build_data
      artifact: profiler-logs_integration_tests_linux_$(baseImage)_$(publishTargetFramework)_$(System.JobAttempt)
      condition: succeededOrFailed()
      continueOnError: true

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: tracer/build_data/results/**/*.trx
      condition: succeededOrFailed()

    - template: steps/run-in-docker.yml
      parameters:
        baseImage: $(baseImage)
        command: "CheckBuildLogsForErrors"

- stage: integration_tests_arm64
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'))
  dependsOn: [build_arm64]
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [Test]

    - job: Test
      strategy:
        matrix:
          net5_0:
            publishTargetFramework: net5.0
          net6_0:
            publishTargetFramework: net6.0
      variables:
        TestAllPackageVersions: true
        IncludeMinorPackageVersions:  $[or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.perform_comprehensive_testing, 'true'))]
        baseImage: debian
      workspace:
        clean: all
      pool:
        name: Arm64

      steps:
        # Doing a clean of obj files _before_ restore to remove build output from previous runs
        # Can't do a full clean, as otherwise restore-working-directory fails
        # Only necessary for ARM64, but shouldn't cause any harm on others
        - template: steps/run-in-docker.yml
          parameters:
            build: true
            baseImage: $(baseImage)
            command: "CleanObjFiles"

        - template: steps/restore-working-directory.yml
          parameters:
            artifact: build-linux-arm64-working-directory

        - template: steps/run-in-docker.yml
          parameters:
            build: true
            baseImage: $(baseImage)
            command: "BuildLinuxIntegrationTests --framework $(publishTargetFramework)"

        - script: |
            # retry up to 5 times to pull the docker images
            for i in 1 2 3 4 5; do 
              docker-compose -p ddtrace_$(Build.BuildNumber) build --build-arg baseImage=$(baseImage) --build-arg framework=$(publishTargetFramework) IntegrationTests.ARM64 && \
              docker-compose -p ddtrace_$(Build.BuildNumber) run --rm StartDependencies.ARM64 && \
              break || sleep 1; 
            done
          env:
            baseImage: $(baseImage)
            framework: $(publishTargetFramework)
          displayName: docker-compose build IntegrationTests and run StartDependencies

        - task: DockerCompose@0
          displayName: docker-compose run IntegrationTests
          inputs:
            containerregistrytype: Container Registry
            dockerComposeFileArgs: |
              baseImage=$(baseImage)
              framework=$(publishTargetFramework)
            dockerComposeCommand: run --rm -e baseImage=$(baseImage) -e framework=$(publishTargetFramework) IntegrationTests.ARM64
            projectName: ddtrace_$(Build.BuildNumber)

        - task: DockerCompose@0
          displayName: docker-compose stop services
          inputs:
            containerregistrytype: Container Registry
            dockerComposeCommand: down
            projectName: ddtrace_$(Build.BuildNumber)
          condition: succeededOrFailed()

        - publish: tracer/build_data
          artifact: profiler-logs_integration_tests_linux_arm64_$(publishTargetFramework)_$(System.JobAttempt)
          condition: succeededOrFailed()
          continueOnError: true

        - task: PublishTestResults@2
          displayName: publish test results
          inputs:
            testResultsFormat: VSTest
            testResultsFiles: tracer/build_data/results/**/*.trx
          condition: succeededOrFailed()

        - template: steps/run-in-docker.yml
          parameters:
            baseImage: $(baseImage)
            command: "CheckBuildLogsForErrors"

- stage: exploration_tests_windows
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'), eq(variables['runExplorationTests'], 'True'))
  dependsOn: build_windows

  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [ExplorationTest]

  - job: generator
    pool:
      vmImage: ubuntu-18.04
    steps:
      - bash: |
          matrix="{"
          for explorationTestUseCase in "debugger" "continuousProfiler"; do
            for explorationTestName in "eshoponweb" "protobuf" "cake" "swashbuckle" "paket" ; do
              name="${explorationTestUseCase//./_}_${explorationTestName}"
              matrix="${matrix} '${name}':"
              matrix="${matrix} { 'explorationTestUseCase': '${explorationTestUseCase}', "
              matrix="${matrix} 'explorationTestName': '${explorationTestName}' },"
            done
          done
          matrix="${matrix::-1} }"
          echo "##vso[task.setVariable variable=values;isOutput=true]${matrix}"
        name: mtrx

  - job: ExplorationTest
    timeoutInMinutes: 100
    dependsOn: generator
    strategy:
      matrix: $[ dependencies.generator.outputs['mtrx.values'] ]
    pool:
      vmImage: windows-2019

    # Enable the Datadog Agent service for this job
    services:
      dd_agent: dd_agent

    steps:
    - template: steps/install-dotnet-sdks.yml
      parameters:
        includeX86: true
    - template: steps/restore-working-directory.yml

    - script: tracer\build.cmd RunExplorationTests_$(explorationTestUseCase) -ExplorationTestName $(explorationTestName)
      displayName: RunExplorationTest

    - publish: tracer/build_data
      displayName: Uploading exploration_tests_windows tracer logs
      artifact: exploration_tests_windows_tracer_logs_$(explorationTestUseCase)_$(explorationTestName)
      condition: succeededOrFailed()
      continueOnError: true

    - script: tracer\build.cmd CheckBuildLogsForErrors
      displayName: Check logs for errors

- stage: exploration_tests_linux
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'))
  dependsOn: [build_linux]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Test]

  - job: generator
    pool:
      vmImage: ubuntu-18.04
    steps:
      - bash: |
          matrix="{"
          for baseImage in "debian" "alpine";
            for publishTargetFramework in "netcoreapp2.1" "netcoreapp3.1" "net5.0" "net6.0";
              for explorationTestUseCase in "debugger" "continuousProfiler"; do
                for explorationTestName in "eshoponweb" "cake" ; do
                  name="${baseImage//./_}_${publishTargetFramework//./_}_${explorationTestUseCase//./_}_${explorationTestName}"
                  matrix="${matrix} '${name}':"
                  matrix="${matrix} { 'baseImage': '${baseImage}', "
                  matrix="${matrix} 'publishTargetFramework': '${publishTargetFramework}', "
                  matrix="${matrix} 'explorationTestUseCase': '${explorationTestUseCase}', "
                  matrix="${matrix} 'explorationTestName': '${explorationTestName}' },"
                done
              done
            done
          done
          matrix="${matrix::-1} }"
          echo "##vso[task.setVariable variable=values;isOutput=true]${matrix}"
        name: mtrx


  - job: Test
    dependsOn: generator
    strategy:
      matrix: $[ dependencies.generator.outputs['mtrx.values'] ]

    variables:
      TestAllPackageVersions: true
      IncludeMinorPackageVersions:  $[or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.perform_comprehensive_testing, 'true'))]

    pool:
      vmImage: ubuntu-18.04

    steps:
    # Doing a clean of obj files _before_ restore to remove build output from previous runs
    # Can't do a full clean, as otherwise restore-working-directory fails
    # Only necessary for ARM64, but shouldn't cause any harm on others
    # Can't ifdef it as depends on a matrix variable
    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: $(baseImage)
        command: "CleanObjFiles"

    - template: steps/restore-working-directory.yml
      parameters:
        artifact: build-linux-$(baseImage)-working-directory

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: $(baseImage)
        command: "RunExplorationTests_$(explorationTestUseCase) --framework $(publishTargetFramework) --explorationTestName $(explorationTestName)"

    - task: DockerCompose@0
      displayName: docker-compose build ExplorationTests
      env:
        baseImage: $(baseImage)
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: build --build-arg baseImage=$(baseImage) --build-arg framework=$(publishTargetFramework) ExplorationTests

    - task: DockerCompose@0
      displayName: docker-compose start dependencies
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: run --rm StartDependencies

    - task: DockerCompose@0
      displayName: docker-compose run ExplorationTests
      inputs:
        containerregistrytype: Container Registry
        dockerComposeFileArgs: |
          baseImage=$(baseImage)
          framework=$(publishTargetFramework)
        dockerComposeCommand: run --rm -e baseImage=$(baseImage) -e framework=$(publishTargetFramework) ExplorationTests

    - task: DockerCompose@0
      displayName: docker-compose stop services
      inputs:
        containerregistrytype: Container Registry
        dockerComposeCommand: down
      condition: succeededOrFailed()

    - publish: tracer/build_data
      artifact: profiler-logs_exploration_tests_linux_$(baseImage)_$(publishTargetFramework)_$(explorationTestUseCase)_$(explorationTestName)_$(System.JobAttempt)
      condition: succeededOrFailed()
      continueOnError: true

    - template: steps/run-in-docker.yml
      parameters:
        baseImage: $(baseImage)
        command: "CheckBuildLogsForErrors"


- stage: benchmarks
  condition: and(succeeded(), ne(variables['isNgenTestBuild'], 'True'))
  dependsOn: build_windows
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Windows]

  #### Windows

  - job: Windows
    timeoutInMinutes: 100
    pool: Benchmarks

    # Enable the Datadog Agent service for this job
    services:
      dd_agent: dd_agent

    steps:

    - template: steps/install-latest-dotnet-sdk.yml
    - template: steps/restore-working-directory.yml

    - script: tracer\build.cmd RunBenchmarks
      displayName: RunBenchmarks

    - publish: tracer/build_data/benchmarks
      artifact: benchmarks_results

    - script: tracer\build.cmd CompareBenchmarksResults
      continueOnError: true
      displayName: Compare Benchmarks
      condition: and(succeeded(), eq(variables.isPullRequest, true))
      env:
        PR_NUMBER: $(System.PullRequest.PullRequestNumber)
        AZURE_DEVOPS_TOKEN: $(AZURE_DEVOPS_TOKEN)
        GITHUB_TOKEN: $(GITHUB_TOKEN)

    ## Is this really necessary?
    - task: PowerShell@2
      inputs:
        targetType: 'inline'
        script: 'Start-Sleep -s 120'

- stage: dotnet_tool
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'), ne(variables['isNgenTestBuild'], 'True'))
  dependsOn: [build_windows, build_linux, build_arm64, build_macos]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build_runner_tool_and_standalone]

  - job: build_runner_tool_and_standalone

    pool:
      vmImage: windows-2019

    # Enable the Datadog Agent service for this job
    services:
      dd_agent: dd_agent

    steps:
    - template: steps/install-latest-dotnet-sdk.yml
    - template: steps/restore-working-directory.yml

    - task: DownloadPipelineArtifact@2
      displayName: Download windows tracer home
      inputs:
        artifact: windows-tracer-home
        path: $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Monitoring.Distribution/home

    - task: DownloadPipelineArtifact@2
      displayName: Download linux shell scripts
      inputs:
        artifact: linux-tracer-home-debian
        patterns: "*.sh"
        path: $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Monitoring.Distribution/home

    - task: DownloadPipelineArtifact@2
      displayName: Download linux tracer home
      inputs:
        artifact: linux-tracer-home-debian
        patterns: "**/*.so"
        path: $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Monitoring.Distribution/home/linux-x64

    - task: DownloadPipelineArtifact@2
      displayName: Download alpine tracer home
      inputs:
        artifact: linux-tracer-home-alpine
        patterns: "**/*.so"
        path: $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Monitoring.Distribution/home/linux-musl-x64

    - task: DownloadPipelineArtifact@2
      displayName: Download arm64 tracer home
      inputs:
        artifact: linux-tracer-home-arm64
        patterns: "**/*.so"
        path: $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Monitoring.Distribution/home/linux-arm64

    - task: DownloadPipelineArtifact@2
      displayName: Download osx tracer home
      inputs:
        artifact: macos-tracer-home
        patterns: "**/*.dylib"
        path: $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Monitoring.Distribution/home/osx-x64

    # Install the tracer latest stable release to attach the profiler to the build and test steps.
    # The script exposes the required environment variables to the following steps
    - task: PowerShell@2
      displayName: Install profiler latest release
      inputs:
        filePath: ./.azure-pipelines/setup_tracer.ps1

    - script: tracer\build.cmd BuildDistributionNuget --skip
      displayName: Build BuildDistributionNuget package

    - script: tracer\build.cmd BuildRunnerTool --skip
      displayName: Build Runner tool

    - script: tracer\build.cmd BuildStandaloneTool --skip
      displayName: Build Standalone tool

    - task: DeleteFiles@1
      displayName: 'Remove unneeded files'
      inputs:
        Contents: |
          $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Tool/!(*.nupkg)
          $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/win-x64/home*
          $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/win-x86/home*
          $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/linux-x64/home*
          $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/linux-musl-x64/home*
          $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/linux-arm64/home*
          $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/osx-x64/home*

    - publish: $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Monitoring.Distribution/bin/$(buildConfiguration)/packages
      displayName: Publish Distribution package
      artifact: distribution-nuget-package

    - publish: $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Tool
      displayName: Uploading runner dotnet tool artifact
      artifact: runner-dotnet-tool

    - publish: $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/win-x64
      displayName: Uploading runner standalone win-x64 artifact
      artifact: runner-standalone-win-x64

    - publish: $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/win-x86
      displayName: Uploading runner standalone win-x86 artifact
      artifact: runner-standalone-win-x86

    - publish: $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/linux-x64
      displayName: Uploading runner standalone linux-x64 artifact
      artifact: runner-standalone-linux-x64

    - publish: $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/linux-musl-x64
      displayName: Uploading runner standalone linux-musl-x64 artifact
      artifact: runner-standalone-linux-musl-x64

    - publish: $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/linux-arm64
      displayName: Uploading runner standalone linux-arm64 artifact
      artifact: runner-standalone-linux-arm64

    - publish: $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Trace.Tools.Runner/bin/$(buildConfiguration)/Console/publish/osx-x64
      displayName: Uploading runner standalone osx-x64 artifact
      artifact: runner-standalone-osx-x64

    - powershell: |
        echo "##vso[build.addbuildtag]$(dotnetToolTag)"
      displayName: Add $(dotnetToolTag) build tag

- stage: upload_to_s3
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'), ne(variables['isNgenTestBuild'], 'True'))
  dependsOn: [package_windows, build_linux, build_arm64]
  jobs:
  - job: s3_upload

    pool:
      vmImage: ubuntu-18.04

    steps:

    - script: |
        mkdir s3_upload
      displayName: create s3_upload folder

    - task: DownloadPipelineArtifact@2
      displayName: Download x64 Windows MSI
      inputs:
        artifact: windows-msi-x64
        patterns: '**/*x64.msi'
        path: s3_upload

    - task: DownloadPipelineArtifact@2
      displayName: Download linux-packages
      inputs:
        artifact: linux-packages-debian
        patterns: '**/*amd64.deb'
        path: s3_upload

    # for prerelease versions, rename datadog-dotnet-apm-{version}-amd64.deb
    # to datadog-dotnet-apm-{version}-{tag}-amd64.deb (i.e. add the prerelease tag)
    # by copying most of the filename from datadog-dotnet-apm-{version}-{tag}-x64.msi
    - script: |
        MSI_NAME=$(ls s3_upload/*.msi)
        PACKAGE_NAME=${MSI_NAME::-8}
        echo Renaming deb package to $PACKAGE_NAME-amd64.deb
        mv s3_upload/*.deb $PACKAGE_NAME-amd64.deb
      displayName: Rename deb package name to match MSI name

    # Create index.txt file with the following format:
    # BRANCH_NAME
    # SHA
    # ARTIFACT WILDCARD (datadog-dotnet-apm-vX.X.X-*)
    # COMMIT AUTHOR
    # Note: For the branch name, normalize 'refs/heads/<branch>' to '<branch>' and 'refs/tags/<tag_name>' to 'tags/<tag_name>'
    - script: |
        INDEX_FILE=$(pwd)/s3_upload/index.txt
        echo $(Build.SourceBranch) | sed 's/refs\/heads\///g' | sed 's/refs\/tags\//tags\//g' >> $INDEX_FILE
        git rev-parse HEAD >> $INDEX_FILE
        pushd s3_upload && name=$(ls *.deb) && echo "${name::-9}*" >> $INDEX_FILE && popd
        git show -s --format='%ae' HEAD >> $INDEX_FILE
        echo Generated index.txt file:
        cat $INDEX_FILE
      displayName: Write index.txt

    - script: tree s3_upload
      displayName: 'tree s3_upload'

    - script: |
        sudo apt-get install -y unzip python3-setuptools
        curl "https://s3.amazonaws.com/aws-cli/awscli-bundle.zip" -o "awscli-bundle.zip"
        unzip awscli-bundle.zip
        sudo python3 ./awscli-bundle/install -i /usr/local/aws -b /usr/local/bin/aws
        aws --version
      displayName: Install AWS CLI

    - script: aws configure set aws_access_key_id $SECRET
      displayName: Authenticate aws_access_key_id
      env:
        SECRET: $(AWS_ACCESS_KEY_ID)

    - script: aws configure set aws_secret_access_key $SECRET
      displayName: Authenticate aws_secret_access_key
      env:
        SECRET: $(AWS_SECRET_ACCESS_KEY)

    # by default, run this step on master branch only.
    # use "push_artifacts_to_s3" to override:
    #   "true": run this step
    #   "false": do NOT run this step
    #   else: run this stage if branch is master

    - script: aws s3 cp s3_upload s3://datadog-reliability-env/dotnet/ --recursive
      displayName: Upload deb, MSI, index.txt to s3
      condition: >
        and(
          succeeded(),
          ne(variables['push_artifacts_to_s3'], 'false'),
          or(
            eq(variables['push_artifacts_to_s3'], 'true'),
            eq(variables.isMainBranch, true)
          )
        )

- stage: upload_to_azure
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'))
  dependsOn: [package_windows, build_linux, build_arm64, dotnet_tool]
  jobs:
    - job: upload
      pool:
        vmImage: ubuntu-18.04
      steps:

        - task: DownloadPipelineArtifact@2
          displayName: Download NuGet packages
          inputs:
            artifact: nuget-packages
            path: $(Build.ArtifactStagingDirectory)

        # set the version from the package name
        - bash: |
            NUGET_NAME=$(basename $(Build.ArtifactStagingDirectory)/Datadog.Trace.OpenTracing.*.nupkg)
            VERSION_NUMBER=${NUGET_NAME:26:-6}
            echo "detected version: $VERSION_NUMBER"
            echo "##vso[task.setvariable variable=tracer_version]$VERSION_NUMBER"
          displayName: Extract version number

        - task: DownloadPipelineArtifact@2
          displayName: Download linux Alpine packages
          inputs:
            artifact: linux-packages-alpine
            path: $(Build.ArtifactStagingDirectory)

        - task: DownloadPipelineArtifact@2
          displayName: Download linux Debian packages
          inputs:
            artifact: linux-packages-debian
            path: $(Build.ArtifactStagingDirectory)

        - task: DownloadPipelineArtifact@2
          displayName: Download linux Arm64 packages
          inputs:
            artifact: linux-packages-arm64
            path: $(Build.ArtifactStagingDirectory)

        - task: DownloadPipelineArtifact@2
          displayName: Download Windows tracer home
          inputs:
            artifact: windows-tracer-home.zip
            path: $(Build.ArtifactStagingDirectory)

        - task: DownloadPipelineArtifact@2
          displayName: Download distribution nuget package
          inputs:
            artifact: distribution-nuget-package
            path: $(Build.ArtifactStagingDirectory)

        - task: DownloadPipelineArtifact@2
          displayName: Download runner dotnet tool
          inputs:
            artifact: runner-dotnet-tool
            patterns: "*.nupkg"
            path: $(Build.ArtifactStagingDirectory)

        - publish: "$(Build.ArtifactStagingDirectory)"
          displayName: Publish release artifacts
          artifact: $(tracer_version)-release-artifacts

        # We don't include the MSIs in the artifact upload as they're
        # not signed, but we do include them in the push to Azure
        - task: DownloadPipelineArtifact@2
          displayName: Download x64 MSI
          inputs:
            artifact: windows-msi-x64
            path: $(Build.ArtifactStagingDirectory)

        - task: DownloadPipelineArtifact@2
          displayName: Download x86 MSI
          inputs:
            artifact: windows-msi-x86
            path: $(Build.ArtifactStagingDirectory)

        - bash: |
            az storage blob upload-batch \
              --destination "$(AZURE_STORAGE_CONTAINER_NAME)" \
              --destination-path "$(Build.SourceVersion)" \
              --source "$(Build.ArtifactStagingDirectory)"
          displayName: Upload blobs to Azure
          condition: and(succeeded(), eq(variables.isMainBranch, true), ne(variables['isNgenTestBuild'], 'True'))
          env:
            AZURE_STORAGE_ACCOUNT: $(AZURE_STORAGE_ACCOUNT_NAME)
            AZURE_STORAGE_SAS_TOKEN: $(AZURE_STORAGE_SHARED_ACCESS_TOKEN)

        - bash: ls "$(Build.ArtifactStagingDirectory)" > index.txt
          displayName: Write file list to index.txt

        - bash: echo "$(Build.SourceVersion)" > sha.txt
          displayName: Write commit hash to sha.txt

        - bash: echo "$(tracer_version)" > version.txt
          displayName: Write tracer version number to version.txt

        - bash: |
            az storage blob upload --container-name "$(AZURE_STORAGE_CONTAINER_NAME)" --file "index.txt" --name "index.txt"
            az storage blob upload --container-name "$(AZURE_STORAGE_CONTAINER_NAME)" --file "sha.txt" --name "sha.txt"
            az storage blob upload --container-name "$(AZURE_STORAGE_CONTAINER_NAME)" --file "version.txt" --name "version.txt"
          displayName: Upload indexes to Azure
          condition: and(succeeded(), eq(variables.isMainBranch, true), ne(variables['isNgenTestBuild'], 'True'))
          env:
            AZURE_STORAGE_ACCOUNT: $(AZURE_STORAGE_ACCOUNT_NAME)
            AZURE_STORAGE_SAS_TOKEN: $(AZURE_STORAGE_SHARED_ACCESS_TOKEN)

- stage: throughput
  condition: and(succeeded(), ne(variables['isNgenTestBuild'], 'True'))
  dependsOn: [build_linux, build_arm64, build_windows]
  pool: Throughput
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Linux64, Windows64, LinuxArm64]
  #### Throughput Linux 64, windows 64, linux arm 64

  - job: Linux64
    timeoutInMinutes: 60

    steps:
    - task: DownloadPipelineArtifact@2
      displayName: Download linux native binary
      inputs:
        artifact: linux-tracer-home-debian
        path: $(System.DefaultWorkingDirectory)/tracer/tracer-home-linux

    - script: |
        test ! -s "tracer/tracer-home-linux/Datadog.Trace.ClrProfiler.Native.so" && echo "tracer/tracer-home-linux/Datadog.Trace.ClrProfiler.Native.so does not exist" && exit 1
        test ! -s "tracer/tracer-home-linux/libddwaf.so" && echo "tracer/tracer-home-linux/libddwaf.so does not exist" && exit 1
        cd $(System.DefaultWorkingDirectory)/tracer/build/crank
        chmod +x ./run.sh
        ./run.sh "linux"
      displayName: Crank
      env:
        DD_SERVICE: dd-trace-dotnet

  - job: Windows64
    timeoutInMinutes: 60

    steps:
    - task: DownloadPipelineArtifact@2
      displayName: Download windows native binary
      inputs:
        artifact: windows-tracer-home
        path: $(System.DefaultWorkingDirectory)/tracer/tracer-home-win

    - script: |
        test ! -s "tracer/tracer-home-win/win-x64/Datadog.Trace.ClrProfiler.Native.dll" && echo "tracer/tracer-home-win/win-x64/Datadog.Trace.ClrProfiler.Native.dll does not exist" && exit 1
        test ! -s "tracer/tracer-home-win/win-x64/ddwaf.dll" && echo "tracer/tracer-home-win/win-x64/ddwaf.dll does not exist" && exit 1
        cd $(System.DefaultWorkingDirectory)/tracer/build/crank
        chmod +x ./run.sh
        ./run.sh "windows"
      displayName: Crank
      env:
        DD_SERVICE: dd-trace-dotnet

  - job: LinuxArm64
    timeoutInMinutes: 60

    steps:
    - task: DownloadPipelineArtifact@2
      displayName: Download arm64 native binary
      inputs:
        artifact: linux-tracer-home-arm64
        path: $(System.DefaultWorkingDirectory)/tracer/tracer-home-linux-arm64

    - script: |
        test ! -s "tracer/tracer-home-linux-arm64/Datadog.Trace.ClrProfiler.Native.so" && echo "tracer/tracer-home-linux-arm64/Datadog.Trace.ClrProfiler.Native.so does not exist" && exit 1
        cd $(System.DefaultWorkingDirectory)/tracer/build/crank
        chmod +x ./run.sh
        ./run.sh "linux_arm64"
      displayName: Crank
      env:
        DD_SERVICE: dd-trace-dotnet
        DD_ENV: CI

- stage: throughput_appsec
  condition: and(succeeded(), ne(variables['isNgenTestBuild'], 'True'))
  dependsOn: [build_linux]
  pool: Throughput-AppSec
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Linux64]
  #### Throughput-AppSec Linux 64

  - job: Linux64
    timeoutInMinutes: 60

    steps:
    - task: DownloadPipelineArtifact@2
      displayName: Download linux native binary
      inputs:
        artifact: linux-tracer-home-debian
        path: $(System.DefaultWorkingDirectory)/tracer/tracer-home-linux

    - script: |
        test ! -s "tracer/tracer-home-linux/Datadog.Trace.ClrProfiler.Native.so" && echo "tracer/tracer-home-linux/Datadog.Trace.ClrProfiler.Native.so does not exist" && exit 1
        test ! -s "tracer/tracer-home-linux/libddwaf.so" && echo "tracer/tracer-home-linux/libddwaf.so does not exist" && exit 1
        cd $(System.DefaultWorkingDirectory)/tracer/build/crank
        chmod +x ./run-appsec.sh
        ./run-appsec.sh "linux"
      displayName: Crank
      env:
        DD_SERVICE: dd-trace-dotnet-appsec


- stage: coverage
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'), ne(variables['isNgenTestBuild'], 'True'))
  dependsOn: [integration_tests_windows, integration_tests_windows_iis, integration_tests_linux, unit_tests_linux, unit_tests_macos, unit_tests_windows]
  jobs:
    - job: Windows
      timeoutInMinutes: 30

      pool:
        vmImage: windows-2019

      steps:
      - template: steps/install-latest-dotnet-sdk.yml
      - template: steps/restore-working-directory.yml

      - task: DownloadPipelineArtifact@2
        inputs:
          patterns: '**/coverage.cobertura.xml'
          path: $(Build.SourcesDirectory)/cover

      - task: reportgenerator@4
        inputs:
          reports: '$(Build.SourcesDirectory)\cover\**\coverage.cobertura.xml'
          targetdir: '$(Build.SourcesDirectory)\coveragereport'
          sourcedirs: '$(Build.SourcesDirectory);..'
          reporttypes: 'Cobertura'

      - task: PublishCodeCoverageResults@1
        inputs:
          codeCoverageTool: 'Cobertura'
          summaryFileLocation: '$(Build.SourcesDirectory)/coveragereport/Cobertura.xml'
          pathToSources: '$(Build.SourcesDirectory)'

      - script: tracer\build.cmd CompareCodeCoverageReports
        displayName: Compare code coverage
        condition: and(succeeded(), eq(variables.isPullRequest, true))
        env:
          PR_NUMBER: $(System.PullRequest.PullRequestNumber)
          AZURE_DEVOPS_TOKEN: $(AZURE_DEVOPS_TOKEN)
          GITHUB_TOKEN: $(GITHUB_TOKEN)

- stage: execution_benchmarks
  condition: and(succeeded(), ne(variables['isNgenTestBuild'], 'True'))
  dependsOn: [build_windows]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [windows]

  - job: windows
    pool:
      vmImage: windows-2019
    # Enable the Datadog Agent service for this job
    services:
      dd_agent: dd_agent
    steps:
    - template: steps/install-dotnet-sdks.yml
    - template: steps/restore-working-directory.yml

    - task: DownloadPipelineArtifact@2
      displayName: Download windows native binary
      inputs:
        artifact: windows-tracer-home
        path: $(System.DefaultWorkingDirectory)/tracer/bin/tracer-home

    - task: DotNetCoreCLI@2
      inputs:
        command: 'build'
        arguments: '-c Release'
        workingDirectory: $(System.DefaultWorkingDirectory)/tracer/test/test-applications/integrations/Samples.HttpMessageHandler
      displayName: 'dotnet build Release'

    - task: DotNetCoreCLI@2
      inputs:
        command: 'build'
        arguments: '-c Release'
        workingDirectory: $(System.DefaultWorkingDirectory)/tracer/test/test-applications/integrations/Samples.FakeDbCommand
      displayName: 'dotnet build Release'

    - task: GoTool@0
      displayName: 'Install Go 1.16'
      inputs:
        version: '1.16'
        goPath: '$(System.DefaultWorkingDirectory)'
        workingDirectory: $(System.DefaultWorkingDirectory)

    - task: Go@0
      displayName: 'Install timeit tool'
      inputs:
        command: 'install'
        arguments: 'github.com/tonyredondo/timeit@latest'
        workingDirectory: $(System.DefaultWorkingDirectory)

    - script: run.cmd
      workingDirectory: $(System.DefaultWorkingDirectory)/tracer/build/timeit/Samples.HttpMessageHandler
      displayName: Execute Samples.HttpMessageHandler benchmark
      env:
        DD_SERVICE: dd-trace-dotnet

    - script: run.cmd
      workingDirectory: $(System.DefaultWorkingDirectory)/tracer/build/timeit/Samples.FakeDbCommand
      displayName: Execute Samples.FakeDbCommand benchmark
      env:
        DD_SERVICE: dd-trace-dotnet

    - task: PowerShell@2
      displayName: Wait 20 seconds to agent flush before finishing pipeline
      inputs:
        targetType: 'inline'
        script: 'Start-Sleep -s 20'

- stage: system_tests
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'))
  dependsOn: [build_linux]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [test]

  - job: test
    pool:
      vmImage: ubuntu-18.04

    steps:
      - script: git clone --depth 1 https://github.com/DataDog/system-tests.git
        displayName: Get system tests repo

      - task: DownloadPipelineArtifact@2
        displayName: Download linux-packages
        inputs:
          artifact: linux-packages-debian
          patterns: '**/*tar.gz'
          path: $(Build.ArtifactStagingDirectory)

      - script: |
          PACKAGE_NAME=$(basename $(Build.ArtifactStagingDirectory)/datadog-dotnet-apm-*.tar.gz)
          echo Moving $PACKAGE_NAME to system-tests/binaries
          mv $(Build.ArtifactStagingDirectory)/$PACKAGE_NAME system-tests/binaries/
        displayName: Move dotnet binary to system test folder
      - script: ./build.sh dotnet
        workingDirectory: system-tests
        displayName: Build images

      - script: ./run.sh
        workingDirectory: system-tests
        displayName: Run tests
        env:
          DD_API_KEY: $(SYSTEM_TESTS_DD_API_KEY)

      - publish: system-tests/logs
        condition: always()
        displayName: System tests logs
        artifact: system-tests

- stage: installer_smoke_tests
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'))
  dependsOn: [build_linux]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [linux]

  - job: generator
    pool:
      vmImage: ubuntu-18.04
    steps:
    - checkout: none
    - bash: |
        matrix="{"
        for i in \
          "net6.0 6.0-bullseye-slim" \
          "net5.0 5.0-bullseye-slim" \
          "net5.0 5.0-buster-slim" \
          "net5.0 5.0-focal" \
          "netcoreapp3.1 3.1-bullseye-slim" \
          "netcoreapp3.1 3.1-buster-slim" \
          "netcoreapp3.1 3.1-bionic" \
          "netcoreapp2.1 2.1-bionic" \
          "netcoreapp2.1 2.1-stretch-slim" \
        ; do fwAndImage=( $i )
          publishFramework="${fwAndImage[0]}";
          runtimeImageTag="${fwAndImage[1]}";
          name="${runtimeImageTag//./_}"

          matrix="${matrix} '${name}':"
          matrix="${matrix} { 'installCmd': 'dpkg -i ./datadog-dotnet-apm*_amd64.deb', "
          matrix="${matrix} 'dockerTag': '${name}', "
          matrix="${matrix} 'publishFramework': '${publishFramework}', "
          matrix="${matrix} 'linuxArtifacts': 'linux-packages-debian', "
          matrix="${matrix} 'runtimeImage': 'mcr.microsoft.com/dotnet/aspnet:${runtimeImageTag}' },"
        done;

        for i in \
          "net5.0 35-5.0" \
          "netcoreapp3.1 35-3.1" \
          "net6.0 34-6.0" \
          "net5.0 34-5.0" \
          "netcoreapp3.1 34-3.1" \
          "net5.0 33-5.0" \
          "netcoreapp3.1 33-3.1" \
          "netcoreapp3.1 29-3.1" \
          "netcoreapp2.1 29-2.1" \
        ; do fwAndImage=( $i )
          publishFramework="${fwAndImage[0]}";
          runtimeImageTag="${fwAndImage[1]}";
          name="${runtimeImageTag//./_}"

          matrix="${matrix} 'fedora-${name}':"
          matrix="${matrix} { 'installCmd': 'rpm -Uvh ./datadog-dotnet-apm*-1.x86_64.rpm', "
          matrix="${matrix} 'dockerTag': '${name}', "
          matrix="${matrix} 'publishFramework': '${publishFramework}', "
          matrix="${matrix} 'linuxArtifacts': 'linux-packages-debian', "
          matrix="${matrix} 'runtimeImage': 'andrewlock/dotnet-fedora:${runtimeImageTag}' },"
        done;

        for i in \
          "net6.0 6.0-alpine3.14" \
          "net5.0 5.0-alpine3.14" \
          "net5.0 5.0-alpine3.13" \
          "netcoreapp3.1 3.1-alpine3.14" \
          "netcoreapp3.1 3.1-alpine3.13" \
          "netcoreapp2.1 2.1-alpine3.12" \
        ; do fwAndImage=( $i )
          publishFramework="${fwAndImage[0]}";
          runtimeImageTag="${fwAndImage[1]}";
          name="${runtimeImageTag//./_}"

          matrix="${matrix} '${name}':"
          matrix="${matrix} { 'installCmd': 'tar -C /opt/datadog -xzf ./datadog-dotnet-apm*-musl.tar.gz', "
          matrix="${matrix} 'dockerTag': '${name}', "
          matrix="${matrix} 'publishFramework': '${publishFramework}', "
          matrix="${matrix} 'linuxArtifacts': 'linux-packages-alpine', "
          matrix="${matrix} 'runtimeImage': 'mcr.microsoft.com/dotnet/aspnet:${runtimeImageTag}' },"
        done;
        matrix="${matrix::-1} }"
        echo "##vso[task.setVariable variable=values;isOutput=true]${matrix}"
      name: mtrx

  - job: linux
    dependsOn: [generator]
    strategy:
      matrix: $[ dependencies.generator.outputs['mtrx.values'] ]
    variables:
      smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
    pool:
      vmImage: ubuntu-18.04

    steps:
    - task: DownloadPipelineArtifact@2
      displayName: Download artifacts to smoke test directory
      inputs:
        artifact: $(linuxArtifacts)
        path: $(smokeTestAppDir)/artifacts

    - script: |
        docker build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersion) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg INSTALL_CMD="$(installCmd)" \
          --tag dd-trace-dotnet/$(dockerTag)-smoke-test \
          --file "$(System.DefaultWorkingDirectory)/tracer/build/_build/docker/smoke.dockerfile" \
          "$(smokeTestAppDir)"
      displayName: Build $(dockerTag) Docker image

    - script: docker run --rm dd-trace-dotnet/$(dockerTag)-smoke-test
      displayName: Test $(dockerTag) Docker image

- stage: installer_smoke_tests_arm64
  condition: and(succeeded(), eq(variables['isScheduledBuild'], 'False'))
  dependsOn: [build_arm64]
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [linux]

    - job: generator
      pool:
        vmImage: ubuntu-18.04
      steps:
        - checkout: none
        - bash: |
            matrix="{"
            for i in \
              "net6.0 6.0-bullseye-slim" \
              "net5.0 5.0-bullseye-slim" \
              "net5.0 5.0-buster-slim" \
              "net5.0 5.0-focal" \
            ; do fwAndImage=( $i )
              publishFramework="${fwAndImage[0]}";
              runtimeImageTag="${fwAndImage[1]}";
              name="${runtimeImageTag//./_}"

              matrix="${matrix} '${name}':"
              matrix="${matrix} { 'installCmd': 'dpkg -i ./datadog-dotnet-apm_*_arm64.deb', "
              matrix="${matrix} 'dockerTag': '${name}', "
              matrix="${matrix} 'publishFramework': '${publishFramework}', "
              matrix="${matrix} 'linuxArtifacts': 'linux-packages-arm64', "
              matrix="${matrix} 'runtimeImage': 'mcr.microsoft.com/dotnet/aspnet:${runtimeImageTag}' },"
            done;
            matrix="${matrix::-1} }"
            echo "##vso[task.setVariable variable=values;isOutput=true]${matrix}"
          name: mtrx

    - job: linux
      dependsOn: [generator]
      strategy:
        matrix: $[ dependencies.generator.outputs['mtrx.values'] ]
      variables:
        smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
      pool:
        name: Arm64

      steps:
        - task: DownloadPipelineArtifact@2
          displayName: Download artifacts to smoke test directory
          inputs:
            artifact: $(linuxArtifacts)
            path: $(smokeTestAppDir)/artifacts

        - script: |
            docker build \
              --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersion) \
              --build-arg RUNTIME_IMAGE=$(runtimeImage) \
              --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
              --build-arg INSTALL_CMD="$(installCmd)" \
              --tag dd-trace-dotnet/$(dockerTag)-smoke-test \
              --file "$(System.DefaultWorkingDirectory)/tracer/build/_build/docker/smoke.dockerfile" \
              "$(smokeTestAppDir)"
          displayName: Build $(dockerTag) Docker image

        - script: docker run --rm dd-trace-dotnet/$(dockerTag)-smoke-test
          displayName: Test $(dockerTag) Docker image
