# Change the default BuildId to not include a '.' in the name (use '_' instead)
name: $(Date:yyyyMMdd)-$(Rev:rr)

# master/hotfix branches should always run
trigger:
  branches:
    include:
      - master
      - release/*
      - hotfix/*
    exclude:
      - refs/pull/*/head

# Changes in PRs and other branches need to run, if
# - There were any code changes
# - There were any changes to the AzDo or GitLab builds
# They don't need to run if there are changes to
# - Standalone samples
# - Docs
# - Any other non-build related files (but these rarely change, so just suck it up)
pr:
  branches:
    include:
      - '*' # default
  paths:
    exclude:
      - .azure-pipelines/noop-pipeline.yml
      - .github/
      - docs/
      - tracer/README.MD
      - tracer/samples/

schedules:
  - cron: "0 3 * * *"
    displayName: Daily 3am (UTC) build
    branches:
      include:
        - master
        - release/*
        - hotfix/*
      exclude:
        - release/2.x
        - release/1.x
    always: true

  # The name of this schedule is checked from within Nuke, and is used
  # to ensure we do a run in which we set DD_TRACE_DEBUG=1 in integration tests
  # to catch any debug-specific issues
  - cron: "0 4 * * *"
    displayName: Daily Debug Run
    branches:
      include:
        - master
    always: true

# Global variables
variables:
  buildConfiguration: Release
  dotnetCoreSdkLatestVersion: 10.0.100-preview.7.25380.108
  # This is required until we're out of rc.
  # After GA we can do a find and replace and get rid of this
  dotnetCoreSdkLatestVersionShort: 10.0.100-preview.7
  nativeBuildDotnetSdkVersion: 7.0.306
  # These are the Managed DevOps pool names we use
  linuxTasksPool: azure-managed-linux-tasks
  linuxX64SmokePool: azure-managed-linux-smoke
  linuxX64Pool: azure-managed-linux-x64-1
  linuxArm64Pool: azure-managed-linux-arm64-2
  windowsX64Pool: azure-managed-windows-x64-1

  relativeArtifacts: /tracer/src/bin/artifacts
  monitoringHome: $(System.DefaultWorkingDirectory)/shared/bin/monitoring-home
  artifacts: $(System.DefaultWorkingDirectory)/tracer/src/bin/artifacts
  outputDir: $(System.DefaultWorkingDirectory)/artifacts
  symbols: $(System.DefaultWorkingDirectory)/tracer/bin/symbols
  relativeRunnerTool: tracer/src/bin/runnerTool
  relativeRunnerStandalone: tracer/src/bin/runnerStandalone
  ddApiKey: $(DD_API_KEY_PROD)
  isMainBranch: $[in(variables['Build.SourceBranch'], 'refs/heads/master', 'refs/heads/main')]
  isMainOrReleaseBranch: $[or(in(variables['Build.SourceBranch'], 'refs/heads/master', 'refs/heads/main'), startsWith(variables['Build.SourceBranch'], 'refs/heads/release/'), startsWith(variables['Build.SourceBranch'], 'refs/heads/hotfix/'))]
  isPullRequest: $[eq(variables['Build.Reason'], 'PullRequest')]
  # Only run code coverage when requested
  # Coverlet relies on IL rewriting, which currently breaks tests which explictly check the IL
  CodeCoverageEnabled: $[eq(variables['run_code_coverage'], 'true')]
  DD_DOTNET_TRACER_MSBUILD:
  NugetPackageDirectory: $(System.DefaultWorkingDirectory)/packages
  relativeNugetPackageDirectory: packages
  dotnetToolTag: build-dotnet-tool
  Verify_DisableClipboard: true
  DiffEngine_Disabled: true
  OriginalCommitId: $[coalesce(variables['System.PullRequest.SourceCommitId'], variables['Build.SourceVersion'])]
  NUGET_ENABLE_EXPERIMENTAL_HTTP_RETRY: true
  NUGET_EXPERIMENTAL_CHAIN_BUILD_RETRY_POLICY: 3,1000
  DefaultTimeout: 60
  DD_INSTRUMENTATION_TELEMETRY_ENABLED: 0
  NUKE_TELEMETRY_OPTOUT: 1
  # Include all test frameworks when (variable is set) OR ((running on master/release/hotfix) and (NOT scheduled build)),
  IncludeAllTestFrameworks: $[or(eq(variables['run_all_test_frameworks'], 'true'), and(or(in(variables['Build.SourceBranch'], 'refs/heads/master', 'refs/heads/main'), startsWith(variables['Build.SourceBranch'], 'refs/heads/release/'), startsWith(variables['Build.SourceBranch'], 'refs/heads/hostfix/')), not(eq(variables['Build.Reason'], 'Schedule'))))]
  IntegrationTestSampleName:  $(TEST_SAMPLE_NAME)
  IntegrationTestFilter:  $(TEST_FILTER)
  DockerComposeProjectName: ddtrace-$(Build.BuildNumber)
  # Logger variables
  DD_LOGGER_DD_API_KEY: $(DD_API_KEY_PROD)
  DD_LOGGER_DD_SERVICE: dd-trace-dotnet
  DD_LOGGER_DD_ENV: CI
  DD_LOGGER_DD_TRACE_LOG_DIRECTORY: $(System.DefaultWorkingDirectory)/artifacts/build_data/infra_logs
  DD_LOGGER_TF_BUILD: True
  DD_LOGGER_BUILD_BUILDID: $(Build.BuildId)
  DD_LOGGER_BUILD_DEFINITIONNAME: $(Build.DefinitionName)
  DD_LOGGER_BUILD_SOURCESDIRECTORY: $(Build.SourcesDirectory)
  DD_LOGGER_BUILD_REPOSITORY_URI: $(Build.Repository.Uri)
  DD_LOGGER_BUILD_SOURCEVERSION: $(Build.SourceVersion)
  DD_LOGGER_BUILD_SOURCEBRANCH: $(Build.SourceBranch)
  DD_LOGGER_BUILD_SOURCEBRANCHNAME: $(Build.SourceBranchName)
  DD_LOGGER_BUILD_SOURCEVERSIONMESSAGE: $(Build.SourceVersionMessage)
  DD_LOGGER_BUILD_REQUESTEDFORID: $(Build.RequestedForId)
  DD_LOGGER_BUILD_REQUESTEDFOREMAIL: $(Build.RequestedForEmail)
  DD_LOGGER_SYSTEM_TEAMFOUNDATIONSERVERURI: $(System.TeamFoundationServerUri)
  DD_LOGGER_SYSTEM_TEAMPROJECTID: $(System.TeamProjectId)
  DD_LOGGER_SYSTEM_STAGEDISPLAYNAME: $(System.StageDisplayName)
  DD_LOGGER_SYSTEM_JOBDISPLAYNAME: $(System.JobDisplayName)
  DD_LOGGER_SYSTEM_JOBID: $(System.JobId)
  DD_LOGGER_SYSTEM_PULLREQUEST_SOURCEREPOSITORYURI: $[variables['System.PullRequest.SourceRepositoryURI']]
  DD_LOGGER_SYSTEM_PULLREQUEST_SOURCECOMMITID: $[variables['System.PullRequest.SourceCommitId']]
  DD_LOGGER_SYSTEM_PULLREQUEST_SOURCEBRANCH: $[variables['System.PullRequest.SourceBranch']]
  DD_LOGGER_API_KEY_CHECKER_ENABLED: false
  DD_LOGGER_DD_TAGS: test.configuration.job:$(System.JobDisplayName)
  DD_LOGGER_ENABLED: true
  DD_COLLECTOR_CPU_USAGE: true
  ToolVersion: 3.27.0
  # .NET SDK performance optimization variables
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: 1
  DOTNET_CLI_TELEMETRY_OPTOUT: 1
  DOTNET_NOLOGO: 1
  DOTNET_CLI_UI_LANGUAGE: 'en'
  DOTNET_MULTILEVEL_LOOKUP: 0
  NUGET_XMLDOC_MODE: 'skip'

# Declare the datadog agent as a resource to be used as a pipeline service
resources:
  containers:
  # This always does a docker pull to pull the latest agent
  - container: dd_agent
    image: public.ecr.aws/datadog/agent
    ports:
    - 8126:8126
    env:
      DD_API_KEY: $(ddApiKey)
      DD_INSIDE_CI: true
  # This always uses the local pulled version of the agent
  # This avoids hitting docker pull resource limits, but means we periodically need
  # to run a docker pull ourselves (which typically happens as part of VMSS updates)
  - container: dd_agent_no_pull
    image: public.ecr.aws/datadog/agent
    localImage: true
    ports:
    - 8126:8126
    env:
      DD_API_KEY: $(ddApiKey)
      DD_INSIDE_CI: true

# Stages
stages:
# This step grabs the current commit of master, and records it for subsequent stages
# We use it to ensure that we are always running PRs against the same commit, even
# if master is updated while the build is in progress. This guards against CI flakiness
# where the first stages of the build execute against one merge commit, and later stages
# run against another

- stage: merge_commit_id
  dependsOn: []
  jobs:
  - job: fetch
    timeoutInMinutes: 60 #default value
    pool:
      name: $(linuxTasksPool)

    steps:
    - checkout: none
    - bash: |
        TARGET_BRANCH=$SYSTEM_PULLREQUEST_TARGETBRANCH
        echo "SYSTEM_PULLREQUEST_TARGETBRANCH=$TARGET_BRANCH"
        if [[ "$TARGET_BRANCH" == refs/heads/hotfix/* ]] || [[ "$TARGET_BRANCH" == refs/heads/release/* ]]; then
          TARGET_BRANCH=$(echo $TARGET_BRANCH| cut -c 11-)
        elif [[ "$TARGET_BRANCH" == hotfix/* ]] || [[ "$TARGET_BRANCH" == release/* ]]; then
          echo "No need to change the branch name"
        else
          TARGET_BRANCH=master
        fi
        echo "Using target branch $TARGET_BRANCH"

        rm -rf ./s
        git clone --quiet --no-checkout --depth 1 --branch $TARGET_BRANCH $BUILD_REPOSITORY_URI ./s
        cd s
        TARGET_SHA=$(git rev-parse origin/$TARGET_BRANCH)
        rm -rf ./s
        echo "Using master commit ID $TARGET_SHA"
        echo "##vso[task.setvariable variable=sha;isOutput=true]$TARGET_SHA"
        echo "##vso[task.setvariable variable=branch;isOutput=true]$TARGET_BRANCH"
      failOnStderr: true
      displayName: Fetch master id
      name: set_sha

- stage: generate_variables
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [generate_variables_job]

  - job: generate_variables_job
    timeoutInMinutes: 60 #default value
    dependsOn: []
    pool:
      name: $(windowsX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - powershell: |
        tracer/build.ps1 GenerateVariables
      displayName: Generate Matrices
      name: generate_variables_step

- stage: build_windows_tracer
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build]

  - job: build
    timeoutInMinutes: 60 #default value
    pool:
      name: $(windowsX64Pool)
    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - script: tracer\build.cmd BuildTracerHome BuildNativeLoader
      displayName: Build tracer home
      retryCountOnTaskFailure: 1

    - script: tracer\build.cmd CompileTracerNativeTests RunTracerNativeTests CompileNativeLoaderNativeTests RunNativeLoaderNativeTests
      displayName: Build and run tracer and native loader native tests
      retryCountOnTaskFailure: 1
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)

    - publish: $(monitoringHome)
      displayName: Upload Windows tracer home directory
      artifact: windows-tracer-home

    - publish: $(System.DefaultWorkingDirectory)
      displayName: Upload working directory after the managed build
      artifact: build-windows-working-directory

    - publish: $(System.DefaultWorkingDirectory)/tracer/src/Datadog.Trace.Manual/bin/Release/netcoreapp3.1/Datadog.Trace.Manual.dll
      displayName: Upload Datadog.Trace.Manual.dll for external CI
      artifact: Datadog.Trace.Manual.dll

    - publish: artifacts/build_data/tests
      displayName: publish tracer and native loader test results
      artifact: build_windows_tracer_unit_tests_results_$(System.JobAttempt)

- stage: build_windows_profiler
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build]

  - job: build
    pool:
      name: $(windowsX64Pool)
    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - script: tracer\build.cmd BuildProfilerHome
      displayName: Build profiler home
      retryCountOnTaskFailure: 1

    - script: tracer\build.cmd CompileProfilerNativeTests RunProfilerNativeTests
      displayName: Build and run profiler native tests
      retryCountOnTaskFailure: 1
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)

    - publish: $(monitoringHome)
      displayName: Upload Windows profiler home directory
      artifact: windows-profiler-home

    - publish: $(symbols)
      displayName: Upload Windows profiler symbols
      artifact: windows-profiler-symbols

    - publish: profiler/build_data/tests
      displayName: publish profiler test results
      artifact: build_windows_profiler_unit_tests_results_$(System.JobAttempt)

- stage: build_linux_tracer
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build]

  - job: build
    timeoutInMinutes: 60 #default value
    dependsOn: []
    strategy:
      matrix:
        x64:
          nativeBaseImage: centos7
          managedBaseImage: debian
          useNativeSdkVersion: true
          artifactSuffix: linux-x64
        alpine:
          nativeBaseImage: alpine
          managedBaseImage: alpine
          useNativeSdkVersion: ""
          artifactSuffix: linux-musl-x64
    pool:
      name: $(linuxX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: $(managedBaseImage)
        command: "Clean CompileManagedLoader"
        retryCountForRunCommand: 1

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: $(nativeBaseImage)
        useNativeSdkVersion: $(useNativeSdkVersion)
        command: "BuildNativeTracerHome CompileTracerNativeTests RunTracerNativeTests"
        retryCountForRunCommand: 1
        apiKey: $(DD_LOGGER_DD_API_KEY)

    - template: steps/run-in-docker.yml
      parameters:
        target: builder
        baseImage: $(managedBaseImage)
        command: "BuildManagedTracerHome ExtractDebugInfoLinux ValidateNativeTracerGlibcCompatibility"
        retryCountForRunCommand: 1

    - publish: $(monitoringHome)
      displayName: Uploading linux tracer home artifact
      artifact: linux-tracer-home-$(artifactSuffix)

    - publish: $(System.DefaultWorkingDirectory)
      displayName: Upload working directory after the build
      artifact: build-$(artifactSuffix)-working-directory

    - publish: $(symbols)
      displayName: Upload linux tracer symbols
      artifact: linux-tracer-symbols-$(artifactSuffix)

    - publish: artifacts/build_data/tests
      displayName: publish tracer and native loader test results
      artifact: build_linux_tracer_unit_tests_results_$(artifactSuffix)_$(System.JobAttempt)

- stage: build_linux_tracer_r2r
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [build]

    - job: build
      timeoutInMinutes: 60 #default value
      dependsOn: []
      pool:
        name: $(linuxX64Pool)
      
      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - template: steps/run-in-docker.yml
          parameters:
            build: true
            target: builder
            baseImage: debian
            command: "Clean CompileManagedLoader"
            retryCountForRunCommand: 1

        - template: steps/run-in-docker.yml
          parameters:
            build: true
            target: builder
            baseImage: centos7
            useNativeSdkVersion: true
            command: "BuildNativeTracerHome CompileTracerNativeTests RunTracerNativeTests"
            retryCountForRunCommand: 1
            apiKey: $(DD_LOGGER_DD_API_KEY)

        - template: steps/run-in-docker.yml
          parameters:
            target: builder
            baseImage: debian
            command: "BuildManagedTracerHomeR2R ExtractDebugInfoLinux"
            retryCountForRunCommand: 1

        - publish: $(monitoringHome)
          displayName: Uploading linux tracer home artifact
          artifact: linux-tracer-home-linux-x64-r2r

        - publish: $(System.DefaultWorkingDirectory)
          displayName: Upload working directory after the build
          artifact: build-linux-x64-r2r-working-directory

        - publish: $(symbols)
          displayName: Upload linux tracer symbols
          artifact: linux-tracer-symbols-linux-x64-r2r

        - publish: artifacts/build_data/tests
          displayName: publish tracer and native loader test results
          artifact: build_linux_tracer_unit_tests_results_linux-x64-r2r_$(System.JobAttempt)

- stage: build_linux_universal
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build]

  - job: build
    timeoutInMinutes: 60 #default value
    dependsOn: []
    pool:
      name: $(linuxX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: "universal"
        useNativeSdkVersion: true
        command: "Clean BuildNativeLoader BuildNativeWrapper ExtractDebugInfoLinux ValidateNativeLoaderSnapshotTestsLinux"
        retryCountForRunCommand: 1

    - publish: $(monitoringHome)/linux-musl-x64
      displayName: Uploading linux universal artifacts
      artifact: linux-universal-home-linux-x64

    - publish: $(symbols)/linux-musl-x64
      displayName: Upload linux universal symbols
      artifact: linux-universal-symbols-linux-x64

- stage: build_linux_profiler
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build]

  - job: build
    timeoutInMinutes: 60 #default value
    dependsOn: []
    strategy:
      matrix:
        x64:
          baseImage: centos7
          managedBaseImage: debian
          artifactSuffix: linux-x64
          useNativeSdkVersion: true
        alpine:
          baseImage: alpine
          managedBaseImage: alpine
          artifactSuffix: linux-musl-x64
          useNativeSdkVersion: ""
    pool:
      name: $(linuxX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: $(baseImage)
        useNativeSdkVersion: $(useNativeSdkVersion)
        # We only need the native wrapper for the unit tests but we do not want to publish it (universal binary)
        command: "Clean BuildProfilerHome CompileNativeWrapper CompileProfilerNativeTests RunProfilerNativeTests CompileNativeWrapperNativeTests RunNativeWrapperNativeTests CompileNativeLoaderNativeTests RunNativeLoaderNativeTests"
        retryCountForRunCommand: 1
        apiKey: $(DD_LOGGER_DD_API_KEY)

    # We have to run these in a separate stage because the version of nm included with centos7 is insufficient to validate the glibc version
    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: $(managedBaseImage)
        command: "ExtractDebugInfoLinux ValidateNativeProfilerGlibcCompatibility"
        retryCountForRunCommand: 1

    - publish: $(monitoringHome)
      displayName: Uploading linux profiler home artifact
      artifact: linux-profiler-home-$(artifactSuffix)

    - publish: $(symbols)
      displayName: Upload linux profiler symbols
      artifact: linux-profiler-symbols-$(artifactSuffix)

    - publish: profiler/build_data/tests
      displayName: publish profiler test results
      artifact: build_linux_profiler_unit_tests_results_$(artifactSuffix)_$(System.JobAttempt)

- stage: package_linux
  dependsOn: [merge_commit_id, build_linux_tracer, build_linux_profiler, build_dd_dotnet_linux, build_linux_universal]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [package]

  - job: package
    dependsOn: []
    timeoutInMinutes: 60 #default value
    strategy:
      matrix:
        x64:
          baseImage: debian
          artifactSuffix: linux-x64
        alpine:
          baseImage: alpine
          artifactSuffix: linux-musl-x64
    pool:
      name: $(linuxX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    # Download _both_ musl and glibc if we're building the universal package
    # but only the musl package if we're building alpine package
    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-tracer-home-linux-x64
        path: $(monitoringHome)
        condition: eq(variables['artifactSuffix'], 'linux-x64')

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-profiler-home-linux-x64
        path: $(monitoringHome)
        condition: eq(variables['artifactSuffix'], 'linux-x64')

    - template: steps/download-artifact.yml
      parameters:
        artifact: dd-dotnet-linux-x64
        path: $(monitoringHome)/linux-x64
        condition: eq(variables['artifactSuffix'], 'linux-x64')

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-tracer-home-linux-musl-x64
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-profiler-home-linux-musl-x64
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: dd-dotnet-linux-musl-x64
        path: $(monitoringHome)/linux-musl-x64

    - script: |
        chmod +x $(monitoringHome)/linux-musl-x64/dd-dotnet
        # don't panic if the file doesn't exist
        chmod +x $(monitoringHome)/linux-x64/dd-dotnet | :
      displayName: chmod dd-dotnet

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-universal-home-linux-x64
        path: $(monitoringHome)/$(artifactSuffix)

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: $(baseImage)
        command: "ZipMonitoringHome"
        retryCountForRunCommand: 1

    - publish: $(artifacts)/linux-x64
      displayName: Upload linux-x64 packages
      artifact: linux-packages-$(artifactSuffix)

    - publish: $(monitoringHome)
      displayName: Upload linux-x64 monitoring home
      artifact: linux-monitoring-home-$(artifactSuffix)

- stage: build_arm64_tracer
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build]

  - job: build
    timeoutInMinutes: 60 #default value
    dependsOn: []
    strategy:
      matrix:
        arm64:
          baseImage: debian
          artifactSuffix: linux-arm64
        alpine:
          baseImage: alpine
          artifactSuffix: linux-musl-arm64
    pool:
      name: $(linuxArm64Pool)
    workspace:
      clean: all
    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: $(baseImage)
        command: "Clean CompileManagedLoader BuildNativeTracerHome BuildManagedTracerHome ExtractDebugInfoLinux ValidateNativeTracerGlibcCompatibility"
        retryCountForRunCommand: 1

    - publish: $(monitoringHome)
      displayName: Uploading linux tracer home artifact
      artifact: linux-tracer-home-$(artifactSuffix)

    - publish: $(System.DefaultWorkingDirectory)
      displayName: Upload working directory after the build
      artifact: build-$(artifactSuffix)-working-directory

    - publish: $(symbols)
      displayName: Upload linux tracer symbols
      artifact: linux-tracer-symbols-$(artifactSuffix)

- stage: build_arm64_tracer_r2r
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build]

  - job: build
    timeoutInMinutes: 60 #default value
    dependsOn: []

    pool:
      name: $(linuxArm64Pool)
    workspace:
      clean: all
    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: debian
        command: "Clean CompileManagedLoader BuildNativeTracerHome BuildManagedTracerHomeR2R ExtractDebugInfoLinux"
        retryCountForRunCommand: 1

    - publish: $(monitoringHome)
      displayName: Uploading linux tracer home artifact
      artifact: linux-tracer-home-linux-arm64-r2r

    - publish: $(System.DefaultWorkingDirectory)
      displayName: Upload working directory after the build
      artifact: build-linux-arm64-r2r-working-directory

    - publish: $(symbols)
      displayName: Upload linux tracer symbols
      artifact: linux-tracer-symbols-linux-arm64-r2r

- stage: build_arm64_profiler
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build]

  - job: build
    timeoutInMinutes: 60 #default value
    dependsOn: []
    strategy:
      matrix:
        arm64:
          baseImage: debian
          artifactSuffix: linux-arm64
        alpine:
          baseImage: alpine
          artifactSuffix: linux-musl-arm64
    pool:
      name: $(linuxArm64Pool)
    workspace:
      clean: all
    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: $(baseImage)
        command: "Clean BuildProfilerHome ExtractDebugInfoLinux ValidateNativeProfilerGlibcCompatibility"
        retryCountForRunCommand: 1

    - publish: $(System.DefaultWorkingDirectory)/profiler/_build
      displayName: Uploading linux profiler output build folder
      artifact: linux-profiler-binaries-$(artifactSuffix)

    - publish: $(monitoringHome)
      displayName: Uploading linux profiler home artifact
      artifact: linux-profiler-home-$(artifactSuffix)

    - publish: $(symbols)
      displayName: Upload linux profiler symbols
      artifact: linux-profiler-symbols-$(artifactSuffix)

- stage: build_arm64_universal
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build]

  - job: build
    timeoutInMinutes: 60 #default value
    dependsOn: []
    pool:
      name: $(linuxArm64Pool)
    workspace:
      clean: all
    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: "universal"
        useNativeSdkVersion: true
        command: "Clean BuildNativeLoader BuildNativeWrapper ExtractDebugInfoLinux ValidateNativeLoaderSnapshotTestsLinux"
        retryCountForRunCommand: 1

    - publish: $(monitoringHome)/linux-musl-arm64
      displayName: Uploading linux universal arm64 artifacts
      artifact: linux-universal-home-linux-arm64

    - publish: $(symbols)/linux-musl-arm64
      displayName: Upload linux universal arm64 symbols
      artifact: linux-universal-symbols-linux-arm64

- stage: package_arm64
  dependsOn: [merge_commit_id, build_arm64_tracer, build_arm64_profiler, build_dd_dotnet_linux_arm64, build_arm64_universal]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [package]

  - job: package
    dependsOn: []
    timeoutInMinutes: 60 #default value
    strategy:
      matrix:
        arm64:
          baseImage: debian
          artifactSuffix: linux-arm64
        alpine:
          baseImage: alpine
          artifactSuffix: linux-musl-arm64
    pool:
      name: $(linuxArm64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
      
      # Download _both_ musl and glibc if we're building the universal package
      # but only the musl package if we're building alpine package
    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-tracer-home-linux-arm64
        path: $(monitoringHome)
        condition: eq(variables['artifactSuffix'], 'linux-arm64')

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-profiler-home-linux-arm64
        path: $(monitoringHome)
        condition: eq(variables['artifactSuffix'], 'linux-arm64')

    - template: steps/download-artifact.yml
      parameters:
        artifact: dd-dotnet-linux-arm64
        path: $(monitoringHome)/linux-arm64
        condition: eq(variables['artifactSuffix'], 'linux-arm64')

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-tracer-home-linux-musl-arm64
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-profiler-home-linux-musl-arm64
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: dd-dotnet-linux-musl-arm64
        path: $(monitoringHome)/linux-musl-arm64

    - script: |
        chmod +x $(monitoringHome)/linux-musl-arm64/dd-dotnet
        # don't panic if the file doesn't exist
        chmod +x $(monitoringHome)/linux-arm64/dd-dotnet | :
      displayName: chmod dd-dotnet

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-universal-home-linux-arm64
        path: $(monitoringHome)/$(artifactSuffix)

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: $(baseImage)
        command: "ZipMonitoringHome"
        retryCountForRunCommand: 1

    - publish: $(artifacts)/linux-arm64
      displayName: Upload arm64 packages
      artifact: linux-packages-$(artifactSuffix)

    - publish: $(monitoringHome)
      displayName: Upload arm64 monitoring home
      artifact: linux-monitoring-home-$(artifactSuffix)

- stage: build_macos
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [native_tracer, native_loader_and_managed, upload_artifacts]

  - job: native_tracer
    timeoutInMinutes: 60 #default value
    dependsOn: [ ]
    pool:
      vmImage: macos-13
    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/install-latest-dotnet-sdk.yml

    - script: ./tracer/build.sh CreateRequiredDirectories CompileManagedLoader BuildNativeTracerHome
      displayName: Build native-tracer
      retryCountOnTaskFailure: 1

    - publish: $(monitoringHome)
      displayName: Uploading macos native tracer artifact
      artifact: build-macos-native_tracer

  - job: native_loader_and_managed
    timeoutInMinutes: 60 #default value
    dependsOn: [ ]
    pool:
      vmImage: macos-13
    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/install-latest-dotnet-sdk.yml

    # The CreateTrimmingFile tasks expects the managed loader but we build that in the other stage
    - script: ./tracer/build.sh BuildManagedTracerHome BuildNativeLoader --skip CreateTrimmingFile
      displayName: Build managed tracer + native loader
      retryCountOnTaskFailure: 1

    - publish: $(monitoringHome)
      displayName: Uploading macos native tracer artifact
      artifact: build-macos-native_loader

    - publish: $(System.DefaultWorkingDirectory)
      displayName: Upload working directory after the build
      artifact: build-macos-working-directory

  - job: upload_artifacts
    timeoutInMinutes: 60 #default value
    dependsOn: [native_tracer, native_loader_and_managed ]
    pool:
      vmImage: macos-13
    steps:
    - checkout: none

    - template: steps/download-artifact.yml
      parameters:
        artifact: build-macos-native_tracer
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: build-macos-native_loader
        path: $(monitoringHome)

    - publish: $(monitoringHome)
      displayName: Uploading combined macos profiler artifact
      artifact: macos-tracer-home

- stage: package_windows
  dependsOn: [ build_windows_tracer, build_windows_profiler, build_dd_dotnet_windows, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  pool:
    name: $(windowsX64Pool)
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [msi_and_pack]

  - job: msi_and_pack
    steps:
      - template: steps/clone-repo.yml
        parameters:
          targetShaId: $(targetShaId)
          targetBranch: $(targetBranch)
      - template: steps/restore-working-directory.yml

      - template: steps/download-artifact.yml
        parameters:
          artifact: windows-profiler-home
          path: $(monitoringHome)

      - template: steps/download-artifact.yml
        parameters:
          artifact: dd-dotnet-win-x64
          path: $(monitoringHome)/win-x64

      - script: tracer\build.cmd PackageTracerHome PublishFleetInstaller DownloadWinSsiTelemetryForwarder
        displayName: Build MSI, Tracer home, FleetInstaller, and TelemetryForwarder
        retryCountOnTaskFailure: 1

      - publish: $(artifacts)/windows-tracer-home.zip
        displayName: Publish tracer-home.zip
        artifact: windows-tracer-home.zip

      - publish: $(artifacts)/x64/en-us
        displayName: Publish Windows x64 MSI
        artifact: windows-msi-x64

      - publish: $(artifacts)/nuget
        displayName: Publish NuGet packages
        artifact: nuget-packages

      - publish: $(artifacts)/Datadog.FleetInstaller
        displayName: Publish fleet installer
        artifact: fleet-installer

      - publish: $(artifacts)/telemetry_forwarder.exe
        displayName: Publish telemetry-forwarder
        artifact: fleet-installer-telemetry-forwarder

- stage: build_dd_dotnet_windows
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
    targetFramework: net8.0
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build_dd_dotnet]

  - job: build_dd_dotnet
    timeoutInMinutes: 60 #default value

    pool:
      name: $(windowsX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - script: tracer\build.cmd BuildDdDotnet -framework=$(targetFramework)
      displayName: Build dd-dotnet

    - publish: $(artifacts)/dd-dotnet/win-x64/dd-dotnet.exe
      displayName: Uploading dd-dotnet win-x64
      artifact: dd-dotnet-win-x64

    - publish: $(artifacts)/dd-dotnet/win-x64/dd-dotnet.pdb
      displayName: Uploading dd-dotnet win-x64 symbols
      artifact: dd-dotnet-symbols-win-x64

- stage: build_dd_dotnet_linux
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [linux]

  - job: linux
    timeoutInMinutes: 60 #default value
    strategy:
      matrix:
        x64:
          baseImage: debian
          artifactSuffix: linux-x64
        alpine:
          baseImage: alpine
          artifactSuffix: linux-musl-x64

    pool:
      name: $(linuxX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: $(baseImage)
        command: "Clean BuildDdDotnet --framework net8.0"
        retryCountForRunCommand: 1

    - publish: $(artifacts)/dd-dotnet/$(artifactSuffix)/dd-dotnet
      displayName: Uploading dd-dotnet $(artifactSuffix)
      artifact: dd-dotnet-$(artifactSuffix)

    - publish: $(artifacts)/dd-dotnet/$(artifactSuffix)/dd-dotnet.dbg
      displayName: Uploading dd-dotnet $(artifactSuffix) symbols
      artifact: dd-dotnet-symbols-$(artifactSuffix)

- stage: build_dd_dotnet_linux_arm64
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
    targetFramework: net8.0
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [linux]

  - job: linux
    timeoutInMinutes: 60 #default value
    strategy:
      matrix:
        x64:
          baseImage: debian
          artifactSuffix: linux-arm64
        alpine:
          baseImage: alpine
          artifactSuffix: linux-musl-arm64

    pool:
      name: $(linuxArm64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: $(baseImage)
        command: "Clean BuildDdDotnet --framework $(targetFramework)"
        retryCountForRunCommand: 1

    - publish: $(artifacts)/dd-dotnet/$(artifactSuffix)/dd-dotnet
      displayName: Uploading dd-dotnet $(artifactSuffix)
      artifact: dd-dotnet-$(artifactSuffix)

    - publish: $(artifacts)/dd-dotnet/$(artifactSuffix)/dd-dotnet.dbg
      displayName: Uploading dd-dotnet $(artifactSuffix) symbols
      artifact: dd-dotnet-symbols-$(artifactSuffix)

- stage: debug_builds
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [linux, macos, windows, linux_arm64]

  - job: linux
    timeoutInMinutes: 60 #default value
    dependsOn: []
    strategy:
      matrix:
        x64:
          nativeBaseImage: centos7
          managedBaseImage: debian
          useNativeSdkVersion: true
          artifactSuffix: linux-x64
        alpine:
          nativeBaseImage: alpine
          managedBaseImage: alpine
          useNativeSdkVersion: ""
          artifactSuffix: linux-musl-x64
    pool:
      name: $(linuxX64Pool)

    steps:
      - template: steps/clone-repo.yml
        parameters:
          targetShaId: $(targetShaId)
          targetBranch: $(targetBranch)

      - template: steps/run-in-docker.yml
        parameters:
          build: true
          target: builder
          baseImage: $(managedBaseImage)
          command: "Clean CompileManagedLoader -buildConfiguration Debug"
          retryCountForRunCommand: 1

      - template: steps/run-in-docker.yml
        parameters:
          build: true
          target: builder
          baseImage: $(nativeBaseImage)
          useNativeSdkVersion: $(useNativeSdkVersion)
          command: "BuildNativeTracerHome -buildConfiguration Debug"
          retryCountForRunCommand: 1

      - template: steps/run-in-docker.yml
        parameters:
          target: builder
          baseImage: $(managedBaseImage)
          command: "BuildManagedTracerHome ExtractDebugInfoLinux -buildConfiguration Debug"
          retryCountForRunCommand: 1

  - job: windows
    timeoutInMinutes: 60 #default value
    dependsOn: []
    pool:
      name: $(windowsX64Pool)
    steps:
      - template: steps/clone-repo.yml
        parameters:
          targetShaId: $(targetShaId)
          targetBranch: $(targetBranch)

      - script: tracer\build.cmd Clean Restore CreateRequiredDirectories CompileManagedSrc BuildRunnerTool -buildConfiguration Debug
        displayName: Build tracer home in debug
        retryCountOnTaskFailure: 1

  - job: linux_arm64
    timeoutInMinutes: 60 #default value
    dependsOn: []
    pool:
      name: $(linuxArm64Pool)
    workspace:
      clean: all
    steps:
      - template: steps/clone-repo.yml
        parameters:
          targetShaId: $(targetShaId)
          targetBranch: $(targetBranch)
      - template: steps/run-in-docker.yml
        parameters:
          build: true
          target: builder
          baseImage: debian
          command: "Clean Restore CreateRequiredDirectories CompileManagedSrc BuildRunnerTool -buildConfiguration Debug"
          retryCountForRunCommand: 1

  - job: macos
    timeoutInMinutes: 60 #default value
    dependsOn: [ ]
    pool:
      vmImage: macos-13
    steps:
      - template: steps/clone-repo.yml
        parameters:
          targetShaId: $(targetShaId)
          targetBranch: $(targetBranch)
      - template: steps/install-latest-dotnet-sdk.yml

      - script: ./tracer/build.sh Clean Restore CreateRequiredDirectories CompileManagedSrc BuildRunnerTool -buildConfiguration Debug
        displayName: Build tracer home
        retryCountOnTaskFailure: 1

- stage: unit_tests_windows
  dependsOn: [build_windows_tracer, merge_commit_id, generate_variables]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  pool:
    name: $(windowsX64Pool)

  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [managed]

    - job: managed
      timeoutInMinutes: 60 #default value
      strategy:
        matrix: $[stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.unit_tests_windows_matrix'] ]
      steps:
      - template: steps/clone-repo.yml
        parameters:
          targetShaId: $(targetShaId)
          targetBranch: $(targetBranch)
      - template: steps/restore-working-directory.yml

      - script: tracer\build.cmd BuildManagedUnitTests --framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)
        displayName: Build unit tests
        retryCountOnTaskFailure: 3
        env:
          DD_LOGGER_DD_API_KEY: $(ddApiKey)

      - script: tracer\build.cmd RunManagedUnitTests --framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)
        displayName: Test
        env:
          DD_LOGGER_DD_API_KEY: $(ddApiKey)

      - publish: artifacts/build_data
        artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
        condition: always()
        continueOnError: true

      - task: PublishTestResults@2
        displayName: publish test results
        inputs:
          testResultsFormat: VSTest
          testResultsFiles: artifacts/build_data/results/**/*.trx
        condition: succeededOrFailed()

- stage: unit_tests_macos
  dependsOn: [build_macos, merge_commit_id, generate_variables]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [managed]

  - job: managed
    strategy:
      matrix:
        $[stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.unit_tests_macos_matrix'] ]
    timeoutInMinutes: 90
    pool:
      vmImage: macos-13
    steps:
      - template: steps/clone-repo.yml
        parameters:
          targetShaId: $(targetShaId)
          targetBranch: $(targetBranch)
      - template: steps/install-dotnet.yml
      - template: steps/restore-working-directory.yml
        parameters:
          artifact: build-macos-working-directory

      # The native tracer is built and uploaded separately for perf reasons, so needs to be explicitly downloaded here
      - template: steps/download-artifact.yml
        parameters:
          artifact: build-macos-native_tracer
          path: $(monitoringHome)

      - script: ./tracer/build.sh BuildManagedUnitTests --framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)
        displayName: Build unit tests
        retryCountOnTaskFailure: 3
        env:
          DD_LOGGER_DD_API_KEY: $(ddApiKey)

      - script: ./tracer/build.sh RunManagedUnitTests --framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)
        displayName: Run unit tests
        retryCountOnTaskFailure: 1
        env:
          DD_LOGGER_DD_API_KEY: $(ddApiKey)

      - publish: artifacts/build_data
        artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
        condition: always()
        continueOnError: true

      - task: PublishTestResults@2
        displayName: publish test results
        inputs:
          testResultsFormat: VSTest
          testResultsFiles: artifacts/build_data/results/**/*.trx
        condition: succeededOrFailed()

- stage: unit_tests_linux
  dependsOn: [build_linux_tracer, build_linux_profiler, merge_commit_id, generate_variables]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [managed]

  - job: managed
    timeoutInMinutes: 60 #default value
    strategy:
      matrix:
        $[stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.unit_tests_linux_x64_matrix'] ]
    pool:
      name: $(linuxX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/restore-working-directory.yml
      parameters:
        artifact: build-$(artifactSuffix)-working-directory

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: $(baseImage)
        command: "BuildManagedUnitTests --framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)"
        apiKey: $(DD_LOGGER_DD_API_KEY)
        retryCountForRunCommand: 3

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: $(baseImage)
        command: "RunManagedUnitTests --framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)"
        apiKey: $(DD_LOGGER_DD_API_KEY)

    - template: steps/make-artifacts-uploadable.yml
    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: artifacts/build_data/results/**/*.trx
      condition: succeededOrFailed()

- stage: unit_tests_arm64
  dependsOn: [build_arm64_tracer, merge_commit_id, generate_variables]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [test]

    - job: test
      timeoutInMinutes: 60 #default value

      strategy:
        matrix:
          $[stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.unit_tests_linux_arm64_matrix'] ]
      pool:
        name: $(linuxArm64Pool)
      workspace:
        clean: all
      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)
        - template: steps/restore-working-directory.yml
          parameters:
            artifact: build-$(artifactSuffix)-working-directory

        - template: steps/run-in-docker.yml
          parameters:
            build: true
            baseImage: $(baseImage)
            command: "BuildManagedUnitTests --framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)"
            apiKey: $(DD_LOGGER_DD_API_KEY)
            retryCountForRunCommand: 3

        - template: steps/run-in-docker.yml
          parameters:
            build: true
            baseImage: $(baseImage)
            command: "RunManagedUnitTests --framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)"
            apiKey: $(DD_LOGGER_DD_API_KEY)

        - template: steps/make-artifacts-uploadable.yml
        - publish: artifacts/build_data
          artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
          condition: always()
          continueOnError: true

        - task: PublishTestResults@2
          displayName: publish test results
          inputs:
            testResultsFormat: VSTest
            testResultsFiles: artifacts/build_data/results/**/*.trx
          condition: succeededOrFailed()

- stage: build_samples
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
    performComprehensiveTesting: $[eq(variables.perform_comprehensive_testing, 'true')]
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [standalone, multi_version]

    - job: standalone
      timeoutInMinutes: 60 #default value
      pool:
        name: $(windowsX64Pool)
      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - script: tracer\build.cmd CreateRequiredDirectories CompileSamples
          displayName: Build sample projects
          retryCountOnTaskFailure: 1
          env:
            SampleName: $(IntegrationTestSampleName)

        - publish: $(outputDir)/bin
          displayName: Upload artifact samples (bin only)
          artifact: samples-standalone

        - publish: artifacts/build_data
          displayName: Uploading logs
          artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
          condition: failed()
          continueOnError: true

    - job: multi_version
      timeoutInMinutes: 60 #default value
      strategy:
        # TODO: we could move this generation to the generate_variables stage but it would delay this starting, so just hardcode it for now
        matrix:
          net48:
            framework: net48
          netcoreapp2.1:
            framework: netcoreapp2.1
          netcoreapp3.0:
            framework: netcoreapp3.0
          netcoreapp3.1:
            framework: netcoreapp3.1
          net5.0:
            framework: net5.0
          net6.0:
            framework: net6.0
          net7.0:
            framework: net7.0
          net8.0:
            framework: net8.0
          net9.0:
            framework: net9.0
          net10.0:
            framework: net10.0
      pool:
        name: $(windowsX64Pool)
      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - script: tracer\build.cmd CreateRequiredDirectories CompileSamples -Framework $(framework) -TestAllPackageVersions
          displayName: Build sample projects
          retryCountOnTaskFailure: 1
          env:
            SampleName: $(IntegrationTestSampleName)
            IncludeMinorPackageVersions: $(performComprehensiveTesting)

        - publish: $(outputDir)/publish
          displayName: Upload artifact samples (publish only)
          artifact: samples-multi-version-$(framework)

        - publish: artifacts/build_data
          displayName: Uploading logs
          artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
          condition: failed()
          continueOnError: true

# This is just to test that we _can_ build the solution on macos
# It's not used by other stages, and just ensures we don't break the macos build
- stage: build_samples_macos
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [macos]

    - job: macos
      timeoutInMinutes: 60 #default value
      pool:
        vmImage: macos-13
      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)
        - template: steps/install-latest-dotnet-sdk.yml

        - script: ./tracer/build.sh CreateRequiredDirectories CompileSamples
          displayName: Build sample projects
          retryCountOnTaskFailure: 1
          env:
            SampleName: $(IntegrationTestSampleName)

        - publish: artifacts/build_data
          displayName: Uploading logs
          artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
          condition: failed()
          continueOnError: true


- stage: integration_tests_windows
  dependsOn: [build_windows_tracer, generate_variables, merge_commit_id, build_samples]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Win]

  - job: Win
    pool:
      name: $(windowsX64Pool)
    timeoutInMinutes: 90
    strategy:
      matrix: $[stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.integration_tests_windows_matrix'] ]

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/restore-working-directory.yml
    - template: steps/download-samples.yml
      parameters:
        framework: $(framework)
        includeMultiVersions: false

# Cosmos is _way_ to flaky at the moment. Try enabling again at a later time
#    - powershell: |
#        Write-Host "Starting CosmosDB Emulator"
#        Import-Module "C:/Program Files/Azure Cosmos DB Emulator/PSModules/Microsoft.Azure.CosmosDB.Emulator"
#        Start-CosmosDbEmulator -Timeout 300
#      displayName: 'Start CosmosDB Emulator'
#      workingDirectory: $(Pipeline.Workspace)
#      retryCountOnTaskFailure: 5

    - powershell: |
        Write-Host "Initializing LocalDB"
        sqllocaldb.exe start
        sqlcmd.exe -S "(localdb)\MSSQLLocalDB" -i $(Build.Repository.LocalPath)\.azure-pipelines\prepare_localdb.sql
      displayName: 'Initialize LocalDB'
      workingDirectory: $(Build.Repository.LocalPath)

    - script: tracer\build.cmd CompileTrimmingSamples BuildWindowsIntegrationTests BuildWindowsRegressionTests -Framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)
      displayName: Build integration tests
      retryCountOnTaskFailure: 3
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
        enable_crash_dumps: true
        Filter: $(IntegrationTestFilter)
        SampleName: $(IntegrationTestSampleName)

    - script: tracer\build.cmd RunIntegrationTests RunWindowsRegressionTests -Framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)
      displayName: Run integration tests
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
        enable_crash_dumps: true
        Filter: $(IntegrationTestFilter)
        SampleName: $(IntegrationTestSampleName)

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: artifacts/build_data/results/**/*.trx
      condition: succeededOrFailed()

    - publish: artifacts/build_data
      displayName: Uploading integration_tests_windows tracer logs
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - publish: tracer/test/snapshots
      displayName: Uploading snapshots
      artifact: _$(System.StageName)_$(Agent.JobName)_snapshots_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - script: tracer\build.cmd CheckBuildLogsForErrors
      displayName: Check logs for errors

- stage: integration_tests_windows_debugger
  condition: >
    and(
      succeeded(),
      eq(dependencies.generate_variables.outputs['generate_variables_job.generate_variables_step.IsDebuggerChanged'], 'True')
    )
  dependsOn: [build_windows_tracer, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Win]

  - job: Win
    pool:
      name: $(windowsX64Pool)
    timeoutInMinutes: 60 #default value
    strategy:
      matrix: $[stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.integration_tests_windows_debugger_matrix'] ]

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/restore-working-directory.yml

    - script: tracer\build.cmd BuildDebuggerIntegrationTests -Framework $(framework) --TargetPlatform $(targetPlatform) --DebugType $(debugType) --Optimize $(optimize) --code-coverage-enabled $(CodeCoverageEnabled)
      displayName: Build integration tests
      retryCountOnTaskFailure: 3
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
        Filter: $(IntegrationTestFilter)
        SampleName: $(IntegrationTestSampleName)

    - script: tracer\build.cmd RunDebuggerIntegrationTests -Framework $(framework) --TargetPlatform $(targetPlatform) --DebugType $(debugType) --Optimize $(optimize) --code-coverage-enabled $(CodeCoverageEnabled)
      displayName: Run integration tests
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
        Filter: $(IntegrationTestFilter)
        SampleName: $(IntegrationTestSampleName)

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: artifacts/build_data/results/**/*.trx
      condition: succeededOrFailed()

    - publish: artifacts/build_data
      displayName: Uploading integration_tests_windows_debugger tracer logs
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - publish: tracer/test/snapshots
      displayName: Uploading snapshots
      artifact: _$(System.StageName)_$(Agent.JobName)_snapshots_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - script: tracer\build.cmd CheckBuildLogsForErrors
      displayName: Check logs for errors

- stage: integration_tests_windows_iis
  dependsOn: [build_windows_tracer, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]

  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [tracer]

  - job: tracer
    timeoutInMinutes: 60 #default value
    strategy:
      matrix: $[stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.integration_tests_windows_iis_matrix'] ]
    pool:
      name: $(windowsX64Pool)
    variables:
      relativeMsiOutputDirectory: $(relativeArtifacts)/$(targetPlatform)/en-us

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/restore-working-directory.yml

    - script: tracer\build.cmd BuildAspNetIntegrationTests -Framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)
      displayName: Build Integration Tests
      retryCountOnTaskFailure: 3
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
        Filter: $(IntegrationTestFilter)
        SampleName: $(IntegrationTestSampleName)

    - script: tracer\build.cmd RunWindowsTracerIisIntegrationTests -Framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)
      displayName: RunWindowsIisTracerIntegrationTests
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
        Filter: $(IntegrationTestFilter)
        SampleName: $(IntegrationTestSampleName)

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: artifacts/build_data/results/**/*.trx
      condition: succeededOrFailed()

    - publish: artifacts/build_data
      displayName: Uploading integration_tests_windows_iis tracer logs
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - publish: tracer/test/snapshots
      displayName: Uploading snapshots
      artifact: _$(System.StageName)_$(Agent.JobName)_snapshots_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - script: tracer\build.cmd CheckBuildLogsForErrors
      displayName: Check logs for errors

- stage: integration_tests_azure_functions
  dependsOn: [build_windows_tracer, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]

  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [windows]

  - job: windows
    timeoutInMinutes: 60 #default value
    strategy:
      matrix: $[stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.integration_tests_windows_azure_functions_matrix'] ]
    pool:
      name: $(windowsX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    # This is a hack because otherwise Azure Functions _always_ tries to use the one from program files otherwise
    - script: |
        cd /D %PROGRAMFILES%/dotnet
        rename dotnet.exe dotnet.exe.bak
        where dotnet
      displayName: 'Rename default dotnet.exe'
    - template: steps/restore-working-directory.yml
        
    - template: steps/install-msi.yml
      parameters:
        # Pin to a specific version of Azure Functions, as beyond this requires Azurite
        # TODO: Make this floating and use azurite if necessary down the line
        url: "https://github.com/Azure/azure-functions-core-tools/releases/download/4.0.6280/func-cli-4.0.6280-x64.msi"
        filename: "func-cli-4.0.6280-x64.msi"
        addToPath: "C:\\Program Files\\Microsoft\\Azure Functions Core Tools"

    - script: func
      displayName: 'Display Azure Functions core tools'
      workingDirectory: $(Pipeline.Workspace)

    - script: |
        "%ProgramFiles(x86)%\Microsoft SDKs\Azure\Storage Emulator\AzureStorageEmulator.exe" start
      displayName: 'Start Azure Storage Emulator'
      workingDirectory: $(Pipeline.Workspace)
      retryCountOnTaskFailure: 5

    - script: tracer\build.cmd BuildAndRunWindowsAzureFunctionsTests -Framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)
      displayName: Run Azure Functions tests
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
        Filter: $(IntegrationTestFilter)
        SampleName: $(IntegrationTestSampleName)

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: artifacts/build_data/results/**/*.trx
      condition: succeededOrFailed()

    - publish: artifacts/build_data
      displayName: Uploading tracer logs
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - publish: tracer/test/snapshots
      displayName: Uploading snapshots
      artifact: _$(System.StageName)_$(Agent.JobName)_snapshots_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - script: tracer\build.cmd CheckBuildLogsForErrors
      displayName: Check logs for errors

- stage: static_analysis_checks_tracer
  dependsOn: [merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
    baseImage: "debian"
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [linux, macos]

  - job: linux
    timeoutInMinutes: 60 #default value
    dependsOn: []
    pool:
      name: $(linuxX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: $(baseImage)
        command: "CppCheckNativeSrc CppCheckNativeLoader"
        retryCountForRunCommand: 1

  - job: macos
    timeoutInMinutes: 60 #default value
    dependsOn: [ ]
    pool:
      vmImage: macos-13
    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/install-latest-dotnet-sdk.yml

    - script: brew install cppcheck
      displayName: Installing CppCheck

    - script: ./tracer/build.sh CppCheckNativeSrc CppCheckNativeLoader
      displayName: Run cpp check
      retryCountOnTaskFailure: 1

- stage: static_analysis_tests_profiler
  condition: >
    and(
      succeeded(), 
      eq(dependencies.generate_variables.outputs['generate_variables_job.generate_variables_step.IsProfilerChanged'], 'True')
    )
  dependsOn: [merge_commit_id, generate_variables]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Win, Linux]

  - job: Win
    pool:
      name: $(windowsX64Pool)
    timeoutInMinutes: 60 #default value

    steps:
    # Based on https://community.chocolatey.org/packages/cppcheck#files
    # Not using chocolatey as we're getting 429 Too Many Requests
    - template: steps/install-msi.yml
      parameters:
        url: "https://github.com/danmar/cppcheck/releases/download/2.14.2/cppcheck-2.14.2-x64-Setup.msi"
        filename: "cppcheck.msi"
        addToPath: "C:\\Program Files\\Cppcheck"
        msiParams: "ADDLOCAL=CppcheckCore,CLI,GUI,Translations,ConfigFiles,PlatformFiles,PythonAddons,CRT"

    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - script: tracer\build.cmd RunCppCheckProfiler RunClangTidyProfiler
      displayName: Run CppCheck and Clang-Tidy on Profiler

    - script: tracer\build.cmd CheckProfilerStaticAnalysisResults
      displayName: Check static analyzers results for errors

    - publish: profiler/build_data
      displayName: Publish Static Analysis Results
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: succeededOrFailed()
      continueOnError: true

  - job: Linux
    timeoutInMinutes: 60 #default value
    pool:
      name: $(linuxX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        command: "RunCppCheckProfiler RunClangTidyProfiler"

    - template: steps/run-in-docker.yml
      parameters:
        build: false
        target: builder
        command: "CheckProfilerStaticAnalysisResults"

    - publish: profiler/build_data
      displayName: Publish Static Analysis Results
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: succeededOrFailed()
      continueOnError: true

- stage: msi_integration_tests_windows
  dependsOn: [build_windows_tracer, package_windows, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]

  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [msi_tests, fleet_installer_tests]

  - job: msi_tests
    timeoutInMinutes: 60 #default value
    strategy:
      matrix: $[stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.integration_tests_windows_msi_matrix'] ]
    pool:
      name: $(windowsX64Pool)
    variables:
      relativeMsiOutputDirectory: /artifacts/msi/$(targetPlatform)/en-us

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/restore-working-directory.yml

    - template: steps/download-artifact.yml
      parameters:
        artifact: windows-msi-$(targetPlatform)
        path: $(System.DefaultWorkingDirectory)$(relativeMsiOutputDirectory)
        patterns: '**/*-$(targetPlatform).msi'

    - script: tracer\build.cmd BuildAspNetIntegrationTests -Framework $(framework)
      displayName: BuildWindowsIntegrationTests
      retryCountOnTaskFailure: 3

    - powershell: |
        mkdir -Force ./artifacts/build_data/snapshots
        mkdir -Force ./artifacts/build_data/logs/LoaderOptimizationStartup
        mkdir -Force ./artifacts/build_data/logs/MultipleAppsInDomain
        docker compose -f docker-compose.windows.yml run --rm start-test-agent.windows

        docker compose -f docker-compose.windows.yml build `
            --build-arg DOTNET_TRACER_MSI=.$(relativeMsiOutputDirectory)/*.msi `
            --build-arg ENABLE_32_BIT=$(enable32bit) `
            IntegrationTests.IIS.LoaderOptimizationStartup

        docker compose -f docker-compose.windows.yml build `
            --build-arg DOTNET_TRACER_MSI=.$(relativeMsiOutputDirectory)/*.msi `
            --build-arg ENABLE_32_BIT=$(enable32bit) `
            IntegrationTests.IIS.MultipleAppsInDomain

        docker compose -f docker-compose.windows.yml up -d IntegrationTests.IIS.LoaderOptimizationStartup IntegrationTests.IIS.MultipleAppsInDomain
      displayName: docker-compose start IntegrationTests.IIS
      retryCountOnTaskFailure: 5
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)

    - script: tracer\build.cmd RunWindowsMsiIntegrationTests -Framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)
      displayName: RunWindowsIisIntegrationTests
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: artifacts/build_data/results/**/*.trx
      condition: succeededOrFailed()

    - script: docker compose  -f docker-compose.windows.yml down
      displayName: docker-compose stop services
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
      condition: succeededOrFailed()
      continueOnError: true

    - publish: artifacts/build_data
      displayName: Uploading integration_tests_windows_msi tracer logs
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - publish: tracer/test/snapshots
      displayName: Uploading snapshots
      artifact: _$(System.StageName)_$(Agent.JobName)_snapshots_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - script: tracer\build.cmd CheckBuildLogsForErrors
      displayName: Check logs for errors

  - job: fleet_installer_tests
    timeoutInMinutes: 60 #default value
    pool:
      name: $(windowsX64Pool)
    variables:
      framework: net48

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/restore-working-directory.yml

    - script: tracer\build.cmd BuildWindowsIntegrationTests  -Framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)
      displayName: BuildWindowsIntegrationTests
      retryCountOnTaskFailure: 3

    - script: tracer\build.cmd RunIntegrationTests -filter FleetInstaller=True -Framework $(framework) --code-coverage-enabled $(CodeCoverageEnabled)
      displayName: RunWindowsIisIntegrationTests
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: artifacts/build_data/results/**/*.trx
      condition: succeededOrFailed()

    - publish: artifacts/build_data
      displayName: Uploading tracer logs
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - publish: tracer/test/snapshots
      displayName: Uploading snapshots
      artifact: _$(System.StageName)_$(Agent.JobName)_snapshots_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - script: tracer\build.cmd CheckBuildLogsForErrors
      displayName: Check logs for errors

- stage: integration_tests_linux
  dependsOn: [build_linux_tracer, build_linux_universal, build_linux_profiler, generate_variables, merge_commit_id, build_samples]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Test, DockerTest, Serverless]

  - job: Test
    timeoutInMinutes: 60 #default value
    strategy:
      matrix: $[stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.integration_tests_linux_matrix']]

    variables:
      TestAllPackageVersions: true
      IncludeMinorPackageVersions:  $[eq(variables.perform_comprehensive_testing, 'true')]

    pool:
      name: $(linuxX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/restore-working-directory-for-tests.yml
      parameters:
        artifactSuffix: $(artifactSuffix)
    - template: steps/download-samples.yml
      parameters:
        framework: $(publishTargetFramework)

    # when we build samples separately, we could run this step and the docker-compose one below in //
    # (currently the docker-compose step relies on serverless samples)
    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: $(baseImage)
        command: "BuildLinuxIntegrationTests CompileTrimmingSamples --framework $(publishTargetFramework) --IncludeTestsRequiringDocker false --Filter $(IntegrationTestFilter) --SampleName $(IntegrationTestSampleName)"
        apikey: $(DD_LOGGER_DD_API_KEY)
        retryCountForRunCommand: 3

    - script: |
        docker-compose -f docker-compose.yml -p $(DockerComposeProjectName) \
          run --no-deps --rm \
          -e baseImage=$(baseImage) \
          -e framework=$(publishTargetFramework) \
          -e CodeCoverageEnabled=$(CodeCoverageEnabled) \
          -e IncludeTestsRequiringDocker=false  \
          -e Filter=$(IntegrationTestFilter) \
          -e SampleName=$(IntegrationTestSampleName) \
          -e Area=$(area) \
          IntegrationTests
      displayName: docker-compose run IntegrationTests
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
        baseImage: $(baseImage) # for interpolation in the docker-compose file

    - template: steps/make-artifacts-uploadable.yml
    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: artifacts/build_data/results/**/*.trx
      condition: succeededOrFailed()

    - publish: tracer/test/snapshots
      displayName: Uploading snapshots
      artifact: _$(System.StageName)_$(Agent.JobName)_snapshots_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/run-in-docker.yml
      parameters:
        baseImage: $(baseImage)
        command: "CheckBuildLogsForErrors"
        apiKey: $(DD_LOGGER_DD_API_KEY)

  - job: DockerTest
    timeoutInMinutes: 60 #default value
    strategy:
      matrix: $[stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.integration_tests_linux_docker_matrix']]

    variables:
      TestAllPackageVersions: true
      IncludeMinorPackageVersions:  $[eq(variables.perform_comprehensive_testing, 'true')]

    pool:
      name: $(linuxX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/restore-working-directory-for-tests.yml
      parameters:
        artifactSuffix: $(artifactSuffix)
    - template: steps/download-samples.yml
      parameters:
        framework: $(publishTargetFramework)

    # when we build samples separately, we could run this step and the docker-compose one below in //
    # (currently the docker-compose step relies on serverless samples)
    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: $(baseImage)
        command: "BuildLinuxIntegrationTests CompileTrimmingSamples --framework $(publishTargetFramework) --IncludeTestsRequiringDocker true --Filter $(IntegrationTestFilter) --SampleName $(IntegrationTestSampleName)"
        apiKey: $(DD_LOGGER_DD_API_KEY)
        retryCountForRunCommand: 3

    - script: |
        docker-compose -p $(DockerComposeProjectName) build --build-arg baseImage=$(baseImage) --build-arg framework=$(publishTargetFramework) --build-arg CodeCoverageEnabled=$(CodeCoverageEnabled) --build-arg Filter=$(IntegrationTestFilter) --build-arg SampleName=$(IntegrationTestSampleName) IntegrationTests
        docker-compose -p $(DockerComposeProjectName) run --rm StartDependencies
      env:
        baseImage: $(baseImage)
        framework: $(publishTargetFramework)
        Filter: $(IntegrationTestFilter)
        SampleName: $(IntegrationTestSampleName)
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
      displayName: docker-compose build IntegrationTests and run StartDependencies
      retryCountOnTaskFailure: 5

    - script: |
        docker-compose -f docker-compose.yml -p $(DockerComposeProjectName) \
          run --rm \
          -e baseImage=$(baseImage) \
          -e framework=$(publishTargetFramework) \
          -e CodeCoverageEnabled=$(CodeCoverageEnabled) \
          -e IncludeTestsRequiringDocker=true \
          -e Filter=$(IntegrationTestFilter) \
          -e SampleName=$(IntegrationTestSampleName) \
          -e Area=$(area) \
          IntegrationTests
      displayName: docker-compose run IntegrationTests
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
        baseImage: $(baseImage) # for interpolation in the docker-compose file

    - script: docker-compose -f docker-compose.yml -p $(DockerComposeProjectName) logs
      displayName: docker-compose logs
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
      condition: succeededOrFailed()
      continueOnError: true

    - script: docker-compose -f docker-compose.yml -p $(DockerComposeProjectName) down
      displayName: docker-compose stop services
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
      condition: succeededOrFailed()
      continueOnError: true

    - template: steps/make-artifacts-uploadable.yml
    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: artifacts/build_data/results/**/*.trx
      condition: succeededOrFailed()

    - publish: tracer/test/snapshots
      displayName: Uploading snapshots
      artifact: _$(System.StageName)_$(Agent.JobName)_snapshots_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/run-in-docker.yml
      parameters:
        baseImage: $(baseImage)
        command: "CheckBuildLogsForErrors"
        apiKey: $(DD_LOGGER_DD_API_KEY)

  - job: Serverless
    timeoutInMinutes: 60

    variables:
      TestAllPackageVersions: false
      IncludeMinorPackageVersions:  false
      baseImage: "debian"
      artifactSuffix: "linux-x64"

    strategy:
      matrix:
        net6:
          publishTargetFramework: "net6.0"
          lambdaBaseImage: "public.ecr.aws/lambda/dotnet:6"
        net7:
          publishTargetFramework: "net7.0"
          lambdaBaseImage: "public.ecr.aws/lambda/dotnet:7"
        net8:
          publishTargetFramework: "net8.0"
          lambdaBaseImage: "public.ecr.aws/lambda/dotnet:8"
        net9:
          publishTargetFramework: "net9.0"
          lambdaBaseImage: "public.ecr.aws/lambda/dotnet:9"
    pool:
      name: $(linuxX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/restore-working-directory-for-tests.yml
      parameters:
        artifactSuffix: $(artifactSuffix)
    - template: steps/download-samples.yml
      parameters:
        framework: $(publishTargetFramework)

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: $(baseImage)
        command: "BuildLinuxIntegrationTests --framework $(publishTargetFramework) --SampleName Samples.Aws.Lambda"
        apiKey: $(DD_LOGGER_DD_API_KEY)
        retryCountForRunCommand: 3

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: $(baseImage)
        command: "BuildLinuxIntegrationTests --framework $(publishTargetFramework) --SampleName Samples.Amazon.Lambda.RuntimeSupport"
        apiKey: $(DD_LOGGER_DD_API_KEY)
        retryCountForRunCommand: 3
        
    - script: |
        # Include the serverless dockerfile
        docker-compose -p $(DockerComposeProjectName) \
          -f $(System.DefaultWorkingDirectory)/docker-compose.yml \
          -f docker-compose.serverless.yml \
          build \
          --build-arg baseImage=$(baseImage) \
          --build-arg framework=$(publishTargetFramework) \
          --build-arg CodeCoverageEnabled=$(CodeCoverageEnabled) \
          IntegrationTests.Serverless

        docker-compose -p $(DockerComposeProjectName) \
          -f $(System.DefaultWorkingDirectory)/docker-compose.yml \
          -f docker-compose.serverless.yml \
          --build-arg CodeCoverageEnabled=$(CodeCoverageEnabled) \
          --build-arg framework=$(publishTargetFramework) \
          pull --include-deps StartDependencies.Serverless

        docker-compose -p $(DockerComposeProjectName) \
          -f $(System.DefaultWorkingDirectory)/docker-compose.yml \
          -f docker-compose.serverless.yml \
          run --rm StartDependencies.Serverless
      env:
        baseImage: $(baseImage)
        framework: $(publishTargetFramework)
        lambdaBaseImage: $(lambdaBaseImage)
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
      displayName: docker-compose build IntegrationTests.Serverless and run StartDependencies.Serverless
      retryCountOnTaskFailure: 5

    - script: |
        docker-compose -f docker-compose.yml -f docker-compose.serverless.yml -p $(DockerComposeProjectName) \
          run --rm \
          -e baseImage=$(baseImage) \
          -e framework=$(publishTargetFramework) \
          -e lambdaBaseImage=$(lambdaBaseImage) \
          -e CodeCoverageEnabled=$(CodeCoverageEnabled) \
          IntegrationTests.Serverless
      displayName: docker-compose run IntegrationTests.Serverless
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
        baseImage: $(baseImage) # for interpolation in the docker-compose file

    - script: |
        mkdir -p artifacts/build_data/docker

        docker-compose -p $(DockerComposeProjectName) \
          -f $(System.DefaultWorkingDirectory)/docker-compose.yml \
          -f docker-compose.serverless.yml \
          logs \
          serverless-lambda-no-param-sync \
          serverless-lambda-one-param-sync \
          serverless-lambda-two-params-sync \
          serverless-lambda-no-param-sync-with-context \
          serverless-lambda-one-param-sync-with-context \
          serverless-lambda-two-params-sync-with-context \
          serverless-lambda-no-param-async \
          serverless-lambda-one-param-async \
          serverless-lambda-two-params-async \
          serverless-lambda-no-param-void \
          serverless-lambda-one-param-void \
          serverless-lambda-two-params-void \
          serverless-lambda-struct-param \
          serverless-lambda-nested-class-param \
          serverless-lambda-nested-struct-param \
          serverless-lambda-generic-dict-param \
          serverless-lambda-nested-generic-dict-param \
          serverless-lambda-doubly-nested-generic-dict-param \
          serverless-lambda-throwing \
          serverless-lambda-throwing-async \
          serverless-lambda-throwing-async-task \
          serverless-lambda-throwing-with-context \
          serverless-lambda-throwing-async-with-context \
          serverless-lambda-throwing-async-task-with-context \
          serverless-lambda-generic \
          serverless-lambda-generic-async \
          serverless-lambda-generic-virtual \
          serverless-lambda-generic-virtual-async \
          serverless-lambda-generic-abstract \
          serverless-lambda-generic-abstract-async \
          serverless-lambda-generic-complex \
          serverless-lambda-generic-complex-nested \
          serverless-lambda-toplevel-statement
      env:
        baseImage: $(baseImage)
        framework: $(publishTargetFramework)
        DD_LOGGER_DD_API_KEY: $(DD_LOGGER_DD_API_KEY)
      displayName: docker-compose logs for serverless services
      condition: succeededOrFailed()
      retryCountOnTaskFailure: 5

    - script: docker-compose -f docker-compose.yml -f docker-compose.serverless.yml -p $(DockerComposeProjectName) down
      displayName: docker-compose stop services
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
      condition: succeededOrFailed()
      continueOnError: true

    - template: steps/make-artifacts-uploadable.yml
    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: artifacts/build_data/results/**/*.trx
      condition: succeededOrFailed()

    - publish: tracer/test/snapshots
      displayName: Uploading snapshots
      artifact: _$(System.StageName)_$(Agent.JobName)_snapshots_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/run-in-docker.yml
      parameters:
        baseImage: $(baseImage)
        command: "CheckBuildLogsForErrors"
        apiKey: $(DD_LOGGER_DD_API_KEY)

- stage: integration_tests_linux_debugger
  condition: >
    and(
      succeeded(),
      eq(dependencies.generate_variables.outputs['generate_variables_job.generate_variables_step.IsDebuggerChanged'], 'True')
    )
  dependsOn: [build_linux_tracer, build_linux_universal, build_linux_profiler, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Test]

  - job: Test
    timeoutInMinutes: 60 #default value
    strategy:
      matrix: $[stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.integration_tests_linux_debugger_matrix']]

    variables:
      TestAllPackageVersions: true
      IncludeMinorPackageVersions:  $[eq(variables.perform_comprehensive_testing, 'true')]

    pool:
      name: $(linuxX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/restore-working-directory-for-tests.yml
      parameters:
        artifactSuffix: $(artifactSuffix)

    # when we build samples separately, we could run this step and the docker-compose one below in //
    # (currently the docker-compose step relies on serverless samples)
    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: $(baseImage)
        command: "BuildDebuggerIntegrationTests --framework $(publishTargetFramework) --targetplatform x64 --debugtype portable --optimize $(optimize)"
        apikey: $(DD_LOGGER_DD_API_KEY)
        retryCountForRunCommand: 3

    - script: |
        docker-compose -f docker-compose.yml -p $(DockerComposeProjectName) \
          run --no-deps --rm \
          -e baseImage=$(baseImage) \
          -e framework=$(publishTargetFramework) \
          -e CodeCoverageEnabled=$(CodeCoverageEnabled) \
          IntegrationTests.Debugger
      displayName: docker-compose run --no-deps IntegrationTests.Debugger
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
        baseImage: $(baseImage) # for interpolation in the docker-compose file

    - template: steps/make-artifacts-uploadable.yml
    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: artifacts/build_data/results/**/*.trx
      condition: succeededOrFailed()

    - publish: tracer/test/Datadog.Trace.Debugger.IntegrationTests/Approvals
      displayName: Uploading snapshots
      artifact: _$(System.StageName)_$(Agent.JobName)_snapshots_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/run-in-docker.yml
      parameters:
        baseImage: $(baseImage)
        command: "CheckBuildLogsForErrors"
        apiKey: $(DD_LOGGER_DD_API_KEY)

- stage: profiler_integration_tests_windows
  condition: >
    and(
      succeeded(),
      or(
        eq(variables.isMainOrReleaseBranch, true),
        eq(dependencies.generate_variables.outputs['generate_variables_job.generate_variables_step.IsProfilerChanged'], 'True')
      )
    )
  dependsOn: [package_windows, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Win]

  - job: Win
    timeoutInMinutes: 60 #default value
    strategy:
      matrix:
        x86:
          targetPlatform: "x86"
        x64:
          targetPlatform: "x64"

    variables:
      IncludeMinorPackageVersions:  $[eq(variables.perform_comprehensive_testing, 'true')]

    pool:
      name: $(windowsX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    # windows-tracer-home.zip file contains profiler, tracer...
    - template: steps/download-artifact.yml
      parameters:
        artifact: windows-tracer-home.zip
        path: $(Agent.TempDirectory)
        patterns: "windows-tracer-home.zip"

    - task: ExtractFiles@1
      inputs:
        archiveFilePatterns: '$(Agent.TempDirectory)/windows-tracer-home.zip'
        destinationFolder: $(monitoringHome)

    - script: tracer\build.cmd BuildProfilerSamples BuildAndRunProfilerIntegrationTests --TargetPlatform $(targetPlatform)
      displayName: Run Profiler Integration tests
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)

    - publish: profiler/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: profiler/build_data/results/**/*.trx
      condition: succeededOrFailed()

- stage: profiler_integration_tests_linux
  condition: >
    and(
      succeeded(),
      or(
        eq(variables.isMainOrReleaseBranch, true),
        eq(dependencies.generate_variables.outputs['generate_variables_job.generate_variables_step.IsProfilerChanged'], 'True')
      )
    )
  dependsOn: [package_linux, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Test]

  - job: Test
    timeoutInMinutes: 60 #default value
    strategy:
      matrix:
        x64:
          baseImage: debian
          useNativeSdkVersion: ""
          artifactSuffix: linux-x64
        alpine:
          baseImage: alpine
          useNativeSdkVersion: ""
          artifactSuffix: linux-musl-x64

    variables:
      IncludeMinorPackageVersions:  $[eq(variables.perform_comprehensive_testing, 'true')]

    pool:
      name: $(linuxX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/restore-working-directory.yml
      parameters:
        artifact: build-$(artifactSuffix)-working-directory

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-monitoring-home-$(artifactSuffix)
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-profiler-symbols-$(artifactSuffix)
        path: $(monitoringHome)

    # when we build samples separately, we could run this step and the docker-compose one below in //
    # (currently the docker-compose step relies on serverless samples)
    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: $(baseImage)
        useNativeSdkVersion: $(useNativeSdkVersion)
        command: "BuildProfilerSamples"
        apiKey: $(DD_LOGGER_DD_API_KEY)

    - template: steps/run-in-docker.yml
      parameters:
        baseImage: $(baseImage)
        useNativeSdkVersion: $(useNativeSdkVersion)
        command: "BuildAndRunProfilerCpuLimitTests"
        extraArgs: "--cpus 2 --env CONTAINER_CPUS=1"
        apiKey: $(DD_LOGGER_DD_API_KEY)

    - template: steps/run-in-docker.yml
      parameters:
        baseImage: $(baseImage)
        useNativeSdkVersion: $(useNativeSdkVersion)
        command: "BuildAndRunProfilerCpuLimitTests"
        extraArgs: "--cpus 0.5 --env CONTAINER_CPUS=0.5"
        apiKey: $(DD_LOGGER_DD_API_KEY)

    - script: |
        docker-compose -f docker-compose.yml -p $(DockerComposeProjectName) \
          run --rm \
          -e baseImage=$(baseImage) \
          ProfilerIntegrationTests
      displayName: docker-compose run --no-deps ProfilerIntegrationTests
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
        baseImage: $(baseImage) # for interpolation in the docker-compose file

    - publish: profiler/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: profiler/build_data/results/**/*.trx
      condition: succeededOrFailed()

- stage: asan_profiler_tests
  #address sanitizer tests
  condition: >
    and(
      succeeded(), 
      eq(dependencies.generate_variables.outputs['generate_variables_job.generate_variables_step.IsProfilerChanged'], 'True')
    )
  dependsOn: [merge_commit_id, generate_variables]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Linux,Windows]
      allowSkipped: true

  - job: Linux
    timeoutInMinutes: 60 #default value

    pool:
      name: $(linuxX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - script: |
        sudo sysctl vm.mmap_rnd_bits=28

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: centos7
        useNativeSdkVersion: true
        command: "BuildProfilerAsanTest -Framework net7.0"
        apiKey: $(DD_LOGGER_DD_API_KEY)

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: debian
        command: "BuildProfilerSampleForSanitiserTests -Framework net7.0"
        apiKey: $(DD_LOGGER_DD_API_KEY)
        
    - template: steps/run-in-docker.yml
      parameters:
        target: builder
        baseImage: centos7
        useNativeSdkVersion: true
        command: "RunSampleWithProfilerAsan -Framework net7.0"
        apiKey: $(DD_LOGGER_DD_API_KEY)

    - publish: profiler/build_data
      displayName: Uploading Address sanitizer test results
      artifact: _$(System.StageName)_$(Agent.JobName)_test_results_$(System.JobAttempt)
      condition: always()
      continueOnError: false

  - job: Windows
    # disable the job for now, we would need a VS update on the runner
    condition: false
    timeoutInMinutes: 60 #default value
    pool:
      name: $(windowsX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - script: tracer\build.cmd RunProfilerAsanTest -Framework net8.0
      displayName: Run Profiler ASAN test

    - publish: profiler/build_data
      displayName: Uploading Address sanitizer test results
      artifact: _$(System.StageName)_$(Agent.JobName)_test_results_$(System.JobAttempt)
      condition: always()
      continueOnError: false

- stage: ubsan_profiler_tests
#undefined behavior sanitizer tests
  condition: > 
    and(
      succeeded(), 
      eq(dependencies.generate_variables.outputs['generate_variables_job.generate_variables_step.IsProfilerChanged'], 'True')
    )
  dependsOn: [merge_commit_id, generate_variables]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Linux]

  - job: Linux
    timeoutInMinutes: 60 #default value

    pool:
      name: $(linuxX64Pool)

    steps:

    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: centos7
        useNativeSdkVersion: true
        command: "BuildProfilerUbsanTest -Framework net7.0"
        apiKey: $(DD_LOGGER_DD_API_KEY)

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: debian
        command: "BuildProfilerSampleForSanitiserTests -Framework net7.0"
        apiKey: $(DD_LOGGER_DD_API_KEY)

    - template: steps/run-in-docker.yml
      parameters:
        target: builder
        baseImage: centos7
        useNativeSdkVersion: true
        command: "RunSampleWithProfilerUbsan -Framework net7.0"
        apiKey: $(DD_LOGGER_DD_API_KEY)

    - publish: profiler/build_data
      displayName: Uploading test results
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: false

- stage: tsan_profiler_tests
  #thread sanitizer tests
  condition: >
    and(
      succeeded(), 
      eq(dependencies.generate_variables.outputs['generate_variables_job.generate_variables_step.IsProfilerChanged'], 'True')
    )
  dependsOn: [merge_commit_id, generate_variables]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Linux]
      allowSkipped: true

  - job: Linux
    timeoutInMinutes: 60 #default value

    pool:
      name: $(linuxX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - script: |
        sudo sysctl vm.mmap_rnd_bits=28
        sudo sysctl kernel.randomize_va_space=1

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        target: builder
        baseImage: centos7
        useNativeSdkVersion: true
        command: "BuildProfilerTsanTest RunUnitTestsWithTsanLinux -Framework net7.0"
        apiKey: $(DD_LOGGER_DD_API_KEY)

    - publish: profiler/build_data
      displayName: Uploading Thread sanitizer test results
      artifact: _$(System.StageName)_$(Agent.JobName)_test_results_$(System.JobAttempt)
      condition: always()
      continueOnError: false

- stage: integration_tests_arm64
  dependsOn: [build_arm64_tracer, build_arm64_universal, build_arm64_profiler, generate_variables, merge_commit_id, build_samples]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
    TestAllPackageVersions: true
    IncludeMinorPackageVersions: $[eq(variables.perform_comprehensive_testing, 'true')]

 
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [Test, DockerTest]

    - job: Test
      timeoutInMinutes: 90 #default value
      strategy:
        matrix: $[stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.integration_tests_linux_arm64_matrix']]
      workspace:
        clean: all
      pool:
        name: $(linuxArm64Pool)

      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - template: steps/restore-working-directory-for-tests.yml
          parameters:
            artifactSuffix: $(artifactSuffix)
        - template: steps/download-samples.yml
          parameters:
            framework: $(publishTargetFramework)

        - template: steps/run-in-docker.yml
          parameters:
            build: true
            baseImage: $(baseImage)
            command: "BuildLinuxIntegrationTests CompileTrimmingSamples --framework $(publishTargetFramework) --IncludeTestsRequiringDocker false --Filter $(IntegrationTestFilter) --SampleName $(IntegrationTestSampleName)"
            apiKey: $(DD_LOGGER_DD_API_KEY)
            retryCountForRunCommand: 3

        - script: |
            docker-compose -f docker-compose.yml -f docker-compose.serverless.yml -p $(DockerComposeProjectName) \
              run --no-deps --rm \
              -e baseImage=$(baseImage) \
              -e framework=$(publishTargetFramework) \
              -e CodeCoverageEnabled=$(CodeCoverageEnabled) \
              -e IncludeTestsRequiringDocker=false \
              -e Filter=$(IntegrationTestFilter) \
              -e SampleName=$(IntegrationTestSampleName) \
              IntegrationTests.ARM64
          displayName: docker-compose run --no-deps IntegrationTests
          env:
            DD_LOGGER_DD_API_KEY: $(ddApiKey)
            baseImage: $(baseImage) # for interpolation in the docker-compose file

        - template: steps/make-artifacts-uploadable.yml
        - publish: artifacts/build_data
          artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
          condition: always()
          continueOnError: true

        - task: PublishTestResults@2
          displayName: publish test results
          inputs:
            testResultsFormat: VSTest
            testResultsFiles: artifacts/build_data/results/**/*.trx
          condition: succeededOrFailed()

        - publish: tracer/test/snapshots
          displayName: Uploading snapshots
          artifact: _$(System.StageName)_$(Agent.JobName)_snapshots_$(System.JobAttempt)
          condition: always()
          continueOnError: true

        - template: steps/run-in-docker.yml
          parameters:
            baseImage: $(baseImage)
            command: "CheckBuildLogsForErrors"
            apiKey: $(DD_LOGGER_DD_API_KEY)

    - job: DockerTest
      timeoutInMinutes: 60 #default value
      strategy:
        matrix: $[stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.integration_tests_linux_arm64_matrix']]
      workspace:
        clean: all
      pool:
        name: $(linuxArm64Pool)

      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - template: steps/restore-working-directory-for-tests.yml
          parameters:
            artifactSuffix: $(artifactSuffix)
        - template: steps/download-samples.yml
          parameters:
            framework: $(publishTargetFramework)

        - template: steps/run-in-docker.yml
          parameters:
            build: true
            baseImage: $(baseImage)
            command: "BuildLinuxIntegrationTests --framework $(publishTargetFramework) --IncludeTestsRequiringDocker true --Filter $(IntegrationTestFilter) --SampleName $(IntegrationTestSampleName)"
            apiKey: $(DD_LOGGER_DD_API_KEY)
            retryCountForRunCommand: 3

        - script: |
            docker-compose -p $(DockerComposeProjectName) build --build-arg baseImage=$(baseImage) --build-arg framework=$(publishTargetFramework) --build-arg CodeCoverageEnabled=$(CodeCoverageEnabled) IntegrationTests.ARM64
            docker-compose -p $(DockerComposeProjectName) run --rm StartDependencies.ARM64
          env:
            baseImage: $(baseImage)
            framework: $(publishTargetFramework)
            Filter: $(IntegrationTestFilter)
            SampleName: $(IntegrationTestSampleName)
            DD_LOGGER_DD_API_KEY: $(ddApiKey)
          displayName: docker-compose build IntegrationTests and run StartDependencies
          retryCountOnTaskFailure: 5

        - script: |
            docker-compose -f docker-compose.yml -p $(DockerComposeProjectName) \
              run --rm \
              -e baseImage=$(baseImage) \
              -e framework=$(publishTargetFramework) \
              -e CodeCoverageEnabled=$(CodeCoverageEnabled) \
              -e IncludeTestsRequiringDocker=true \
              -e Filter=$(IntegrationTestFilter) \
              -e SampleName=$(IntegrationTestSampleName) \
              IntegrationTests.ARM64 \
          displayName: docker-compose run IntegrationTests
          env:
            DD_LOGGER_DD_API_KEY: $(ddApiKey)
            baseImage: $(baseImage) # for interpolation in the docker-compose file

        - script: docker-compose -f docker-compose.yml -p $(DockerComposeProjectName) logs
          displayName: docker-compose logs
          env:
            DD_LOGGER_DD_API_KEY: $(ddApiKey)
          condition: succeededOrFailed()
          continueOnError: true

        - script: docker-compose -f docker-compose.yml -p $(DockerComposeProjectName) down
          displayName: docker-compose stop services
          env:
            DD_LOGGER_DD_API_KEY: $(ddApiKey)
          condition: succeededOrFailed()
          continueOnError: true

        - template: steps/make-artifacts-uploadable.yml
        - publish: artifacts/build_data
          artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
          condition: always()
          continueOnError: true

        - task: PublishTestResults@2
          displayName: publish test results
          inputs:
            testResultsFormat: VSTest
            testResultsFiles: artifacts/build_data/results/**/*.trx
          condition: succeededOrFailed()

        - publish: tracer/test/snapshots
          displayName: Uploading snapshots
          artifact: _$(System.StageName)_$(Agent.JobName)_snapshots_$(System.JobAttempt)
          condition: always()
          continueOnError: true

        - template: steps/run-in-docker.yml
          parameters:
            baseImage: $(baseImage)
            command: "CheckBuildLogsForErrors"
            apiKey: $(DD_LOGGER_DD_API_KEY)

- stage: integration_tests_arm64_debugger
  condition: >
    and(
      succeeded(),
      eq(dependencies.generate_variables.outputs['generate_variables_job.generate_variables_step.IsDebuggerChanged'], 'True')
    )
  dependsOn: [build_arm64_tracer, build_arm64_universal, build_arm64_profiler, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]

  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [Test]

    - job: Test
      timeoutInMinutes: 60 #default value
      strategy:
        matrix: $[stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.integration_tests_arm64_debugger_matrix']]

      workspace:
        clean: all
      pool:
        name: $(linuxArm64Pool)

      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - template: steps/restore-working-directory-for-tests.yml
          parameters:
            artifactSuffix: $(artifactSuffix)

        - template: steps/run-in-docker.yml
          parameters:
            build: true
            baseImage: $(baseImage)
            command: "BuildDebuggerIntegrationTests --framework $(publishTargetFramework) --targetplatform x64 --debugtype portable --optimize $(optimize)"
            apiKey: $(DD_LOGGER_DD_API_KEY)

        - script: |
            docker-compose -f docker-compose.yml -p $(DockerComposeProjectName) \
              run --no-deps --rm \
              -e baseImage=$(baseImage) \
              -e framework=$(publishTargetFramework) \
              -e CodeCoverageEnabled=$(CodeCoverageEnabled) \
              IntegrationTests.ARM64.Debugger
          displayName: docker-compose run --no-deps IntegrationTests.ARM64.Debugger
          env:
            DD_LOGGER_DD_API_KEY: $(ddApiKey)
            baseImage: $(baseImage) # for interpolation in the docker-compose file

        - template: steps/make-artifacts-uploadable.yml
        - publish: artifacts/build_data
          artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
          condition: always()
          continueOnError: true

        - task: PublishTestResults@2
          displayName: publish test results
          inputs:
            testResultsFormat: VSTest
            testResultsFiles: artifacts/build_data/results/**/*.trx
          condition: succeededOrFailed()

        - publish: tracer/test/snapshots
          displayName: Uploading snapshots
          artifact: _$(System.StageName)_$(Agent.JobName)_snapshots_$(System.JobAttempt)
          condition: always()
          continueOnError: true

        - template: steps/run-in-docker.yml
          parameters:
            baseImage: $(baseImage)
            command: "CheckBuildLogsForErrors"
            apiKey: $(DD_LOGGER_DD_API_KEY)

- stage: exploration_tests_windows
  condition: >
    and(
      succeeded(),
      or(
        eq(dependencies.generate_variables.outputs['generate_variables_job.generate_variables_step.IsTracerChanged'],'True'),
        eq(dependencies.generate_variables.outputs['generate_variables_job.generate_variables_step.IsProfilerChanged'], 'True'),
        eq(dependencies.generate_variables.outputs['generate_variables_job.generate_variables_step.IsDebuggerChanged'], 'True')
      )
    )
  dependsOn: [build_windows_tracer, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]

  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [ExplorationTest]

  - job: ExplorationTest
    timeoutInMinutes: 100
    strategy:
      matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.exploration_tests_windows_matrix'] ]
    pool:
      name: $(windowsX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/restore-working-directory.yml

    - script: tracer\build.cmd SetupExplorationTests --ExplorationTestUseCase $(explorationTestUseCase) --ExplorationTestName $(explorationTestName)
      displayName: SetupExplorationTest $(explorationTestUseCase) $(explorationTestName)

    - powershell: |
        dotnet build -c Release $(System.DefaultWorkingDirectory)\tracer\tools\MockAgent
        $serviceName = "MockAgent"
        $exePath = "$(System.DefaultWorkingDirectory)\tracer\tools\MockAgent\bin\release\net9.0\MockAgent.exe"

        # Check if service already exists
        if (Get-Service -Name $serviceName -ErrorAction SilentlyContinue) {
            Write-Host "Service $serviceName already exists. Stopping and removing..."
            Stop-Service -Name $serviceName -Force -ErrorAction SilentlyContinue
            sc.exe delete $serviceName | Out-Null
        }

        # Install the service
        sc.exe create $serviceName binPath= "`"$exePath`"" start= auto DisplayName= "Datadog Mock Agent"

        # Start the service
        Start-Service -Name $serviceName

        # Verify
        Get-Service -Name $serviceName
      displayName: Start Mock Agent

    - script: tracer\build.cmd RunExplorationTests --ExplorationTestUseCase $(explorationTestUseCase) --ExplorationTestName $(explorationTestName)
      displayName: RunExplorationTest $(explorationTestUseCase) $(explorationTestName)
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)

    - publish: artifacts/build_data
      displayName: Uploading exploration_tests_windows tracer logs
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - script: tracer\build.cmd CheckBuildLogsForErrors
      displayName: Check logs for errors

- stage: exploration_tests_linux
  condition: >
    and(
      succeeded(),
      or(
        eq(dependencies.generate_variables.outputs['generate_variables_job.generate_variables_step.IsTracerChanged'],'True'),
        eq(dependencies.generate_variables.outputs['generate_variables_job.generate_variables_step.IsProfilerChanged'], 'True'),
        eq(dependencies.generate_variables.outputs['generate_variables_job.generate_variables_step.IsDebuggerChanged'], 'True')
      )
    )
  dependsOn: [package_linux, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Test]

  - job: Test
    timeoutInMinutes: 60 #default value
    strategy:
      matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.exploration_tests_linux_matrix'] ]

    pool:
      name: $(linuxX64Pool)

    # Enable the Datadog Agent service for this job
    services:
      dd_agent: dd_agent_no_pull

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    # Doing a clean of obj files _before_ restore to remove build output from previous runs
    # Can't do a full clean, as otherwise restore-working-directory fails
    # Only necessary for ARM64, but shouldn't cause any harm on others
    # Can't ifdef it as depends on a matrix variable
    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: $(baseImage)
        command: "CleanObjFiles"

    - template: steps/restore-working-directory.yml
      parameters:
        artifact: build-$(artifactSuffix)-working-directory

    - template: steps/run-in-docker.yml
      parameters:
        build: false
        baseImage: $(baseImage)
        command: "SetupExplorationTests -ExplorationTestUseCase $(explorationTestUseCase) --explorationTestName $(explorationTestName) --framework $(publishTargetFramework)"
        apiKey: $(DD_LOGGER_DD_API_KEY)

    - script: |
        docker-compose -f docker-compose.yml -f docker-compose.ci.azdo.yml -p $(DockerComposeProjectName) \
          build \
          --build-arg baseImage=$(baseImage) \
          --build-arg explorationTestUseCase=$(explorationTestUseCase) \
          --build-arg explorationTestName=$(explorationTestName) \
          --build-arg framework=$(publishTargetFramework) \
          --build-arg CodeCoverageEnabled=$(CodeCoverageEnabled) \
          ExplorationTests
      displayName: docker-compose build ExplorationTests
      env:
        baseImage: $(baseImage) # for interpolation in the docker-compose file
        azdo_network: $(agent.containernetwork)
        DD_LOGGER_DD_API_KEY: $(ddApiKey)

    - script: |
        docker-compose -f docker-compose.yml -f docker-compose.ci.azdo.yml -p $(DockerComposeProjectName) \
          run --rm \
          -e DD_AGENT_HOST=dd_agent \
          -e baseImage=$(baseImage) \
          -e explorationTestUseCase=$(explorationTestUseCase) \
          -e explorationTestName=$(explorationTestName) \
          -e framework=$(publishTargetFramework) \
          -e CodeCoverageEnabled=$(CodeCoverageEnabled) \
          ExplorationTests
      displayName: docker-compose run ExplorationTests
      env:
        baseImage: $(baseImage) # for interpolation in the docker-compose file
        azdo_network: $(agent.containernetwork)
        DD_LOGGER_DD_API_KEY: $(ddApiKey)

    - script: docker-compose -f docker-compose.yml -f docker-compose.ci.azdo.yml -p $(DockerComposeProjectName) down
      env:
        baseImage: $(baseImage) # for interpolation in the docker-compose file
        azdo_network: $(agent.containernetwork)
      displayName: docker-compose stop services
      condition: succeededOrFailed()
      continueOnError: true

    - template: steps/make-artifacts-uploadable.yml
    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/run-in-docker.yml
      parameters:
        baseImage: $(baseImage)
        command: "CheckBuildLogsForErrors"

- stage: dotnet_tool
  dependsOn: [build_windows_tracer, build_windows_profiler, build_linux_tracer, build_linux_profiler, build_arm64_tracer, build_arm64_profiler, build_linux_universal, build_arm64_universal, build_macos, build_dd_dotnet_windows, build_dd_dotnet_linux, build_dd_dotnet_linux_arm64, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [build_runner_tool_and_standalone]

  - job: build_runner_tool_and_standalone
    timeoutInMinutes: 60 #default value

    pool:
      name: $(windowsX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    # download _everything_ not just the bin/obj/package files
    - template: steps/download-artifact.yml
      parameters:
        artifact: build-windows-working-directory
        path: $(System.DefaultWorkingDirectory)
        retryCountOnTaskFailure: 5

    # Download everything to monitoring home
    # BuildBundleNuget moves everything to the required folders
    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-tracer-home-linux-x64
        patterns: |
          **/*.so
          **/loader.conf
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-tracer-home-linux-musl-x64
        patterns: |
          **/*.so
          **/loader.conf
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-tracer-home-linux-arm64
        patterns: |
          **/*.so
          **/loader.conf
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-tracer-home-linux-musl-arm64
        patterns: |
          **/*.so
          **/loader.conf
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: macos-tracer-home
        patterns: |
          **/*.dylib
          **/loader.conf
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: windows-profiler-home
        patterns: "**/*.dll"
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-profiler-home-linux-x64
        patterns: |
          **/*.so
          **/loader.conf
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-profiler-home-linux-musl-x64
        patterns: |
          **/*.so
          **/loader.conf
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-profiler-home-linux-arm64
        patterns: |
          **/*.so
          **/loader.conf
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-profiler-home-linux-musl-arm64
        patterns: |
          **/*.so
          **/loader.conf
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: dd-dotnet-win-x64
        path: $(monitoringHome)/win-x64

    - template: steps/download-artifact.yml
      parameters:
        artifact: dd-dotnet-linux-x64
        path: $(monitoringHome)/linux-x64

    - template: steps/download-artifact.yml
      parameters:
        artifact: dd-dotnet-linux-musl-x64
        path: $(monitoringHome)/linux-musl-x64

    - template: steps/download-artifact.yml
      parameters:
        artifact: dd-dotnet-linux-arm64
        path: $(monitoringHome)/linux-arm64

    - template: steps/download-artifact.yml
      parameters:
        artifact: dd-dotnet-linux-musl-arm64
        path: $(monitoringHome)/linux-musl-arm64

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-universal-home-linux-x64
        path: $(monitoringHome)/linux-x64

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-universal-home-linux-x64
        path: $(monitoringHome)/linux-musl-x64

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-universal-home-linux-arm64
        path: $(monitoringHome)/linux-arm64

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-universal-home-linux-arm64
        path: $(monitoringHome)/linux-musl-arm64

    - script: tracer\build.cmd CreateBundleHome BuildBundleNuget BuildAzureFunctionsNuget BuildRunnerTool PackRunnerToolNuget BuildStandaloneTool BuildBenchmarkNuget
      displayName: Build tools and pack NuGet packages (Bundle, AzureFunctions, Benchmark)
      env:
        MSBUILDDISABLENODEREUSE: "1"

    - publish: $(artifacts)/nuget/bundle
      displayName: Uploading Datadog.Trace.Bundle package
      artifact: bundle-nuget-package

    - publish: $(artifacts)/nuget/azure-functions
      displayName: Uploading Datadog.AzureFunctions package
      artifact: azurefunctions-nuget-package

    - publish: $(artifacts)/nuget/benchmark
      displayName: Uploading Benchmark package
      artifact: benchmark-nuget-package

    - publish: $(artifacts)/nuget/dd-trace
      displayName: Uploading runner dotnet tool artifact
      artifact: runner-dotnet-tool

    - publish: $(artifacts)/dd-trace-win-x64.zip
      displayName: Uploading runner standalone win-x64 artifact
      artifact: runner-standalone-win-x64

    - publish: $(artifacts)/dd-trace-win-x86.zip
      displayName: Uploading runner standalone win-x86 artifact
      artifact: runner-standalone-win-x86

    - publish: $(artifacts)/dd-trace-linux-x64.tar.gz
      displayName: Uploading runner standalone linux-x64 artifact
      artifact: runner-standalone-linux-x64

    - publish: $(artifacts)/dd-trace-linux-musl-x64.tar.gz
      displayName: Uploading runner standalone linux-musl-x64 artifact
      artifact: runner-standalone-linux-musl-x64

    - publish: $(artifacts)/dd-trace-linux-arm64.tar.gz
      displayName: Uploading runner standalone linux-arm64 artifact
      artifact: runner-standalone-linux-arm64

    - publish: $(artifacts)/dd-trace-linux-musl-arm64.tar.gz
      displayName: Uploading runner standalone linux-musl-arm64 artifact
      artifact: runner-standalone-linux-musl-arm64

    - publish: $(artifacts)/dd-trace-osx-x64.tar.gz
      displayName: Uploading runner standalone osx-x64 artifact
      artifact: runner-standalone-osx-x64

    - powershell: |
        echo "##vso[build.addbuildtag]$(dotnetToolTag)"
      displayName: Add $(dotnetToolTag) build tag

- stage: tool_artifacts_tests_windows
  dependsOn: [dotnet_tool, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
    runnerTool: $(System.DefaultWorkingDirectory)/$(relativeRunnerTool)
    runnerStandalone: $(System.DefaultWorkingDirectory)/$(relativeRunnerStandalone)
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [test]

  - job: test
    timeoutInMinutes: 60 #default value
    strategy:
      matrix:
        windows-x86:
          targetPlatform: "x86"
        windows-x64:
          targetPlatform: "x64"

    pool:
      name: $(windowsX64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/restore-working-directory.yml

    - template: steps/download-artifact.yml
      parameters:
        artifact: windows-profiler-home
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: runner-dotnet-tool
        path: $(runnerTool)

    - template: steps/download-artifact.yml
      parameters:
        artifact: runner-standalone-win-$(targetPlatform)
        path: $(Agent.TempDirectory)/runner

    - template: steps/download-artifact.yml
      parameters:
        artifact: dd-dotnet-win-x64
        path: $(monitoringHome)/win-x64

    - task: ExtractFiles@1
      inputs:
        archiveFilePatterns: '$(Agent.TempDirectory)/runner/*.zip'
        destinationFolder: $(runnerStandalone)
        cleanDestinationFolder: false

    - script: tracer\build.cmd BuildAndRunToolArtifactTests --ToolSource $(runnerTool)
      displayName: Build and Test tool
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)

    - script: tracer\build.cmd RunToolArtifactTests --ToolDestination $(runnerStandalone)
      displayName: Test standalone
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)

    - script: tracer\build.cmd BuildAndRunDdDotnetArtifactTests --framework net48 --TargetPlatform $(targetPlatform)
      displayName: Build and Test dd-dotnet
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
        enable_crash_dumps: true

    - template: steps/make-artifacts-uploadable.yml
    - publish: artifacts/build_data
      displayName: Uploading tool_artifacts_tests_windows logs
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: artifacts/build_data/results/**/*.trx
      condition: succeededOrFailed()

- stage: tool_artifacts_tests_linux
  dependsOn: [dotnet_tool, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
    runnerTool: $(System.DefaultWorkingDirectory)/$(relativeRunnerTool)
    runnerStandalone: $(System.DefaultWorkingDirectory)/$(relativeRunnerStandalone)
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [test]

  - job: test
    timeoutInMinutes: 60 #default value
    strategy:
      matrix:
        x64:
          baseImage: debian
          artifactSuffix: linux-x64
          poolName: $(linuxX64Pool)
          targetArch: x64
        alpine_x64:
          baseImage: alpine
          artifactSuffix: linux-musl-x64
          poolName: $(linuxX64Pool)
          targetArch: x64
        arm64:
          baseImage: debian
          artifactSuffix: linux-arm64
          poolname: $(linuxArm64Pool)
          targetArch: arm64
        alpine_arm64:
          baseImage: alpine
          artifactSuffix: linux-musl-arm64
          poolname: $(linuxArm64Pool)
          targetArch: arm64

    pool:
      name: $(poolName)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/restore-working-directory.yml
      parameters:
        artifact: build-$(artifactSuffix)-working-directory

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-profiler-home-$(artifactSuffix)
        path: $(monitoringHome)

    - template: steps/download-artifact.yml
      parameters:
        artifact: runner-dotnet-tool
        path: $(runnerTool)

    - template: steps/download-artifact.yml
      parameters:
        artifact: runner-standalone-$(artifactSuffix)
        path: $(Agent.TempDirectory)/runner

    - template: steps/download-artifact.yml
      parameters:
        artifact: dd-dotnet-$(artifactSuffix)
        path: $(monitoringHome)/$(artifactSuffix)

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-universal-home-linux-$(targetArch)
        path: $(monitoringHome)/$(artifactSuffix)

    - task: ExtractFiles@1
      inputs:
        archiveFilePatterns: '$(Agent.TempDirectory)/runner/*.tar.gz'
        destinationFolder: $(runnerStandalone)
        cleanDestinationFolder: false

    - script: |
        ls $(runnerStandalone)
        chmod +x $(runnerStandalone)/dd-trace
      displayName: chmod dd-trace

    - script: |
        chmod +x $(monitoringHome)/$(artifactSuffix)/dd-dotnet
      displayName: chmod dd-dotnet

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: $(baseImage)
        command: "BuildAndRunToolArtifactTests --ToolSource /project/$(relativeRunnerTool)"

    - template: steps/run-in-docker.yml
      parameters:
        baseImage: $(baseImage)
        command: "RunToolArtifactTests --ToolDestination /project/$(relativeRunnerStandalone)"

    - template: steps/run-in-docker.yml
      parameters:
        baseImage: $(baseImage)
        command: "BuildAndRunDdDotnetArtifactTests --framework net7.0"

    - template: steps/make-artifacts-uploadable.yml
    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - task: PublishTestResults@2
      displayName: publish test results
      inputs:
        testResultsFormat: VSTest
        testResultsFiles: artifacts/build_data/results/**/*.trx
      condition: succeededOrFailed()

- stage: store_ssi_artifacts
  dependsOn: [package_linux, package_arm64, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
    - job: combine
      timeoutInMinutes: 60 #default value
      pool:
        vmImage: ubuntu-latest
      steps:
        - checkout: none
        # Linux packages
        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-packages-linux-musl-x64
            patterns: "*.tar.gz"
            path: $(Build.ArtifactStagingDirectory)

        - template: steps/download-artifact.yml
          parameters:
              artifact: linux-packages-linux-x64
              patterns: "*.tar.gz"
              path: $(Build.ArtifactStagingDirectory)

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-packages-linux-arm64
            patterns: "*.tar.gz"
            path: $(Build.ArtifactStagingDirectory)

        - bash: |
            TAR_NAME=$(basename $(Build.ArtifactStagingDirectory)/datadog-dotnet-apm-*.arm64.tar.gz)
            VERSION_NUMBER=${TAR_NAME:19:-13}
            echo "Detected version: $VERSION_NUMBER"
            echo "$VERSION_NUMBER" > $(Build.ArtifactStagingDirectory)/version.txt
          displayName: Write tracer version number to version.txt

        # publish all tar files as single artifact
        - publish: "$(Build.ArtifactStagingDirectory)"
          displayName: Publish ssi artifacts
          artifact: ssi-artifacts

- stage: store_serverless_artifacts
  dependsOn: [build_linux_tracer_r2r, build_arm64_tracer_r2r, build_linux_universal, build_arm64_universal]
  jobs:
    - job: combine
      timeoutInMinutes: 60 #default value
      pool:
        vmImage: ubuntu-latest
      steps:
        - checkout: none
        # Download the files to the expected locations
        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-tracer-home-linux-x64-r2r
            path: $(Build.ArtifactStagingDirectory)/x64

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-universal-home-linux-x64
            path: $(Build.ArtifactStagingDirectory)/x64

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-tracer-home-linux-arm64-r2r
            path: $(Build.ArtifactStagingDirectory)/arm64

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-universal-home-linux-arm64
            path: $(Build.ArtifactStagingDirectory)/arm64

        # publish all tar files as single artifact
        - publish: "$(Build.ArtifactStagingDirectory)"
          displayName: Publish serverless artifacts
          artifact: serverless-artifacts

- stage: upload_to_azure
  dependsOn: [package_windows, package_linux, package_arm64, dotnet_tool, merge_commit_id, store_serverless_artifacts]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
    - job: upload
      timeoutInMinutes: 60 #default value
      pool:
        vmImage: ubuntu-latest
      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - template: steps/download-artifact.yml
          parameters:
            artifact: nuget-packages
            path: $(Build.ArtifactStagingDirectory)

        # set the version from the package name
        - bash: |
            NUGET_NAME=$(basename $(Build.ArtifactStagingDirectory)/Datadog.Trace.OpenTracing.*.nupkg)
            VERSION_NUMBER=${NUGET_NAME:26:-6}
            echo "detected version: $VERSION_NUMBER"
            echo "##vso[task.setvariable variable=tracer_version]$VERSION_NUMBER"
          displayName: Extract version number

        # Linux packages
        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-packages-linux-musl-x64
            path: $(Build.ArtifactStagingDirectory)

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-packages-linux-x64
            path: $(Build.ArtifactStagingDirectory)

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-packages-linux-arm64
            path: $(Build.ArtifactStagingDirectory)

        # Linux symbols
        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-profiler-symbols-linux-musl-x64
            path: $(Build.ArtifactStagingDirectory)/symbols

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-profiler-symbols-linux-x64
            path: $(Build.ArtifactStagingDirectory)/symbols

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-profiler-symbols-linux-arm64
            path: $(Build.ArtifactStagingDirectory)/symbols

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-profiler-symbols-linux-musl-arm64
            path: $(Build.ArtifactStagingDirectory)/symbols

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-tracer-symbols-linux-musl-x64
            path: $(Build.ArtifactStagingDirectory)/symbols

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-tracer-symbols-linux-x64
            path: $(Build.ArtifactStagingDirectory)/symbols

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-tracer-symbols-linux-arm64
            path: $(Build.ArtifactStagingDirectory)/symbols

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-tracer-symbols-linux-musl-arm64
            path: $(Build.ArtifactStagingDirectory)/symbols

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-universal-symbols-linux-x64
            path: $(Build.ArtifactStagingDirectory)/symbols/linux-x64

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-universal-symbols-linux-x64
            path: $(Build.ArtifactStagingDirectory)/symbols/linux-musl-x64

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-universal-symbols-linux-arm64
            path: $(Build.ArtifactStagingDirectory)/symbols/linux-arm64

        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-universal-symbols-linux-arm64
            path: $(Build.ArtifactStagingDirectory)/symbols/linux-musl-arm64

        - template: steps/download-artifact.yml
          parameters:
            artifact: dd-dotnet-symbols-linux-x64
            path: $(Build.ArtifactStagingDirectory)/symbols/linux-x64

        - template: steps/download-artifact.yml
          parameters:
            artifact: dd-dotnet-symbols-linux-musl-x64
            path: $(Build.ArtifactStagingDirectory)/symbols/linux-musl-x64

        - template: steps/download-artifact.yml
          parameters:
            artifact: dd-dotnet-symbols-linux-arm64
            path: $(Build.ArtifactStagingDirectory)/symbols/linux-arm64

        - bash: |
            tar -zcf  $(Build.ArtifactStagingDirectory)/linux-native-symbols.tar.gz ./symbols
            rm -rf $(Build.ArtifactStagingDirectory)/symbols
          displayName: Tar native linux symbols
          failOnStderr: true
          workingDirectory: $(Build.ArtifactStagingDirectory)


        # NuGet
        - template: steps/download-artifact.yml
          parameters:
            artifact: bundle-nuget-package
            path: $(Build.ArtifactStagingDirectory)

        - template: steps/download-artifact.yml
          parameters:
            artifact: azurefunctions-nuget-package
            path: $(Build.ArtifactStagingDirectory)

#        Don't include the Datadog.Trace.BenchmarkDotNet package in the release artifacts
#        as it currently doesn't work with v3.
#        - task: DownloadPipelineArtifact@2
#          displayName: Download benchmark nuget package
#          inputs:
#            artifact: benchmark-nuget-package
#            path: $(Build.ArtifactStagingDirectory)

        # runner tool
        - template: steps/download-artifact.yml
          parameters:
            artifact: runner-dotnet-tool
            patterns: "*.nupkg"
            path: $(Build.ArtifactStagingDirectory)

        - template: steps/download-artifact.yml
          parameters:
            artifact: runner-standalone-win-x64
            patterns: "*.zip"
            path: $(Build.ArtifactStagingDirectory)

        - template: steps/download-artifact.yml
          parameters:
            artifact: runner-standalone-linux-x64
            patterns: "*.tar.gz"
            path: $(Build.ArtifactStagingDirectory)

        - template: steps/download-artifact.yml
          parameters:
            artifact: runner-standalone-linux-musl-x64
            patterns: "*.tar.gz"
            path: $(Build.ArtifactStagingDirectory)

        - template: steps/download-artifact.yml
          parameters:
            artifact: runner-standalone-linux-arm64
            patterns: "*.tar.gz"
            path: $(Build.ArtifactStagingDirectory)

        - template: steps/download-artifact.yml
          parameters:
            artifact: runner-standalone-linux-musl-arm64
            patterns: "*.tar.gz"
            path: $(Build.ArtifactStagingDirectory)

        # release artifacts
        - publish: "$(Build.ArtifactStagingDirectory)"
          displayName: Publish release artifacts
          artifact: $(tracer_version)-release-artifacts

        # We don't include the MSIs in the artifact upload as they're
        # not signed, and we use the windows-tracer-home.zip file from
        # GitLab so that it matches the native symbols file,
        # but we include them all in the push to Azure
        - template: steps/download-artifact.yml
          parameters:
            artifact: windows-tracer-home.zip
            path: $(Build.ArtifactStagingDirectory)

        - template: steps/download-artifact.yml
          parameters:
            artifact: windows-msi-x64
            path: $(Build.ArtifactStagingDirectory)

        # Download the artifacts required by the serverless layer and create the zip file
        # This expands the directory - but we want a zip file, so re-zip it!
        - template: steps/download-artifact.yml
          parameters:
            artifact: serverless-artifacts
            path: $(Agent.TempDirectory)/serverless-artifacts

        - bash: |
            cd $(Agent.TempDirectory)/serverless-artifacts
            zip -r $(Build.ArtifactStagingDirectory)/serverless-artifacts.zip .
          displayName: Zip serverless artifacts and store in staging directory

        - bash: |
            # Write tracer version number to version.txt
            echo "$(tracer_version)" > $(Build.ArtifactStagingDirectory)/version.txt

            # Write file list to index.txt
            ls "$(Build.ArtifactStagingDirectory)" > $(Build.ArtifactStagingDirectory)/index.txt
          displayName: Write description of assets

        - bash: |
            az storage blob upload-batch \
              --destination "$(AZURE_STORAGE_CONTAINER_NAME)" \
              --destination-path "$(Build.SourceVersion)" \
              --source "$(Build.ArtifactStagingDirectory)"
          displayName: Upload blobs to Azure
          condition: >
            and(
              succeeded(),
              ne(variables['push_artifacts_to_azure_storage'], 'false'),
              or(
                eq(variables['push_artifacts_to_azure_storage'], 'true'),
                eq(variables.isMainOrReleaseBranch, true)
              )
            )
          env:
            AZURE_STORAGE_ACCOUNT: $(AZURE_STORAGE_ACCOUNT_NAME)
            AZURE_STORAGE_SAS_TOKEN: $(AZURE_STORAGE_SHARED_ACCESS_TOKEN)

        - bash: ls "$(Build.ArtifactStagingDirectory)" > index.txt
          displayName: Write file list to index.txt

        - bash: echo "$(Build.SourceVersion)" > sha.txt
          displayName: Write commit hash to sha.txt

        - bash: echo "$(tracer_version)" > version.txt
          displayName: Write tracer version number to version.txt

        - bash: |
            az storage blob upload --container-name "$(AZURE_STORAGE_CONTAINER_NAME)" --file "index.txt" --name "index.txt" --overwrite true
            az storage blob upload --container-name "$(AZURE_STORAGE_CONTAINER_NAME)" --file "sha.txt" --name "sha.txt" --overwrite true
            az storage blob upload --container-name "$(AZURE_STORAGE_CONTAINER_NAME)" --file "version.txt" --name "version.txt" --overwrite true
          displayName: Upload indexes to Azure
          condition: and(succeeded(), eq(variables.isMainBranch, true))
          env:
            AZURE_STORAGE_ACCOUNT: $(AZURE_STORAGE_ACCOUNT_NAME)
            AZURE_STORAGE_SAS_TOKEN: $(AZURE_STORAGE_SHARED_ACCESS_TOKEN)

# Only run these on merges to master and PRs with the docker_image_artifacts label
- stage: upload_container_images
  condition: |
      or(
        and( succeeded()
          , eq( variables['Build.Reason'], 'IndividualCI')
          , eq( variables['isMainOrReleaseBranch'], true)
        ),
        and( in( dependencies.upload_to_azure.result, 'Succeeded')
          , eq( variables['Build.Reason'], 'PullRequest')
        )
      )
  dependsOn: [upload_to_azure]
  jobs:
    - job: upload
      timeoutInMinutes: 60 #default value
      pool:
        vmImage: ubuntu-latest
      steps:
      - checkout: none
      - template: steps/create-github-app-token.yml
      - bash: |
          REF=$(Build.SourceBranch)
          BRANCH_NAME="latest_snapshot"
          if [ "$(Build.Reason)" = "PullRequest" ]; then
            LABELS=$(curl -s -H "Authorization: token $GITHUB_TOKEN" \
            "https://api.github.com/repos/DataDog/dd-trace-dotnet/pulls/$(System.PullRequest.PullRequestNumber)" \
            | jq -r '.labels[].name')
          
            if echo "$LABELS" | grep -q "docker_image_artifacts"; then
              BRANCH_NAME="$(System.PullRequest.SourceBranch)"
              REF="refs/heads/$BRANCH_NAME"
            else
              echo "Label 'docker_image_artifacts' not found in PR — skipping Docker image build"
              exit 0
            fi
          fi

          echo "Creating dispatch event for https://github.com/DataDog/dd-trace-dotnet/actions/workflows/create-system-test-docker-base-images.yml with ref=$REF and azdo_build_id=$(Build.BuildId) and is_release_version=False"
          curl \
            -X POST \
            -H "Accept: application/vnd.github+json" \
            -H "Authorization: token $GITHUB_TOKEN"\
            -H "X-GitHub-Api-Version: 2022-11-28" \
            https://api.github.com/repos/DataDog/dd-trace-dotnet/actions/workflows/create-system-test-docker-base-images.yml/dispatches \
            -d "{\"ref\":\"$REF\",\"inputs\":{\"azdo_build_id\":\"$(Build.BuildId)\",\"branch_name\":\"$BRANCH_NAME\"}}"
        displayName: Start the generation of docker base images on GitHub Actions worfklow
        condition: |
          or(
            eq( variables['isMainBranch'], true ),
            eq( variables['Build.Reason'],  'PullRequest' )
          )
        env:
          GITHUB_TOKEN: $(retrieve_github_token.GITHUB_APP_TOKEN)

- stage: coverage
  condition: and(succeeded(), eq(variables['runCodeCoverage'], 'True'))
  dependsOn:
    - integration_tests_windows
    - integration_tests_windows_iis
    - integration_tests_azure_functions
    - msi_integration_tests_windows
    - integration_tests_linux
    - integration_tests_arm64
    - unit_tests_linux
    - unit_tests_macos
    - unit_tests_arm64
    - unit_tests_windows
    - merge_commit_id
    - tool_artifacts_tests_windows
    - tool_artifacts_tests_linux
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
    # Create this token on the linux side (create_github_token doesn't work on Windows currently)
    - job: create_github_token
      pool:
        vmImage: ubuntu-latest
      steps:
      - checkout: none
      - template: steps/create-github-app-token.yml

    - job: Windows
      dependsOn: create_github_token
      variables:
        GITHUB_APP_TOKEN: $[ dependencies.create_github_token.outputs['retrieve_github_token.GITHUB_APP_TOKEN'] ]  

      timeoutInMinutes: 30

      pool:
        vmImage: windows-2022

      steps:
      - template: steps/clone-repo.yml
        parameters:
          targetShaId: $(targetShaId)
          targetBranch: $(targetBranch)
      - template: steps/install-latest-dotnet-sdk.yml

      - template: steps/download-artifact.yml
        parameters:
          patterns: '**/coverage.cobertura.xml'
          path: $(Build.SourcesDirectory)/cover

      - task: reportgenerator@4
        inputs:
          reports: '$(Build.SourcesDirectory)\cover\**\coverage.cobertura.xml'
          targetdir: '$(Build.SourcesDirectory)\coveragereport'
          sourcedirs: '$(Build.SourcesDirectory);..'
          reporttypes: 'Cobertura'

      - task: PublishCodeCoverageResults@1
        inputs:
          codeCoverageTool: 'Cobertura'
          summaryFileLocation: '$(Build.SourcesDirectory)/coveragereport/Cobertura.xml'
          pathToSources: '$(Build.SourcesDirectory)'

      - script: tracer\build.cmd CompareCodeCoverageReports
        displayName: Compare code coverage
        condition: and(succeeded(), eq(variables.isPullRequest, true))
        env:
          PR_NUMBER: $(System.PullRequest.PullRequestNumber)
          AZURE_DEVOPS_TOKEN: $(AZURE_DEVOPS_TOKEN)
          GITHUB_TOKEN: $(GITHUB_APP_TOKEN)

- stage: execution_benchmarks
  dependsOn: [build_windows_tracer, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Windows, compare, create_github_token]

  - job: Windows
    strategy:
      matrix:
        HttpMessageHandler:
          sampleName: HttpMessageHandler
          poolName: ExecBenchAgent1
        FakeDbCommand:
          sampleName: FakeDbCommand
          poolName: ExecBenchAgent2
    pool:
      name: $(poolName)
    timeoutInMinutes: 30 #default value

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/install-latest-dotnet-sdk.yml
    - template: steps/restore-working-directory.yml

    - template: steps/download-artifact.yml
      parameters:
        artifact: windows-tracer-home
        path: $(monitoringHome)
        retryCountOnTaskFailure: 5

    - task: DotNetCoreCLI@2
      inputs:
        command: 'build'
        arguments: '-c Release'
        workingDirectory: $(System.DefaultWorkingDirectory)/tracer/test/test-applications/integrations/Samples.$(sampleName)
      displayName: 'dotnet build Release $(sampleName)'

    - script: run.cmd
      workingDirectory: $(System.DefaultWorkingDirectory)/tracer/build/timeit/Samples.$(sampleName)
      displayName: Execute Samples.$(sampleName) benchmark
      env:
        DD_SERVICE: dd-trace-dotnet
        DD_ENV: CI
        DOTNET_ROOT: $(LOCALAPPDATA)\Microsoft\dotnet
        DD_API_KEY: $(ddApiKey)
        DD_CIVISIBILITY_AGENTLESS_ENABLED: 1
        DD_CIVISIBILITY_LOGS_ENABLED: 0
        DD_CIVISIBILITY_ITR_ENABLED: 0

    - powershell: |
        mkdir -p $(System.DefaultWorkingDirectory)/artifacts/build_data/benchmarks
        cp $(System.DefaultWorkingDirectory)/tracer/build/timeit/Samples.$(sampleName)/results_*.json $(System.DefaultWorkingDirectory)/artifacts/build_data/benchmarks
      displayName: Copy the results to benchmarks dir
      condition: succeededOrFailed()
      continueOnError: true

    - publish: "$(System.DefaultWorkingDirectory)/artifacts/build_data/benchmarks"
      displayName: Publish results
      artifact: execution_time_benchmarks_windows_x64_$(sampleName)_$(System.JobAttempt)
      condition: succeededOrFailed()
      continueOnError: true

  # Create this token on the linux side (create_github_token doesn't work on Windows currently)
  - job: create_github_token
    pool:
      vmImage: ubuntu-latest
    steps:
    - checkout: none
    - template: steps/create-github-app-token.yml

  - job: compare
    timeoutInMinutes: 60 #default value
    dependsOn: [Windows, create_github_token]
    variables:
      GITHUB_APP_TOKEN: $[ dependencies.create_github_token.outputs['retrieve_github_token.GITHUB_APP_TOKEN'] ]
    pool:
      vmImage: windows-2022

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/install-latest-dotnet-sdk.yml

    - template: steps/download-artifact.yml
      parameters:
        artifact: execution_time_benchmarks_windows_x64_HttpMessageHandler_1 #only download the first lot, ignores retries
        path: $(System.DefaultWorkingDirectory)/artifacts/build_data/execution_benchmarks/current/execution_time_benchmarks_windows_x64_HttpMessageHandler_1

    - template: steps/download-artifact.yml
      parameters:
        artifact: execution_time_benchmarks_windows_x64_FakeDbCommand_1 #only download the first lot, ignores retries
        path: $(System.DefaultWorkingDirectory)/artifacts/build_data/execution_benchmarks/current/execution_time_benchmarks_windows_x64_FakeDbCommand_1

    - script: tracer\build.cmd CompareExecutionTimeBenchmarkResults
      displayName: Compare execution-time results
      env:
        PR_NUMBER: $(System.PullRequest.PullRequestNumber)
        AZURE_DEVOPS_TOKEN: $(AZURE_DEVOPS_TOKEN)
        GITHUB_TOKEN: $(GITHUB_APP_TOKEN)

    - publish: $(System.DefaultWorkingDirectory)/artifacts/build_data/execution_benchmarks/execution_time_report.md
      displayName: Upload report
      artifact: execution_time_report

- stage: profiler_execution_benchmarks
  dependsOn: [merge_commit_id, build_windows_profiler, build_linux_profiler]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [Windows]

  - job: Windows
    strategy:
      matrix:
        Cpu_Walltime:
          sampleName: Computer01
          testName: cpu-walltime
          poolName: ProfilerExecBenchAgent1
          framework: net7.0
        Exceptions:
          sampleName: ExceptionGenerator
          testName: exceptions
          poolName: ProfilerExecBenchAgent2
          framework: net7.0
        Contention:
          sampleName: Computer01
          testName: contention
          poolName: ProfilerExecBenchAgent3
          framework: net7.0
        Allocations:
          sampleName: Computer01
          testName: allocations
          poolName: ProfilerExecBenchAgent4
          framework: net7.0
        LiveHeap:
          sampleName: Computer01
          testName: liveheap
          poolName: ProfilerExecBenchAgent5
          framework: net7.0
        GarbageCollections:
          sampleName: Computer01
          testName: garbagecollections
          poolName: ProfilerExecBenchAgent11
          framework: net7.0
    pool:
      name: $(poolName)
    timeoutInMinutes: 30 #default value

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/install-latest-dotnet-sdk.yml
      parameters:
        includeX86: true

    - template: steps/download-artifact.yml
      parameters:
        artifact: windows-profiler-home
        path: $(monitoringHome)
        retryCountOnTaskFailure: 5

    - task: DotNetCoreCLI@2
      inputs:
        command: 'build'
        arguments: '-c Release -f $(framework) -p:Platform=x64 -p:CheckEolTargetFramework=false'
        workingDirectory: $(System.DefaultWorkingDirectory)/profiler/src/Demos/Samples.$(sampleName)
      displayName: 'dotnet build Release x64 $(sampleName)'

    - task: DotNetCoreCLI@2
      inputs:
        command: 'build'
        arguments: '-c Release -f $(framework) -p:Platform=x86 -p:CheckEolTargetFramework=false'
        workingDirectory: $(System.DefaultWorkingDirectory)/profiler/src/Demos/Samples.$(sampleName)
      displayName: 'dotnet build Release x86 $(sampleName)'

    - script: run-$(testName).cmd
      workingDirectory: $(System.DefaultWorkingDirectory)/profiler/build/
      displayName: Execute $(testName) benchmark
      env:
        DD_SERVICE: dd-trace-dotnet
        DD_ENV: CI
        DOTNET_ROOT: $(LOCALAPPDATA)\Microsoft\dotnet
        DD_API_KEY: $(ddApiKey)
        DD_CIVISIBILITY_AGENTLESS_ENABLED: 1
        DD_SITE: datadoghq.com
        DD_PROFILING_AGENTLESS: 1
        DD_CIVISIBILITY_LOGS_ENABLED: 0
        DD_CIVISIBILITY_ITR_ENABLED: 0

    - powershell: |
        mkdir -p $(System.DefaultWorkingDirectory)/profiler/build_data/benchmarks/$(testName)
        cp $(System.DefaultWorkingDirectory)/profiler/build/jsonexporter_*.json $(System.DefaultWorkingDirectory)/profiler/build_data/benchmarks/$(testName)
      displayName: Copy the results to benchmarks dir
      condition: succeededOrFailed()
      continueOnError: true

    - publish: "$(System.DefaultWorkingDirectory)/profiler/build_data/benchmarks"
      displayName: Publish results
      artifact: profiler_execution_time_benchmarks_windows_x64_$(testName)_$(System.JobAttempt)
      condition: succeededOrFailed()
      continueOnError: true

  - job: Linux
    strategy:
      matrix:
        Cpu_Walltime:
          sampleName: Computer01
          testName: cpu-walltime
          poolName: ProfilerExecBenchAgent6
          framework: net7.0
        Exceptions:
          sampleName: ExceptionGenerator
          testName: exceptions
          poolName: ProfilerExecBenchAgent7
          framework: net7.0
        Contention:
          sampleName: Computer01
          testName: contention
          poolName: ProfilerExecBenchAgent8
          framework: net7.0
        Allocations:
          sampleName: Computer01
          testName: allocations
          poolName: ProfilerExecBenchAgent9
          framework: net7.0
        LiveHeap:
          sampleName: Computer01
          testName: liveheap
          poolName: ProfilerExecBenchAgent10
          framework: net7.0
        GarbageCollections:
          sampleName: Computer01
          testName: garbagecollections
          poolName: ProfilerExecBenchAgent12
          framework: net7.0
    pool:
      name: $(poolName)
    timeoutInMinutes: 30 #default value

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/download-artifact.yml
      parameters:
        artifact: linux-profiler-home-linux-x64
        path: $(monitoringHome)
        retryCountOnTaskFailure: 5

    - task: DotNetCoreCLI@2
      inputs:
        command: 'build'
        arguments: '-c Release -f $(framework) -p:Platform=x64 -p:CheckEolTargetFramework=false'
        workingDirectory: $(System.DefaultWorkingDirectory)/profiler/src/Demos/Samples.$(sampleName)
      displayName: 'dotnet build Release x64 $(sampleName)'

    - script: ./run-$(testName).sh
      workingDirectory: $(System.DefaultWorkingDirectory)/profiler/build/
      displayName: Execute $(testName) benchmark
      env:
        DD_SERVICE: dd-trace-dotnet
        DD_ENV: CI
        DD_API_KEY: $(ddApiKey)
        DD_CIVISIBILITY_AGENTLESS_ENABLED: 1
        DD_SITE: datadoghq.com
        DD_PROFILING_AGENTLESS: 1
        DD_CIVISIBILITY_LOGS_ENABLED: 0
        DD_CIVISIBILITY_ITR_ENABLED: 0

    - script: |
        mkdir -p $(System.DefaultWorkingDirectory)/profiler/build_data/benchmarks/$(testName)
        cp $(System.DefaultWorkingDirectory)/profiler/build/jsonexporter_*.json $(System.DefaultWorkingDirectory)/profiler/build_data/benchmarks/$(testName)
      displayName: Copy the results to benchmarks dir
      condition: succeededOrFailed()
      continueOnError: true

    - publish: "$(System.DefaultWorkingDirectory)/profiler/build_data/benchmarks"
      displayName: Publish results
      artifact: profiler_execution_time_benchmarks_linux_x64_$(testName)_$(System.JobAttempt)
      condition: succeededOrFailed()
      continueOnError: true

  # - job: compare
  #   timeoutInMinutes: 60 #default value
  #   dependsOn: [Windows]
  #   pool:
  #     vmImage: windows-2022

  #   steps:
  #   - template: steps/clone-repo.yml
  #     parameters:
  #       targetShaId: $(targetShaId)
  #       targetBranch: $(targetBranch)

    # - template: steps/install-latest-dotnet-sdk.yml

    # - task: DownloadPipelineArtifact@2
    #   displayName: Download HttpMessageHandler
    #   inputs:
    #     artifact: profiler_execution_time_benchmarks_windows_x64_HttpMessageHandler_1 #only download the first lot, ignores retries
    #     path: $(System.DefaultWorkingDirectory)/artifacts/build_data/execution_benchmarks/current/execution_time_benchmarks_windows_x64_HttpMessageHandler_1

    # - task: DownloadPipelineArtifact@2
    #   displayName: Download FakeDbCommand
    #   inputs:
    #     artifact: execution_time_benchmarks_windows_x64_FakeDbCommand_1 #only download the first lot, ignores retries
    #     path: $(System.DefaultWorkingDirectory)/artifacts/build_data/execution_benchmarks/current/execution_time_benchmarks_windows_x64_FakeDbCommand_1

    # - script: tracer\build.cmd CompareExecutionTimeBenchmarkResults
    #   displayName: Compare execution-time results
    #   env:
    #     PR_NUMBER: $(System.PullRequest.PullRequestNumber)
    #     AZURE_DEVOPS_TOKEN: $(AZURE_DEVOPS_TOKEN)
    #     GITHUB_TOKEN: $(GITHUB_TOKEN)

    # - publish: $(System.DefaultWorkingDirectory)/artifacts/build_data/execution_benchmarks/execution_time_report.md
    #   displayName: Upload report
    #   artifact: execution_time_report

- stage: system_tests
  dependsOn: [package_linux, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
    scenarioGroups: "appsec,remote_config,telemetry,debugger,profiling,integrations, tracer_release"
    additionalScenarios: "DEFAULT,INTEGRATIONS_AWS,CROSSED_TRACING_LIBRARIES,TRACE_PROPAGATION_STYLE_W3C,LIBRARY_CONF_CUSTOM_HEADER_TAGS"
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [compute_scenarios, tests]
        
    - job: compute_scenarios
      timeoutInMinutes: 60
      displayName: Compute system-tests scenarios
      pool:
          vmImage: ubuntu-latest
          
      steps:
        - checkout: none
          
        - task: UsePythonVersion@0
          inputs:
            versionSpec: '3.12'
          displayName: Install python 3.12

        - script: git clone --depth 1 https://github.com/DataDog/system-tests.git
          displayName: Get system tests repo
          
        - script: |
            ./build.sh -i runner
          displayName: Install runner
          workingDirectory: system-tests
          
        - script: |
            set -e
            
            source venv/bin/activate
            # Try to get each workflow to take 15 mins = 900s
            PYTHONPATH=. python utils/scripts/compute-workflow-parameters.py dotnet -g "$(scenarioGroups)" -s "$(additionalScenarios)" -t 900 > out.txt

            endtoend_scenario_groups=$(grep 'endtoend_defs_parallel_jobs' out.txt | sed 's/.*=//g')
            endtoend_weblogs=$(grep 'endtoend_weblogs' out.txt | sed 's/.*=//g')

            echo "Found scenario groups: $endtoend_scenario_groups"
            echo "Found weblogs: $endtoend_weblogs"
            
            # Write the weblogs to a file (for later use to generate the docker images)
            python -c "import json; variants = json.loads('$endtoend_weblogs'); print('\n'.join(variants))" > /tmp/weblogs_list.txt
            # Generate matrix and write to file
            jq -c -n --argjson main "$endtoend_scenario_groups" --argjson webs "$endtoend_weblogs" '
              (
                $main | map({
                  ("GROUP (" + .weblog + ") " + (.weblog_instance|tostring)): {
                    SCENARIO: (.scenarios | join(",")), N: 1, I: 1,
                    WEBLOG_VARIANT: .weblog
                  }
                })
              ) + (
              [ range(1; 4) as $i |
                { ("PARAMETRIC \($i)"): {
                  SCENARIO: "PARAMETRIC", WEBLOG_VARIANT: $webs[0], N: 3, I: $i
                }}
              ]
              ) | add
            ' > matrix.json
            echo "##vso[task.setvariable variable=matrixJson;isOutput=true]$(cat matrix.json)"
            echo "Json: $(cat matrix.json)"
          displayName: Generate scenarios matrix JSON
          name: create_matrix
          workingDirectory: system-tests
          
        - template: steps/download-artifact.yml
          parameters:
            artifact: linux-packages-linux-x64
            patterns: '**/*tar.gz'
            path: $(Build.ArtifactStagingDirectory)

        - script: |
            PACKAGE_NAME=$(basename $(Build.ArtifactStagingDirectory)/datadog-dotnet-apm-*.tar.gz)
            echo Moving $PACKAGE_NAME to system-tests/binaries
            mv $(Build.ArtifactStagingDirectory)/$PACKAGE_NAME system-tests/binaries/
          displayName: Move dotnet binary to system test folder

        - script: |
            set -e
            cd system-tests
            mkdir -p ../docker-images
        
            while read w; do
              echo "------------------------------------"
              echo "Building images for variant: $w"
              echo "------------------------------------"
              # Build the images. For example:
              ./build.sh dotnet --weblog-variant $w
            
              # Save weblog variant image
              docker save system_tests/weblog:latest -o ../docker-images/$w.tar
            done < /tmp/weblogs_list.txt

          displayName: Build weblogs and agent & save Docker images

        - task: PublishPipelineArtifact@1
          displayName: Publish Docker images artifact
          # Ignore if we re-run the job and don't try to re-publish
          continueOnError: true
          inputs:
            path: 'docker-images'
            artifactName: 'system-test-docker-images'

    - job: tests
      displayName: ""
      timeoutInMinutes: 60
      pool:
          vmImage: ubuntu-latest
      dependsOn: compute_scenarios
     
      strategy:
        matrix: $[ dependencies.compute_scenarios.outputs['create_matrix.matrixJson'] ]

      steps:
      - checkout: none

      - task: UsePythonVersion@0
        inputs:
          versionSpec: '3.12'
        displayName: Install python 3.12

      - script: git clone --depth 1 https://github.com/DataDog/system-tests.git
        displayName: Get system tests repo
        
      - template: steps/download-artifact.yml
        parameters:
          artifact: system-test-docker-images
          path: $(Build.SourcesDirectory)

      - template: steps/download-artifact.yml
        parameters:
          artifact: linux-packages-linux-x64
          patterns: '**/*tar.gz'
          path: $(Build.ArtifactStagingDirectory)
          condition: eq(variables['SCENARIO'], 'PARAMETRIC')

      - script: |
          PACKAGE_NAME=$(basename $(Build.ArtifactStagingDirectory)/datadog-dotnet-apm-*.tar.gz)
          echo Moving $PACKAGE_NAME to system-tests/binaries
          mv $(Build.ArtifactStagingDirectory)/$PACKAGE_NAME system-tests/binaries/
        displayName: Move dotnet binary to system test folder
        condition: eq(variables['SCENARIO'], 'PARAMETRIC')

      - script: |
          echo "Loading images for variant: $(WEBLOG_VARIANT)"
          docker load -i "$(Build.SourcesDirectory)/$(WEBLOG_VARIANT).tar"
          
          echo "Available Docker images after loading:"
          docker images
        displayName: Docker load the correct variant

      - script: |
              ./build.sh -i runner
        displayName: Install runner
        workingDirectory: system-tests

      - script: |
          set -e

          source venv/bin/activate
          python utils/scripts/get-image-list.py "$(SCENARIO)" -l=dotnet -w=$(WEBLOG_VARIANT) > compose.yaml
          cat compose.yaml
        workingDirectory: system-tests
        displayName: Generate docker-compose file

      - script: docker compose pull
        workingDirectory: system-tests
        displayName: Pull docker images
        retryCountOnTaskFailure: 3

      - script: |
          # Replace ',' with ' +S ' and add initial +S prefix
          SCENARIOS=$(SCENARIO)
          SCENARIOS_TO_RUN="+S ${SCENARIOS//,/ +S }"
          ./run.sh $SCENARIOS_TO_RUN --splits=$(N) --group=$(I)
        workingDirectory: system-tests
        displayName: Run tests
        env:
          DD_API_KEY: 00000000000000000000000000000000 # Doesn't need to be a valid key (except for e2e, but they don't run here)
          TEST_LIBRARY: dotnet

      - script: |
          mkdir -p all_logs
          cp -r ./logs* ./all_logs
        workingDirectory: system-tests
        condition: always()
        displayName: Group logs

      - publish: system-tests/all_logs/
        condition: always()
        displayName: System tests logs
        artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)

- stage: installer_smoke_tests
  dependsOn: [package_linux, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [linux]

  - job: linux
    timeoutInMinutes: 45 # should take ~5 mins
    strategy:
      matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.installer_smoke_tests_matrix'] ]
    variables:
      smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
    pool:
      name: $(linuxX64SmokePool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)
    - template: steps/download-artifact.yml
      parameters:
        artifact: $(linuxArtifacts)
        path: $(smokeTestAppDir)/artifacts

    - script: |
        mkdir -p artifacts/build_data/snapshots
        mkdir -p artifacts/build_data/logs
      displayName: create test data directories

    # Run the "normal" installer smoke tests
    - script: |
        docker-compose -p $(DockerComposeProjectName) build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg INSTALL_CMD="$(installCmd)" \
          smoke-tests
      env:
        dockerTag: $(dockerTag)
        DD_LOGGER_DD_API_KEY: $(ddApiKey)
      displayName: docker-compose build smoke-tests
      retryCountOnTaskFailure: 3

    - template: steps/run-snapshot-test.yml
      parameters:
        target: 'smoke-tests'
        snapshotPrefix: "smoke_test"

    # Run the "dd-dotnet" installer smoke tests
    - script: |
        docker-compose -p $(DockerComposeProjectName) build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg INSTALL_CMD="$(installCmd)" \
          dd-dotnet-smoke-tests
      env:
        dockerTag: $(dockerTag)
      displayName: docker-compose build dd-dotnet-smoke-tests
      retryCountOnTaskFailure: 3

    - template: steps/run-snapshot-test.yml
      parameters:
        target: 'dd-dotnet-smoke-tests'
        snapshotPrefix: "smoke_test"
    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: alpine
        command: "CheckSmokeTestsForErrors ExtractMetricsFromLogs"
        apikey: $(DD_LOGGER_DD_API_KEY)

- stage: installer_chiseled_smoke_tests
  dependsOn: [package_linux, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [linux]

    - job: linux
      timeoutInMinutes: 45 # should take ~5 mins
      strategy:
        matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.installer_chiseled_smoke_tests_matrix'] ]
      variables:
        smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
      pool:
        name: $(linuxX64SmokePool)
      
      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - template: steps/download-artifact.yml
          parameters:
            artifact: $(linuxArtifacts)
            path: $(smokeTestAppDir)/artifacts

        # Run the "normal" installer smoke tests
        - script: |
            docker-compose -p $(DockerComposeProjectName) build \
              --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
              --build-arg RUNTIME_IMAGE=$(runtimeImage) \
              --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
              chiseled-smoke-tests
          env:
            dockerTag: $(dockerTag)
            DD_LOGGER_DD_API_KEY: $(ddApiKey)
          displayName: docker-compose build chiseled-smoke-tests
          retryCountOnTaskFailure: 3

        - template: steps/run-snapshot-test.yml
          parameters:
            target: 'chiseled-smoke-tests'
            snapshotPrefix: "smoke_test"
        
        # Run the "dd-dotnet" installer smoke tests
        - script: |
            docker-compose -p $(DockerComposeProjectName) build \
              --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
              --build-arg RUNTIME_IMAGE=$(runtimeImage) \
              --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
              --build-arg RUNTIME_ID="$(runtimeId)" \
              dd-dotnet-chiseled-smoke-tests
          env:
            dockerTag: $(dockerTag)
            dockerTarget: $(runtimeId)
          displayName: docker-compose build dd-dotnet-chiseled-smoke-tests
          retryCountOnTaskFailure: 3

        - template: steps/run-snapshot-test.yml
          parameters:
            target: 'dd-dotnet-chiseled-smoke-tests'
            snapshotPrefix: "smoke_test"

        - publish: artifacts/build_data
          artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
          condition: always()
          continueOnError: true

        - template: steps/run-in-docker.yml
          parameters:
            build: true
            baseImage: alpine
            command: "CheckSmokeTestsForErrors ExtractMetricsFromLogs"

- stage: nuget_installer_smoke_tests
  condition: and(succeeded(), or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.run_all_installer_tests, 'true')))
  dependsOn: [dotnet_tool, package_windows, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [linux]

  - job: linux
    timeoutInMinutes: 45 # should take ~5 mins
    strategy:
      matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.nuget_installer_linux_smoke_tests_matrix'] ]
    variables:
      smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
    pool:
      name: $(linuxX64SmokePool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/download-artifact.yml
      parameters:
        artifact: bundle-nuget-package
        path: $(smokeTestAppDir)/artifacts

    - template: steps/download-artifact.yml
      parameters:
        artifact: nuget-packages
        path: $(smokeTestAppDir)/artifacts

    - script: |
        mkdir -p artifacts/build_data/snapshots
        mkdir -p artifacts/build_data/logs
      displayName: create test data directories

    - script: |
        docker-compose -p $(DockerComposeProjectName) build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg TOOL_VERSION=$(ToolVersion) \
          --build-arg RELATIVE_PROFILER_PATH="$(relativeProfilerPath)" \
          --build-arg RELATIVE_APIWRAPPER_PATH="$(relativeApiWrapperPath)" \
          nuget-smoke-tests
      env:
        dockerTag: $(dockerTag)
      displayName: docker-compose build nuget-smoke-tests
      retryCountOnTaskFailure: 3

    - template: steps/run-snapshot-test.yml
      parameters:
        target: 'nuget-smoke-tests'
        snapshotPrefix: "smoke_test"

    - script: |
        docker-compose -p $(DockerComposeProjectName) build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg TOOL_VERSION=$(ToolVersion) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg RELATIVE_PROFILER_PATH="$(relativeProfilerPath)" \
          --build-arg RELATIVE_APIWRAPPER_PATH="$(relativeApiWrapperPath)" \
          nuget-dddotnet-smoke-tests
      env:
        dockerTag: $(dockerTag)
      displayName: docker-compose build nuget-dddotnet-smoke-tests
      retryCountOnTaskFailure: 3

    - template: steps/run-snapshot-test.yml
      parameters:
        target: 'nuget-dddotnet-smoke-tests'
        snapshotPrefix: "smoke_test"

    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: alpine
        command: "CheckSmokeTestsForErrors ExtractMetricsFromLogs"

- stage: trimmed_installer_smoke_tests
  dependsOn: [package_windows, package_linux, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [linux]

    - job: linux
      timeoutInMinutes: 45 # should take ~5 mins
      strategy:
        matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.trimming_installer_linux_smoke_tests_matrix'] ]
      variables:
        smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
      pool:
        name: $(linuxX64SmokePool)

      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - template: steps/download-artifact.yml
          parameters:
            artifact: $(linuxArtifacts)
            path: $(smokeTestAppDir)/artifacts

        - template: steps/download-artifact.yml
          parameters:
            artifact: nuget-packages
            itemPattern: "$(packageName).$(ToolVersion)$(packageVersionSuffix).nupkg"
            path: $(smokeTestAppDir)/artifacts

        - script: |
            mkdir -p artifacts/build_data/snapshots
            mkdir -p artifacts/build_data/logs
          displayName: create test data directories

        - script: |
            docker-compose -p $(DockerComposeProjectName) build \
              --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
              --build-arg RUNTIME_IMAGE=$(runtimeImage) \
              --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
              --build-arg INSTALL_CMD="$(installCmd)" \
              --build-arg PACKAGE_NAME=$(packageName) \
              --build-arg RUNTIME_IDENTIFIER=$(runtimeId) \
              --build-arg TOOL_VERSION=$(ToolVersion)$(packageVersionSuffix) \
              trimming-smoke-tests
          env:
            dockerTag: $(dockerTag)
          displayName: docker-compose build trimming-smoke-tests
          retryCountOnTaskFailure: 3

        - template: steps/run-snapshot-test.yml
          parameters:
            target: 'trimming-smoke-tests'
            snapshotPrefix: "smoke_test"

        - publish: artifacts/build_data
          artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
          condition: always()
          continueOnError: true

        - template: steps/run-in-docker.yml
          parameters:
            build: true
            baseImage: alpine
            command: "CheckSmokeTestsForErrors ExtractMetricsFromLogs"

- stage: dotnet_tool_nuget_smoke_tests_linux
  condition: and(succeeded(), or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.run_all_installer_tests, 'true')))
  dependsOn: [dotnet_tool, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [linux]

  - job: linux
    timeoutInMinutes: 45 # should take ~5 mins
    strategy:
      matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.dotnet_tool_nuget_installer_linux_smoke_tests_matrix'] ]
    variables:
      smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
    pool:
      name: $(linuxX64SmokePool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/download-artifact.yml
      parameters:
        artifact: runner-dotnet-tool
        path: $(smokeTestAppDir)/artifacts

    - script: |
        mkdir -p artifacts/build_data/snapshots
        mkdir -p artifacts/build_data/logs
      displayName: create test data directories

    - script: |
        docker-compose -p $(DockerComposeProjectName) build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg TOOL_VERSION=$(ToolVersion) \
          dotnet-tool-nuget-smoke-tests
      env:
        dockerTag: $(dockerTag)
      displayName: docker-compose build  dotnet-tool-nuget-smoke-tests
      retryCountOnTaskFailure: 3

    - template: steps/run-snapshot-test.yml
      parameters:
        target: 'dotnet-tool-nuget-smoke-tests'
        snapshotPrefix: "smoke_test"

    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: alpine
        command: "CheckSmokeTestsForErrors ExtractMetricsFromLogs"

- stage: dotnet_tool_smoke_tests_linux
  condition: and(succeeded(), or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.run_all_installer_tests, 'true')))
  dependsOn: [dotnet_tool, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [linux]

  - job: linux
    timeoutInMinutes: 45 # should take ~5 mins
    strategy:
      matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.dotnet_tool_installer_linux_smoke_tests_matrix'] ]
    variables:
      smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
    pool:
      name: $(linuxX64SmokePool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/download-artifact.yml
      parameters:
        artifact: runner-standalone-$(platformSuffix)
        patterns: "*.tar.gz"
        path: $(Agent.TempDirectory)

    - script: |
        mkdir -p artifacts/build_data/snapshots
        mkdir -p artifacts/build_data/logs
        mkdir -p $(smokeTestAppDir)/artifacts
        tar -xf $(Agent.TempDirectory)/dd-trace-$(platformSuffix).tar.gz -C $(smokeTestAppDir)/artifacts
        chmod +x $(smokeTestAppDir)/artifacts/dd-trace
      displayName: create test data directories and extract tool

    - script: |
        docker-compose -p $(DockerComposeProjectName) build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg TOOL_VERSION=$(ToolVersion) \
          dotnet-tool-smoke-tests
      env:
        dockerTag: $(dockerTag)
      displayName: docker-compose build smoke-tests
      retryCountOnTaskFailure: 3

    - template: steps/run-snapshot-test.yml
      parameters:
        target: 'dotnet-tool-smoke-tests'
        snapshotPrefix: "smoke_test"

    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: alpine
        command: "CheckSmokeTestsForErrors ExtractMetricsFromLogs"

- stage: dotnet_tool_self_instrument_smoke_tests_linux
  condition: and(succeeded(), or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.run_all_installer_tests, 'true')))
  dependsOn: [dotnet_tool, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [linux]

  - job: linux
    timeoutInMinutes: 45 # should take ~5 mins
    variables:
      smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
      publishFramework: net6.0
      platformSuffix: linux-x64
      dockerTag: debian_net6
      runtimeImage: "mcr.microsoft.com/dotnet/aspnet:6.0-bullseye-slim"
      installCmd: "dpkg -i ./datadog-dotnet-apm*_amd64.deb"
      linuxArtifacts: "linux-packages-linux-x64"
    pool:
      name: $(linuxX64SmokePool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/download-artifact.yml
      parameters:
        artifact: $(linuxArtifacts)
        path: $(smokeTestAppDir)/artifacts

    - template: steps/download-artifact.yml
      parameters:
        artifact: runner-standalone-$(platformSuffix)
        patterns: "*.tar.gz"
        path: $(Agent.TempDirectory)

    - script: |
        mkdir -p artifacts/build_data/snapshots
        mkdir -p artifacts/build_data/logs
        tar -xf $(Agent.TempDirectory)/dd-trace-$(platformSuffix).tar.gz -C $(smokeTestAppDir)/artifacts
        chmod +x $(smokeTestAppDir)/artifacts/dd-trace
      displayName: create test data directories and extract tool

    - script: |
        docker-compose -p $(DockerComposeProjectName) build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg TOOL_VERSION=$(ToolVersion) \
          --build-arg INSTALL_CMD="$(installCmd)" \
          dotnet-tool-self-instrument-smoke-tests
      env:
        dockerTag: $(dockerTag)
      displayName: docker-compose build dotnet-tool-self-instrument-smoke-tests
      retryCountOnTaskFailure: 3

    - template: steps/run-snapshot-test.yml
      parameters:
        target: 'dotnet-tool-self-instrument-smoke-tests'
        snapshotPrefix: "smoke_test"

    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: alpine
        command: "CheckSmokeTestsForErrors ExtractMetricsFromLogs"

- stage: installer_smoke_tests_arm64
  dependsOn: [package_arm64, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [linux]

    - job: linux
      timeoutInMinutes: 45 # should take ~15 mins
      strategy:
        matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.installer_smoke_tests_arm64_matrix'] ]
      variables:
        smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
      pool:
        name: $(linuxArm64Pool)

      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - template: steps/download-artifact.yml
          parameters:
            artifact: $(linuxArtifacts)
            path: $(smokeTestAppDir)/artifacts

        - script: |
            mkdir -p artifacts/build_data/snapshots
            mkdir -p artifacts/build_data/logs
          displayName: create test data directories

        # Run the "normal" installer smoke tests 
        - script: |
            docker-compose -p $(DockerComposeProjectName) build \
              --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
              --build-arg RUNTIME_IMAGE=$(runtimeImage) \
              --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
              --build-arg INSTALL_CMD="$(installCmd)" \
              smoke-tests
          env:
            dockerTag: $(dockerTag)
          displayName: docker-compose build smoke-tests
          retryCountOnTaskFailure: 3

        - template: steps/run-snapshot-test.yml
          parameters:
            target: 'smoke-tests'
            snapshotPrefix: "smoke_test"

        # Run the "dd-dotnet" installer smoke tests
        - script: |
            docker-compose -p $(DockerComposeProjectName) build \
              --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
              --build-arg RUNTIME_IMAGE=$(runtimeImage) \
              --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
              --build-arg INSTALL_CMD="$(installCmd)" \
              dd-dotnet-smoke-tests
          env:
            dockerTag: $(dockerTag)
          displayName: docker-compose build dd-dotnet-smoke-tests
          retryCountOnTaskFailure: 3

        - template: steps/run-snapshot-test.yml
          parameters:
            target: 'dd-dotnet-smoke-tests'
            snapshotPrefix: "smoke_test"

        - publish: artifacts/build_data
          artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
          condition: always()
          continueOnError: true

        - template: steps/run-in-docker.yml
          parameters:
            build: true
            baseImage: alpine
            command: "CheckSmokeTestsForErrors ExtractMetricsFromLogs"

- stage: installer_chiseled_smoke_tests_arm64
  condition: and(succeeded(), or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.run_all_installer_tests, 'true')))
  dependsOn: [package_arm64, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [linux]

    - job: linux
      timeoutInMinutes: 45 # should take ~15 mins
      strategy:
        matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.installer_chiseled_smoke_tests_arm64_matrix'] ]
      variables:
        smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
      pool:
        name: $(linuxArm64Pool)

      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - template: steps/download-artifact.yml
          parameters:
            artifact: $(linuxArtifacts)
            path: $(smokeTestAppDir)/artifacts

        # Run the "normal" installer smoke tests 
        - script: |
            docker-compose -p $(DockerComposeProjectName) build \
              --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
              --build-arg RUNTIME_IMAGE=$(runtimeImage) \
              --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
              chiseled-smoke-tests
          env:
            dockerTag: $(dockerTag)
            DD_LOGGER_DD_API_KEY: $(ddApiKey)
          displayName: docker-compose build chiseled-smoke-tests
          retryCountOnTaskFailure: 3

        - template: steps/run-snapshot-test.yml
          parameters:
            target: 'chiseled-smoke-tests'
            snapshotPrefix: "smoke_test"
        
        # Run the "dd-dotnet" installer smoke tests
        - script: |
            docker-compose -p $(DockerComposeProjectName) build \
              --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
              --build-arg RUNTIME_IMAGE=$(runtimeImage) \
              --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
              --build-arg RUNTIME_ID="$(runtimeId)" \
              dd-dotnet-chiseled-arm64-smoke-tests
          env:
            dockerTag: $(dockerTag)
            dockerTarget: $(runtimeId)
          displayName: docker-compose build dd-dotnet-chiseled-arm64-smoke-tests
          retryCountOnTaskFailure: 3

        - template: steps/run-snapshot-test.yml
          parameters:
            target: 'dd-dotnet-chiseled-arm64-smoke-tests'
            snapshotPrefix: "smoke_test"

        - publish: artifacts/build_data
          artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
          condition: always()
          continueOnError: true

        - template: steps/run-in-docker.yml
          parameters:
            build: true
            baseImage: alpine
            command: "CheckSmokeTestsForErrors ExtractMetricsFromLogs"

- stage: nuget_installer_smoke_tests_arm64
  condition: and(succeeded(), or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.run_all_installer_tests, 'true')))
  dependsOn: [dotnet_tool, package_windows, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [linux]

  - job: linux
    timeoutInMinutes: 45 # should take ~15 mins
    strategy:
      matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.nuget_installer_linux_smoke_tests_arm64_matrix'] ]
    variables:
      smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
    pool:
      name: $(linuxArm64Pool)

    steps:
    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/download-artifact.yml
      parameters:
        artifact: bundle-nuget-package
        path: $(smokeTestAppDir)/artifacts

    - template: steps/download-artifact.yml
      parameters:
        artifact: nuget-packages
        path: $(smokeTestAppDir)/artifacts

    - script: |
        mkdir -p artifacts/build_data/snapshots
        mkdir -p artifacts/build_data/logs
      displayName: create test data directories

    - script: |
        docker-compose -p $(DockerComposeProjectName) build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg TOOL_VERSION=$(ToolVersion) \
          --build-arg RELATIVE_PROFILER_PATH="$(relativeProfilerPath)" \
          --build-arg RELATIVE_APIWRAPPER_PATH="$(relativeApiWrapperPath)" \
          nuget-smoke-tests
      env:
        dockerTag: $(dockerTag)
      displayName: docker-compose build nuget-smoke-tests
      retryCountOnTaskFailure: 3

    - template: steps/run-snapshot-test.yml
      parameters:
        target: 'nuget-smoke-tests'
        snapshotPrefix: "smoke_test"

    - script: |
        docker-compose -p $(DockerComposeProjectName) build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg TOOL_VERSION=$(ToolVersion) \
          --build-arg RELATIVE_PROFILER_PATH="$(relativeProfilerPath)" \
          --build-arg RELATIVE_APIWRAPPER_PATH="$(relativeApiWrapperPath)" \
          nuget-dddotnet-smoke-tests
      env:
        dockerTag: $(dockerTag)
      displayName: docker-compose build smoke-tests dd-dotnet
      retryCountOnTaskFailure: 3

    - template: steps/run-snapshot-test.yml
      parameters:
        target: 'nuget-dddotnet-smoke-tests'
        snapshotPrefix: "smoke_test"

    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: alpine
        command: "CheckSmokeTestsForErrors ExtractMetricsFromLogs"

- stage: dotnet_tool_smoke_tests_arm64
  condition: and(succeeded(), or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.run_all_installer_tests, 'true')))
  dependsOn: [dotnet_tool, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [linux]

  - job: linux
    timeoutInMinutes: 45 # should take ~15 mins
    strategy:
      matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.dotnet_tool_installer_smoke_tests_arm64_matrix'] ]
    variables:
      smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
    pool:
      name: $(linuxArm64Pool)

    steps:
    - template: steps/download-artifact.yml
      parameters:
        artifact: runner-standalone-$(platformSuffix)
        patterns: "*.tar.gz"
        path: $(Agent.TempDirectory)

    - script: |
        mkdir -p artifacts/build_data/snapshots
        mkdir -p artifacts/build_data/logs
        mkdir -p $(smokeTestAppDir)/artifacts
        tar -xf $(Agent.TempDirectory)/dd-trace-$(platformSuffix).tar.gz -C $(smokeTestAppDir)/artifacts
        chmod +x $(smokeTestAppDir)/artifacts/dd-trace
      displayName: create test data directories and extract tool

    - script: |
        docker-compose -p $(DockerComposeProjectName) build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg TOOL_VERSION=$(ToolVersion) \
          dotnet-tool-smoke-tests
      env:
        dockerTag: $(dockerTag)
      displayName: docker-compose build smoke-tests
      retryCountOnTaskFailure: 3

    - template: steps/run-snapshot-test.yml
      parameters:
        target: 'dotnet-tool-smoke-tests'
        snapshotPrefix: "smoke_test"

    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/run-in-docker.yml
      parameters:
        build: true
        baseImage: alpine
        command: "CheckSmokeTestsForErrors ExtractMetricsFromLogs"

- stage: nuget_installer_smoke_tests_windows
  condition: and(succeeded(), or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.run_all_installer_tests, 'true')))
  dependsOn: [dotnet_tool, package_windows, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
    dockerComposePath: 'C:/docker-compose/docker-compose.exe'
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [windows]

  - job: windows
    timeoutInMinutes: 45 # should take ~15 mins as large Windows docker files
    strategy:
      matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.nuget_installer_windows_smoke_tests_matrix'] ]
    variables:
      smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
    pool:
      vmImage: windows-2022

    steps:
    - template: steps/install-docker-compose-v1.yml
      parameters:
        dockerComposePath: $(dockerComposePath)

    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/download-artifact.yml
      parameters:
        artifact: bundle-nuget-package
        path: $(smokeTestAppDir)/artifacts

    - template: steps/download-artifact.yml
      parameters:
        artifact: nuget-packages
        path: $(smokeTestAppDir)/artifacts

    - powershell: |
        mkdir -p artifacts/build_data/snapshots
        mkdir -p artifacts/build_data/logs
      displayName: create test data directories

    - bash: |
        $(dockerComposePath) -f docker-compose.windows.yml -p $(DockerComposeProjectName) build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg TOOL_VERSION=$(ToolVersion) \
          --build-arg CHANNEL_32_BIT="$(channel32Bit)" \
          --build-arg RELATIVE_PROFILER_PATH="$(relativeProfilerPath)" \
          nuget-smoke-tests.windows
      env:
        dockerTag: $(dockerTag)
      displayName: docker-compose build smoke-tests
      retryCountOnTaskFailure: 3

    - template: steps/run-snapshot-test.yml
      parameters:
        target: 'nuget-smoke-tests.windows'
        snapshotPrefix: "smoke_test"
        isLinux: false
        dockerComposePath: $(dockerComposePath)

    - bash: |
        $(dockerComposePath) -f docker-compose.windows.yml -p $(DockerComposeProjectName) build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg TOOL_VERSION=$(ToolVersion) \
          --build-arg CHANNEL_32_BIT="$(channel32Bit)" \
          --build-arg RELATIVE_PROFILER_PATH="$(relativeProfilerPath)" \
          nuget-dddotnet-smoke-tests.windows
      env:
        dockerTag: $(dockerTag)
      displayName: docker-compose build smoke-tests dd-dotnet
      retryCountOnTaskFailure: 3

    - template: steps/run-snapshot-test.yml
      parameters:
        target: 'nuget-dddotnet-smoke-tests.windows'
        snapshotPrefix: "smoke_test"
        isLinux: false
        dockerComposePath: $(dockerComposePath)

    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/install-latest-dotnet-sdk.yml
    - script: tracer\build.cmd CheckSmokeTestsForErrors ExtractMetricsFromLogs
      displayName: CheckSmokeTestsForErrors ExtractMetricsFromLogs
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)

- stage: dotnet_tool_smoke_tests_windows
  condition: and(succeeded(), or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.run_all_installer_tests, 'true')))
  dependsOn: [dotnet_tool, package_windows, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
    dockerComposePath: 'C:/docker-compose/docker-compose.exe'
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [windows]

  - job: windows
    timeoutInMinutes: 45 # should take ~15 mins as large Windows docker files
    strategy:
      matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.dotnet_tool_installer_windows_smoke_tests_matrix'] ]
    variables:
      smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
    pool:
      vmImage: windows-2022

    steps:
    - template: steps/install-docker-compose-v1.yml
      parameters:
        dockerComposePath: $(dockerComposePath)

    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/download-artifact.yml
      parameters:
        artifact: runner-standalone-win-x64
        patterns: "dd-trace-win-x64.zip"
        path: $(Agent.TempDirectory)

    - powershell: |
        mkdir -f -p artifacts/build_data/snapshots
        mkdir -f -p artifacts/build_data/logs
        mkdir -f -p $(smokeTestAppDir)/artifacts
        mv $(Agent.TempDirectory)/*.zip $(smokeTestAppDir)/artifacts/dd-trace-win.zip
      displayName: Create test data directories

    - bash: |
        $(dockerComposePath) -f docker-compose.windows.yml -p $(DockerComposeProjectName) build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg TOOL_VERSION=$(ToolVersion) \
          --build-arg CHANNEL_32_BIT="$(channel32Bit)" \
          dotnet-tool-smoke-tests.windows
      env:
        dockerTag: $(dockerTag)
      displayName: docker-compose build smoke-tests
      retryCountOnTaskFailure: 3

    - template: steps/run-snapshot-test.yml
      parameters:
        target: 'dotnet-tool-smoke-tests.windows'
        snapshotPrefix: "smoke_test"
        isLinux: false
        dockerComposePath: $(dockerComposePath)

    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/install-latest-dotnet-sdk.yml
    - script: tracer\build.cmd CheckSmokeTestsForErrors ExtractMetricsFromLogs
      displayName: CheckSmokeTestsForErrors ExtractMetricsFromLogs
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)

- stage: msi_installer_smoke_tests
  condition: and(succeeded(), or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.run_all_installer_tests, 'true')))
  dependsOn: [package_windows, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
    dockerComposePath: 'C:/docker-compose/docker-compose.exe'
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [windows]

  - job: windows
    timeoutInMinutes: 45 # should take ~15 mins as large Windows docker files
    strategy:
      matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.msi_installer_windows_smoke_tests_matrix'] ]
    variables:
      smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
    pool:
      vmImage: windows-2022

    steps:
    - template: steps/install-docker-compose-v1.yml
      parameters:
        dockerComposePath: $(dockerComposePath)

    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - template: steps/download-artifact.yml
      parameters:
        artifact: windows-msi-$(targetPlatform)
        patterns: '**/*-$(targetPlatform).msi'
        path: $(Agent.TempDirectory)

    - powershell: |
        mkdir -p artifacts/build_data/snapshots
        mkdir -p artifacts/build_data/logs
        mkdir -p $(smokeTestAppDir)/artifacts
        mv $(Agent.TempDirectory)/*.msi $(smokeTestAppDir)/artifacts/datadog-apm.msi
      displayName: Create test data directories

    - bash: |
        $(dockerComposePath) -f docker-compose.windows.yml -p $(DockerComposeProjectName) build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg CHANNEL_32_BIT="$(channel32Bit)" \
          smoke-tests.windows
      env:
        dockerTag: $(dockerTag)
      displayName: docker-compose build smoke-tests
      retryCountOnTaskFailure: 3

    - template: steps/run-snapshot-test.yml
      parameters:
        target: 'smoke-tests.windows'
        snapshotPrefix: "smoke_test"
        isLinux: false
        dockerComposePath: $(dockerComposePath)

    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/install-latest-dotnet-sdk.yml
    - script: tracer\build.cmd CheckSmokeTestsForErrors ExtractMetricsFromLogs
      displayName: CheckSmokeTestsForErrors ExtractMetricsFromLogs
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)

- stage: dd_dotnet_msi_installer_smoke_tests
  condition: and(succeeded(), or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.run_all_installer_tests, 'true')))
  dependsOn: [package_windows, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
    dockerComposePath: 'C:/docker-compose/docker-compose.exe'
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [windows]

    - job: windows
      timeoutInMinutes: 45 # should take ~15 mins as large Windows docker files
      strategy:
        # Uses the same matrix as msi_installer_smoke_tests
        matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.msi_installer_windows_smoke_tests_matrix'] ]
      variables:
        smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
      pool:
        vmImage: windows-2022
      
      steps:
        - template: steps/install-docker-compose-v1.yml
          parameters:
            dockerComposePath: $(dockerComposePath)

        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - template: steps/download-artifact.yml
          parameters:
            artifact: windows-msi-$(targetPlatform)
            patterns: '**/*-$(targetPlatform).msi'
            path: $(Agent.TempDirectory)

        - powershell: |
            mkdir -p artifacts/build_data/snapshots
            mkdir -p artifacts/build_data/logs
            mkdir -p $(smokeTestAppDir)/artifacts
            mv $(Agent.TempDirectory)/*.msi $(smokeTestAppDir)/artifacts/datadog-apm.msi
          displayName: Create test data directories

        - bash: |
            $(dockerComposePath) -f docker-compose.windows.yml -p $(DockerComposeProjectName) build \
              --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
              --build-arg RUNTIME_IMAGE=$(runtimeImage) \
              --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
              --build-arg CHANNEL_32_BIT="" \
              dd-dotnet-smoke-tests.windows
          env:
            dockerTag: $(dockerTag)
          displayName: docker-compose build smoke-tests
          retryCountOnTaskFailure: 3

        - template: steps/run-snapshot-test.yml
          parameters:
            target: 'dd-dotnet-smoke-tests.windows'
            snapshotPrefix: "smoke_test"
            isLinux: false
            dockerComposePath: $(dockerComposePath)

        - publish: artifacts/build_data
          artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
          condition: always()
          continueOnError: true

        - template: steps/install-latest-dotnet-sdk.yml
        - script: tracer\build.cmd CheckSmokeTestsForErrors ExtractMetricsFromLogs
          displayName: CheckSmokeTestsForErrors ExtractMetricsFromLogs
          env:
            DD_LOGGER_DD_API_KEY: $(ddApiKey)

- stage: tracer_home_smoke_tests
  dependsOn: [package_windows, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
    dockerComposePath: 'C:/docker-compose/docker-compose.exe'
  jobs:
  - template: steps/update-github-status-jobs.yml
    parameters:
      jobs: [windows]

  - job: windows
    timeoutInMinutes: 45 # should take ~15 mins as large Windows docker files
    strategy:
      matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.tracer_home_installer_windows_smoke_tests_matrix'] ]
    variables:
      smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
    pool:
      vmImage: windows-2022

    steps:
    - template: steps/install-docker-compose-v1.yml
      parameters:
        dockerComposePath: $(dockerComposePath)

    - template: steps/clone-repo.yml
      parameters:
        targetShaId: $(targetShaId)
        targetBranch: $(targetBranch)

    - powershell: |
        mkdir -p artifacts/build_data/snapshots
        mkdir -p artifacts/build_data/logs
        mkdir -p $(smokeTestAppDir)/artifacts
      displayName: Create test data directories

    - template: steps/download-artifact.yml
      parameters:
        artifact: windows-tracer-home.zip
        path: $(smokeTestAppDir)/artifacts

    - bash: |
        $(dockerComposePath) -f docker-compose.windows.yml -p $(DockerComposeProjectName) build \
          --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
          --build-arg RUNTIME_IMAGE=$(runtimeImage) \
          --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
          --build-arg CHANNEL_32_BIT="$(channel32Bit)" \
          --build-arg RELATIVE_PROFILER_PATH="$(relativeProfilerPath)" \
          tracer-home-smoke-tests.windows
      env:
        dockerTag: $(dockerTag)
      displayName: docker-compose build smoke-tests
      retryCountOnTaskFailure: 3

    - template: steps/run-snapshot-test.yml
      parameters:
        target: 'tracer-home-smoke-tests.windows'
        snapshotPrefix: "smoke_test"
        isLinux: false
        dockerComposePath: $(dockerComposePath)

    - publish: artifacts/build_data
      artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
      condition: always()
      continueOnError: true

    - template: steps/install-latest-dotnet-sdk.yml
    - script: tracer\build.cmd CheckSmokeTestsForErrors ExtractMetricsFromLogs
      displayName: CheckSmokeTestsForErrors ExtractMetricsFromLogs
      env:
        DD_LOGGER_DD_API_KEY: $(ddApiKey)

- stage: fleet_installer_iis_smoke_tests
  dependsOn: [package_windows, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
    dockerComposePath: 'C:/docker-compose/docker-compose.exe'
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [windows]

    - job: windows
      timeoutInMinutes: 45 # should take ~15 mins as large Windows docker files
      strategy:
        matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.fleet_installer_windows_iis_smoke_tests_matrix'] ]
      variables:
        smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
      pool:
        vmImage: windows-2022

      steps:
        - template: steps/install-docker-compose-v1.yml
          parameters:
            dockerComposePath: $(dockerComposePath)

        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - template: steps/download-artifact.yml
          parameters:
            artifact: windows-tracer-home.zip
            path: $(smokeTestAppDir)/artifacts

        - template: steps/download-artifact.yml
          parameters:
            artifact: fleet-installer
            path: $(smokeTestAppDir)/artifacts/installer

        - template: steps/download-artifact.yml
          parameters:
            artifact: fleet-installer-telemetry-forwarder
            path: $(smokeTestAppDir)/artifacts/installer

        - powershell: |
            ls $(smokeTestAppDir)/artifacts
            ls $(smokeTestAppDir)/artifacts/installer
            mkdir -p artifacts/build_data/snapshots
            mkdir -p artifacts/build_data/logs
          displayName: Create test data directories

        - bash: |
            $(dockerComposePath) -f docker-compose.windows.yml -p $(DockerComposeProjectName) build \
              --build-arg DOTNETSDK_VERSION=$(dotnetCoreSdkLatestVersionShort) \
              --build-arg RUNTIME_IMAGE=$(runtimeImage) \
              --build-arg PUBLISH_FRAMEWORK=$(publishFramework) \
              --build-arg CHANNEL="$(channel)" \
              --build-arg TARGET_PLATFORM="$(targetPlatform)" \
              --build-arg INSTALL_COMMAND="$(installCommand)" \
              fleet-installer-smoke-tests-iis.windows
          env:
            dockerTag: $(dockerTag)
          displayName: docker-compose build smoke-tests
          retryCountOnTaskFailure: 3

        - template: steps/run-snapshot-test.yml
          parameters:
            target: 'fleet-installer-smoke-tests-iis.windows'
            testAgentTarget: 'test-agent.iis.windows'
            snapshotPrefix: "smoke_test_iis"
            isLinux: false
            dockerComposePath: $(dockerComposePath)

        - publish: artifacts/build_data
          artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
          condition: always()
          continueOnError: true

        - template: steps/install-latest-dotnet-sdk.yml
        - script: tracer\build.cmd CheckSmokeTestsForErrors ExtractMetricsFromLogs
          displayName: CheckSmokeTestsForErrors ExtractMetricsFromLogs
          env:
            DD_LOGGER_DD_API_KEY: $(ddApiKey)

- stage: dotnet_tool_nuget_smoke_tests_macos
  condition: and(succeeded(), or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.run_all_installer_tests, 'true')))
  dependsOn: [dotnet_tool, generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [macos]

    - job: macos
      timeoutInMinutes: 45 # should take ~5 mins
      strategy:
        matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.dotnet_tool_nuget_installer_macos_smoke_tests_matrix'] ]
      variables:
        smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
        snapshotSrcDir: "$(System.DefaultWorkingDirectory)/tracer/build/smoke_test_snapshots"
        snapshotOutputDir: "$(System.DefaultWorkingDirectory)/artifacts/build_data/snapshots"
      pool:
        vmImage: $(vmImage)
      
      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - template: steps/install-dotnet.yml
          parameters:
            packageType: sdk # have to install the SDK (instead of runtime) so we get the aspnetcore runtime

        - template: steps/download-artifact.yml
          parameters:
            artifact: runner-dotnet-tool
            path: $(smokeTestAppDir)/artifacts

        - script: |
            mkdir -p artifacts/build_data/snapshots
            mkdir -p artifacts/build_data/logs
            mkdir $(smokeTestAppDir)/publish
          displayName: create test data directories

        - script: |
            python --version
            pip install ddapm-test-agent

            # copied from run-snapshot-test
            echo "##vso[task.setvariable variable=TOKEN]$(System.JobId)"
            echo "##vso[task.setvariable variable=START_ENDPOINT]/test/session/start?test_session_token=$(System.JobId)"
            echo "##vso[task.setvariable variable=TRACE_DUMP_ENDPOINT]/test/session/traces?test_session_token=$(System.JobId)"
            echo "##vso[task.setvariable variable=STATS_DUMP_ENDPOINT]/test/session/stats?test_session_token=$(System.JobId)"
            echo "##vso[task.setvariable variable=REQUESTS_DUMP_ENDPOINT]/test/session/requests?test_session_token=$(System.JobId)"
            snapshotfile="smoke_test_snapshots"
            echo "##vso[task.setvariable variable=VERIFY_ENDPOINT]/test/session/snapshot?test_session_token=$(System.JobId)&file=$(snapshotSrcDir)/$snapshotfile"
            echo "##vso[task.setvariable variable=CURL_COMMAND]/usr/bin/curl"
          displayName: install test agent and set variables

        - script: |
            cd $(smokeTestAppDir)
            dotnet publish "AspNetCoreSmokeTest.csproj" -c Release --framework $(publishFramework) -o $(smokeTestAppDir)/publish
          displayName: Build app
          failOnStderr: true

        - script: |
            dotnet tool install dd-trace --tool-path $(smokeTestAppDir)/publish --add-source $(smokeTestAppDir)/artifacts/. --version $(ToolVersion)
          displayName: Install tracer

        - script: |
            ddapm-test-agent --port=8126 &
            agent_pid=$(echo $!)
            echo "##vso[task.setvariable variable=AGENT_PID]$agent_pid"
            echo "Agent PID: $agent_pid, waiting for startup"

            while ! nc -z localhost 8126; do   
              sleep 0.1 # wait for 1/10 of the second before check again
            done

            echo "Sending initialisation request"
            $(CURL_COMMAND) --fail "http://localhost:8126$(START_ENDPOINT)"
          displayName: run test agent
          env:
            ENABLED_CHECKS: trace_count_header,meta_tracer_version_header,trace_content_length
            SNAPSHOT_DIR: $(System.DefaultWorkingDirectory)/tracer/build/smoke_test_snapshots
            SNAPSHOT_CI: 1
            # ignoring 'http.client_ip' and 'network.client.ip' because it's set to '::1' here instead of expected '127.0.0.1'
            SNAPSHOT_IGNORED_ATTRS: span_id,trace_id,parent_id,duration,start,metrics.system.pid,meta.runtime-id,metrics.process_id,meta._dd.p.dm,meta._dd.p.tid,meta._dd.git.commit.sha,meta._dd.git.repository_url,meta.http.client_ip,meta.network.client.ip,meta._dd.appsec.s.req.params,meta._dd.appsec.s.res.body,meta._dd.appsec.s.req.headers,meta._dd.appsec.s.res.headers #api-security attrs are unfortunately ignored because gzip compression generates different bytes per platform windows/linux

        - script: |
            # Based on variables set in smoke.dotnet-tool.nuget.dockerfile
            DD_PROFILING_ENABLED=1 \
            DD_APPSEC_ENABLED=1 \
            DD_TRACE_DEBUG=1 \
            ASPNETCORE_URLS=http://localhost:5000 \
            SUPER_SECRET_CANARY=MySuperSecretCanary \
            DD_INTERNAL_WORKAROUND_77973_ENABLED=1 \
            COMPlus_DbgEnableMiniDump=1 \
            COMPlus_DbgMiniDumpType=4 \
            DOTNET_DbgMiniDumpName=$(System.DefaultWorkingDirectory)/artifacts/build_data/dumps/coredump.%t.%p \
            DOTNET_EnableCrashReport=1 \
            DD_INJECTION_ENABLED=tracer \
            DD_INJECT_FORCE=1 \
            DD_TELEMETRY_FORWARDER_PATH=/usr/bin/true \
            DD_TRACE_LOG_DIRECTORY=$(System.DefaultWorkingDirectory)/artifacts/build_data/logs \
            $(smokeTestAppDir)/publish/dd-trace dotnet $(smokeTestAppDir)/publish/AspNetCoreSmokeTest.dll
          displayName: Run the app

        - script: |
            echo "Dumping traces"
            $(CURL_COMMAND) -o $(snapshotOutputDir)/smoke_test_traces.json "http://localhost:8126$(TRACE_DUMP_ENDPOINT)"
            
            echo "Dumping stats"
            $(CURL_COMMAND) -o $(snapshotOutputDir)/smoke_test_stats.json "http://localhost:8126$(STATS_DUMP_ENDPOINT)"
            
            echo "Dumping all requests"
            $(CURL_COMMAND) -o $(snapshotOutputDir)/smoke_test_requests.json "http://localhost:8126$(REQUESTS_DUMP_ENDPOINT)"

            echo "Verifying snapshot session (fail on mis-match)"
            $(CURL_COMMAND) --fail-with-body "http://localhost:8126$(VERIFY_ENDPOINT)"
          displayName: check snapshots

        - publish: artifacts/build_data
          artifact: _$(System.StageName)_$(Agent.JobName)_logs_$(System.JobAttempt)
          condition: always()
          continueOnError: true

        - script: ./tracer/build.sh CheckSmokeTestsForErrors ExtractMetricsFromLogs
          displayName: CheckSmokeTestsForErrors ExtractMetricsFromLogs
          env:
            DD_LOGGER_DD_API_KEY: $(ddApiKey)

        - script: kill -15 $(AGENT_PID)
          displayName: Close test agent
          condition: succeededOrFailed()
          continueOnError: true

- stage: dd_dotnet_installer_failure_tests_linux
  dependsOn: [generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [linux]

    - job: linux
      timeoutInMinutes: 45 # should take ~5 mins
      strategy:
        # This uses the same matrix as installer_smoke_tests
        matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.installer_smoke_tests_matrix'] ]
      variables:
        smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
      pool:
        vmImage: ubuntu-latest
      
      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - script: docker pull $(runtimeImage)
          displayName: Pull dockerfile
          retryCountOnTaskFailure: 3

        - script: |
            echo "Expecting path: $(expectedPath)"
            echo "Expected installer: $(expectedInstaller)"

            cd tracer/build/artifacts
            result=$(docker run --rm -v ${PWD}:/app --entrypoint /app/dd-dotnet.sh $(runtimeImage))
            if [[ "$result" != *$(expectedPath)* ]]; then
              echo "Incorrect message. Expected '$(expectedPath)', but found:"
              echo $result
              exit 1
            fi

            if [[ "$result" != *$(expectedInstaller)* ]]; then
              echo "Incorrect message. Expected '$(expectedInstaller)', but found:"
              echo $result
              exit 1
            fi

            echo "Received expected response:"
            echo $result

          displayName: Run artifact test (expecting failure)

- stage: dd_dotnet_installer_failure_tests_linux_arm64
  condition: and(succeeded(), or(eq(variables.isMainOrReleaseBranch, 'true'), eq(variables.run_all_installer_tests, 'true')))
  dependsOn: [generate_variables, merge_commit_id]
  variables:
    targetShaId: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.sha']]
    targetBranch: $[ stageDependencies.merge_commit_id.fetch.outputs['set_sha.branch']]
  jobs:
    - template: steps/update-github-status-jobs.yml
      parameters:
        jobs: [linux]

    - job: linux
      timeoutInMinutes: 45 # should take ~15 mins
      strategy:
        # This uses the same matrix as installer_smoke_tests_arm64
        matrix: $[ stageDependencies.generate_variables.generate_variables_job.outputs['generate_variables_step.installer_smoke_tests_arm64_matrix'] ]
      variables:
        smokeTestAppDir: "$(System.DefaultWorkingDirectory)/tracer/test/test-applications/regression/AspNetCoreSmokeTest"
      pool:
        name: $(linuxArm64Pool)

      steps:
        - template: steps/clone-repo.yml
          parameters:
            targetShaId: $(targetShaId)
            targetBranch: $(targetBranch)

        - script: docker pull $(runtimeImage)
          displayName: Pull dockerfile
          retryCountOnTaskFailure: 3

        - script: |
            echo "Expecting path: $(expectedPath)"
            echo "Expected installer: $(expectedInstaller)"

            cd tracer/build/artifacts
            result=$(docker run --rm -v ${PWD}:/app --entrypoint /app/dd-dotnet.sh $(runtimeImage))
            if [[ "$result" != *$(expectedPath)* ]]; then
              echo "Incorrect message. Expected '$(expectedPath)', but found:"
              echo $result
              exit 1
            fi

            if [[ "$result" != *$(expectedInstaller)* ]]; then
              echo "Incorrect message. Expected '$(expectedInstaller)', but found:"
              echo $result
              exit 1
            fi

            echo "Received expected response:"
            echo $result

          displayName: Run artifact test (expecting failure)

- template: steps/update-github-pipeline-status.yml # Template reference