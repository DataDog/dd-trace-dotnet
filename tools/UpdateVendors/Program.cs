using System;
using System.IO;
using System.IO.Compression;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace UpdateVendors
{
    public class Program
    {
        private const string AutoGeneratedMessage = @"//------------------------------------------------------------------------------
// <auto-generated />
// This file was automatically generated by the UpdateVendors tool.
//------------------------------------------------------------------------------
";

        private static readonly string DownloadDirectory = Path.Combine(Environment.CurrentDirectory, "downloads");
        private static string _vendorProjectDirectory;

        public static async Task Main(string[] args)
        {
            InitializeCleanDirectory(DownloadDirectory);
            var solutionDirectory = GetSolutionDirectory();
            _vendorProjectDirectory = Path.Combine(solutionDirectory, "src", "Datadog.Trace", "Vendors");
            InitializeCleanDirectory(_vendorProjectDirectory);

            await UpdateVendorAsync(
                libraryName: "Serilog",
                branchDownload: "https://github.com/serilog/serilog/archive/v2.8.0.zip",
                commitUrl: "https://api.github.com/repos/serilog/serilog/commits/v2.8.0",
                pathToSrc: new[] { "serilog-2.8.0", "src", "Serilog" },
                transform: filePath => RewriteCsFileWithStandardTransform(filePath, originalNamespace: "Serilog"));

            await UpdateVendorAsync(
                libraryName: "Serilog.Sinks.File",
                branchDownload: "https://github.com/serilog/serilog-sinks-file/archive/v4.0.0.zip",
                commitUrl: "https://api.github.com/repos/serilog/serilog-sinks-file/commits/v4.0.0",
                pathToSrc: new[] { "serilog-sinks-file-4.0.0", "src", "Serilog.Sinks.File" },
                transform: filePath => RewriteCsFileWithStandardTransform(filePath, originalNamespace: "Serilog"));

            await UpdateVendorAsync(
                libraryName: "StatsdClient",
                branchDownload: "https://github.com/DataDog/dogstatsd-csharp-client/archive/3.3.0.zip",
                commitUrl: "https://api.github.com/repos/DataDog/dogstatsd-csharp-client/commits/3.3.0",
                pathToSrc: new[] { "dogstatsd-csharp-client-3.3.0", "src", "StatsdClient" },
                transform: filePath => RewriteCsFileWithStandardTransform(filePath, originalNamespace: "StatsdClient"));
        }

        private static void RewriteCsFileWithStandardTransform(string filePath, string originalNamespace, Func<string, string, string> extraTransform = null)
        {
            if (string.Equals(Path.GetExtension(filePath), ".cs", StringComparison.OrdinalIgnoreCase))
            {
                RewriteFileWithTransform(
                    filePath,
                    content =>
                    {
                        // Disable analyzer
                        var builder = new StringBuilder(AutoGeneratedMessage, content.Length * 2);

                        builder.Append(content);

                        // Prevent namespace conflicts
                        builder.Replace($"using {originalNamespace}", $"using Datadog.Trace.Vendors.{originalNamespace}");
                        builder.Replace($"namespace {originalNamespace}", $"namespace Datadog.Trace.Vendors.{originalNamespace}");

                        // Don't expose anything we don't intend to
                        // by replacing all "public" access modifiers with "internal"
                        var result = Regex.Replace(
                            builder.ToString(),
                            @"public(\s+((abstract|sealed|static)\s+)?(partial\s+)?(class|struct|interface|enum|delegate))",
                            match => $"internal{match.Groups[1]}");

                        if (extraTransform != null)
                        {
                            result = extraTransform(filePath, result);
                        }

                        return result;
                    });
            }
        }

        private static async Task UpdateVendorAsync(
            string libraryName,
            string branchDownload,
            string commitUrl,
            string[] pathToSrc,
            Action<string> transform = null)
        {
            Console.WriteLine($"Starting {libraryName} upgrade.");

            var zipLocation = Path.Combine(DownloadDirectory, $"{libraryName}.zip");
            var extractLocation = Path.Combine(DownloadDirectory, $"{libraryName}");

            using (var repoDownloadClient = new WebClient())
            {
                repoDownloadClient.DownloadFile(branchDownload, zipLocation);
            }

            Console.WriteLine($"Downloaded {libraryName} upgrade.");

            ZipFile.ExtractToDirectory(zipLocation, extractLocation);

            Console.WriteLine($"Unzipped {libraryName} upgrade.");

            var sourceLocation = Path.Combine(pathToSrc.Prepend(extractLocation).ToArray());
            var projFile = Path.Combine(sourceLocation, $"{libraryName}.csproj");

            // Rename the proj file to a txt for reference
            File.Copy(projFile, projFile + ".txt");
            File.Delete(projFile);
            Console.WriteLine($"Renamed {libraryName} project file.");

            // Delete the assembly properties
            var assemblyPropertiesFolder = Path.Combine(sourceLocation, @"Properties");
            SafeDeleteDirectory(assemblyPropertiesFolder);
            Console.WriteLine($"Deleted {libraryName} assembly properties file.");

            if (transform != null)
            {
                Console.WriteLine($"Running transforms on files for {libraryName}.");

                var files = Directory.GetFiles(
                    sourceLocation,
                    "*.*",
                    SearchOption.AllDirectories);

                foreach (var file in files)
                {
                    transform(file);
                }

                Console.WriteLine($"Finished transforms on files for {libraryName}.");
            }

            // Add information about the commit we are downloading
            var githubToken = Environment.GetEnvironmentVariable("DD_VENDOR_TOOL_TOKEN");
            if (githubToken == null)
            {
                throw new ArgumentException("You must specify a valid OAuth token for the github API.");
            }

            string commitInformation;
            using (var client = new HttpClient())
            {
                client.DefaultRequestHeaders.UserAgent.Add(new ProductInfoHeaderValue("Datadog.Trace.UpdateVendors", "1.0"));
                client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
                client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Token", githubToken);

                commitInformation = await client.GetStringAsync(commitUrl);
            }

            // save commit information to a formatted json file
            var commitJsonPath = Path.Combine(sourceLocation, "commit-info.json");
            SaveFormattedJson(commitInformation, commitJsonPath);

            // Move it all to the vendors directory
            Console.WriteLine($"Copying source of {libraryName} to vendor project.");
            var vendorFinalPath = Path.Combine(_vendorProjectDirectory, libraryName);
            SafeDeleteDirectory(vendorFinalPath);
            Directory.Move(sourceLocation, vendorFinalPath);
            Console.WriteLine($"Finished {libraryName} upgrade.");
        }

        private static void RewriteFileWithTransform(string filePath, Func<string, string> transform)
        {
            var fileContent = File.ReadAllText(filePath);
            fileContent = transform(fileContent);
            File.WriteAllText(
                filePath,
                fileContent,
                new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
        }

        private static void InitializeCleanDirectory(string directoryPath)
        {
            SafeDeleteDirectory(directoryPath);
            Directory.CreateDirectory(directoryPath);
        }

        private static void SafeDeleteDirectory(string directoryPath)
        {
            if (Directory.Exists(directoryPath))
            {
                Directory.Delete(directoryPath, recursive: true);
            }
        }

        private static void SaveFormattedJson(string json, string path)
        {
            var options = new JsonWriterOptions { Indented = true };

            using (var jsonDocument = JsonDocument.Parse(json))
            using (var fileStream = File.OpenWrite(path))
            using (var utf8JsonWriter = new Utf8JsonWriter(fileStream, options))
            {
                jsonDocument.WriteTo(utf8JsonWriter);
            }
        }

        private static string GetSolutionDirectory()
        {
            var startDirectory = Environment.CurrentDirectory;
            var currentDirectory = Directory.GetParent(startDirectory);
            const string searchItem = @"Datadog.Trace.sln";

            while (true)
            {
                var slnFile = currentDirectory.GetFiles(searchItem).SingleOrDefault();

                if (slnFile != null)
                {
                    break;
                }

                currentDirectory = currentDirectory.Parent;

                if (currentDirectory == null || !currentDirectory.Exists)
                {
                    throw new Exception($"Unable to find solution directory from: {startDirectory}");
                }
            }

            return currentDirectory.FullName;
        }
    }
}
