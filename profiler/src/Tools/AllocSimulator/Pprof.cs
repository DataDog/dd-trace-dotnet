// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: pprof.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

#pragma warning disable CS8981 // The type name only contains lower-cased ascii characters. Such names may become reserved for the language.
using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Perftools.Profiles
{

  /// <summary>Holder for reflection information generated from pprof.proto</summary>
  public static partial class PprofReflection {

    #region Descriptor
    /// <summary>File descriptor for pprof.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static PprofReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CgtwcHJvZi5wcm90bxIScGVyZnRvb2xzLnByb2ZpbGVzItUDCgdQcm9maWxl",
            "EjIKC3NhbXBsZV90eXBlGAEgAygLMh0ucGVyZnRvb2xzLnByb2ZpbGVzLlZh",
            "bHVlVHlwZRIqCgZzYW1wbGUYAiADKAsyGi5wZXJmdG9vbHMucHJvZmlsZXMu",
            "U2FtcGxlEiwKB21hcHBpbmcYAyADKAsyGy5wZXJmdG9vbHMucHJvZmlsZXMu",
            "TWFwcGluZxIuCghsb2NhdGlvbhgEIAMoCzIcLnBlcmZ0b29scy5wcm9maWxl",
            "cy5Mb2NhdGlvbhIuCghmdW5jdGlvbhgFIAMoCzIcLnBlcmZ0b29scy5wcm9m",
            "aWxlcy5GdW5jdGlvbhIUCgxzdHJpbmdfdGFibGUYBiADKAkSEwoLZHJvcF9m",
            "cmFtZXMYByABKAMSEwoLa2VlcF9mcmFtZXMYCCABKAMSEgoKdGltZV9uYW5v",
            "cxgJIAEoAxIWCg5kdXJhdGlvbl9uYW5vcxgKIAEoAxIyCgtwZXJpb2RfdHlw",
            "ZRgLIAEoCzIdLnBlcmZ0b29scy5wcm9maWxlcy5WYWx1ZVR5cGUSDgoGcGVy",
            "aW9kGAwgASgDEg8KB2NvbW1lbnQYDSADKAMSGwoTZGVmYXVsdF9zYW1wbGVf",
            "dHlwZRgOIAEoAyInCglWYWx1ZVR5cGUSDAoEdHlwZRgBIAEoAxIMCgR1bml0",
            "GAIgASgDIlYKBlNhbXBsZRITCgtsb2NhdGlvbl9pZBgBIAMoBBINCgV2YWx1",
            "ZRgCIAMoAxIoCgVsYWJlbBgDIAMoCzIZLnBlcmZ0b29scy5wcm9maWxlcy5M",
            "YWJlbCJACgVMYWJlbBILCgNrZXkYASABKAMSCwoDc3RyGAIgASgDEgsKA251",
            "bRgDIAEoAxIQCghudW1fdW5pdBgEIAEoAyLdAQoHTWFwcGluZxIKCgJpZBgB",
            "IAEoBBIUCgxtZW1vcnlfc3RhcnQYAiABKAQSFAoMbWVtb3J5X2xpbWl0GAMg",
            "ASgEEhMKC2ZpbGVfb2Zmc2V0GAQgASgEEhAKCGZpbGVuYW1lGAUgASgDEhAK",
            "CGJ1aWxkX2lkGAYgASgDEhUKDWhhc19mdW5jdGlvbnMYByABKAgSFQoNaGFz",
            "X2ZpbGVuYW1lcxgIIAEoCBIYChBoYXNfbGluZV9udW1iZXJzGAkgASgIEhkK",
            "EWhhc19pbmxpbmVfZnJhbWVzGAogASgIInYKCExvY2F0aW9uEgoKAmlkGAEg",
            "ASgEEhIKCm1hcHBpbmdfaWQYAiABKAQSDwoHYWRkcmVzcxgDIAEoBBImCgRs",
            "aW5lGAQgAygLMhgucGVyZnRvb2xzLnByb2ZpbGVzLkxpbmUSEQoJaXNfZm9s",
            "ZGVkGAUgASgIIikKBExpbmUSEwoLZnVuY3Rpb25faWQYASABKAQSDAoEbGlu",
            "ZRgCIAEoAyJfCghGdW5jdGlvbhIKCgJpZBgBIAEoBBIMCgRuYW1lGAIgASgD",
            "EhMKC3N5c3RlbV9uYW1lGAMgASgDEhAKCGZpbGVuYW1lGAQgASgDEhIKCnN0",
            "YXJ0X2xpbmUYBSABKANCLQodY29tLmdvb2dsZS5wZXJmdG9vbHMucHJvZmls",
            "ZXNCDFByb2ZpbGVQcm90b2IGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Perftools.Profiles.Profile), global::Perftools.Profiles.Profile.Parser, new[]{ "SampleType", "Sample", "Mapping", "Location", "Function", "StringTable", "DropFrames", "KeepFrames", "TimeNanos", "DurationNanos", "PeriodType", "Period", "Comment", "DefaultSampleType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Perftools.Profiles.ValueType), global::Perftools.Profiles.ValueType.Parser, new[]{ "Type", "Unit" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Perftools.Profiles.Sample), global::Perftools.Profiles.Sample.Parser, new[]{ "LocationId", "Value", "Label" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Perftools.Profiles.Label), global::Perftools.Profiles.Label.Parser, new[]{ "Key", "Str", "Num", "NumUnit" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Perftools.Profiles.Mapping), global::Perftools.Profiles.Mapping.Parser, new[]{ "Id", "MemoryStart", "MemoryLimit", "FileOffset", "Filename", "BuildId", "HasFunctions", "HasFilenames", "HasLineNumbers", "HasInlineFrames" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Perftools.Profiles.Location), global::Perftools.Profiles.Location.Parser, new[]{ "Id", "MappingId", "Address", "Line", "IsFolded" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Perftools.Profiles.Line), global::Perftools.Profiles.Line.Parser, new[]{ "FunctionId", "Line_" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Perftools.Profiles.Function), global::Perftools.Profiles.Function.Parser, new[]{ "Id", "Name", "SystemName", "Filename", "StartLine" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  public sealed partial class Profile : pb::IMessage<Profile> {
    private static readonly pb::MessageParser<Profile> _parser = new pb::MessageParser<Profile>(() => new Profile());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Profile> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Perftools.Profiles.PprofReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Profile() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Profile(Profile other) : this() {
      sampleType_ = other.sampleType_.Clone();
      sample_ = other.sample_.Clone();
      mapping_ = other.mapping_.Clone();
      location_ = other.location_.Clone();
      function_ = other.function_.Clone();
      stringTable_ = other.stringTable_.Clone();
      dropFrames_ = other.dropFrames_;
      keepFrames_ = other.keepFrames_;
      timeNanos_ = other.timeNanos_;
      durationNanos_ = other.durationNanos_;
      periodType_ = other.periodType_ != null ? other.periodType_.Clone() : null;
      period_ = other.period_;
      comment_ = other.comment_.Clone();
      defaultSampleType_ = other.defaultSampleType_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Profile Clone() {
      return new Profile(this);
    }

    /// <summary>Field number for the "sample_type" field.</summary>
    public const int SampleTypeFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Perftools.Profiles.ValueType> _repeated_sampleType_codec
        = pb::FieldCodec.ForMessage(10, global::Perftools.Profiles.ValueType.Parser);
    private readonly pbc::RepeatedField<global::Perftools.Profiles.ValueType> sampleType_ = new pbc::RepeatedField<global::Perftools.Profiles.ValueType>();
    /// <summary>
    /// A description of the samples associated with each Sample.value.
    /// For a cpu profile this might be:
    ///   [["cpu","nanoseconds"]] or [["wall","seconds"]] or [["syscall","count"]]
    /// For a heap profile, this might be:
    ///   [["allocations","count"], ["space","bytes"]],
    /// If one of the values represents the number of events represented
    /// by the sample, by convention it should be at index 0 and use
    /// sample_type.unit == "count".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Perftools.Profiles.ValueType> SampleType {
      get { return sampleType_; }
    }

    /// <summary>Field number for the "sample" field.</summary>
    public const int SampleFieldNumber = 2;
    private static readonly pb::FieldCodec<global::Perftools.Profiles.Sample> _repeated_sample_codec
        = pb::FieldCodec.ForMessage(18, global::Perftools.Profiles.Sample.Parser);
    private readonly pbc::RepeatedField<global::Perftools.Profiles.Sample> sample_ = new pbc::RepeatedField<global::Perftools.Profiles.Sample>();
    /// <summary>
    /// The set of samples recorded in this profile.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Perftools.Profiles.Sample> Sample {
      get { return sample_; }
    }

    /// <summary>Field number for the "mapping" field.</summary>
    public const int MappingFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Perftools.Profiles.Mapping> _repeated_mapping_codec
        = pb::FieldCodec.ForMessage(26, global::Perftools.Profiles.Mapping.Parser);
    private readonly pbc::RepeatedField<global::Perftools.Profiles.Mapping> mapping_ = new pbc::RepeatedField<global::Perftools.Profiles.Mapping>();
    /// <summary>
    /// Mapping from address ranges to the image/binary/library mapped
    /// into that address range.  mapping[0] will be the main binary.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Perftools.Profiles.Mapping> Mapping {
      get { return mapping_; }
    }

    /// <summary>Field number for the "location" field.</summary>
    public const int LocationFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Perftools.Profiles.Location> _repeated_location_codec
        = pb::FieldCodec.ForMessage(34, global::Perftools.Profiles.Location.Parser);
    private readonly pbc::RepeatedField<global::Perftools.Profiles.Location> location_ = new pbc::RepeatedField<global::Perftools.Profiles.Location>();
    /// <summary>
    /// Useful program location
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Perftools.Profiles.Location> Location {
      get { return location_; }
    }

    /// <summary>Field number for the "function" field.</summary>
    public const int FunctionFieldNumber = 5;
    private static readonly pb::FieldCodec<global::Perftools.Profiles.Function> _repeated_function_codec
        = pb::FieldCodec.ForMessage(42, global::Perftools.Profiles.Function.Parser);
    private readonly pbc::RepeatedField<global::Perftools.Profiles.Function> function_ = new pbc::RepeatedField<global::Perftools.Profiles.Function>();
    /// <summary>
    /// Functions referenced by locations
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Perftools.Profiles.Function> Function {
      get { return function_; }
    }

    /// <summary>Field number for the "string_table" field.</summary>
    public const int StringTableFieldNumber = 6;
    private static readonly pb::FieldCodec<string> _repeated_stringTable_codec
        = pb::FieldCodec.ForString(50);
    private readonly pbc::RepeatedField<string> stringTable_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// A common table for strings referenced by various messages.
    /// string_table[0] must always be "".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> StringTable {
      get { return stringTable_; }
    }

    /// <summary>Field number for the "drop_frames" field.</summary>
    public const int DropFramesFieldNumber = 7;
    private long dropFrames_;
    /// <summary>
    /// frames with Function.function_name fully matching the following
    /// regexp will be dropped from the samples, along with their successors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long DropFrames {
      get { return dropFrames_; }
      set {
        dropFrames_ = value;
      }
    }

    /// <summary>Field number for the "keep_frames" field.</summary>
    public const int KeepFramesFieldNumber = 8;
    private long keepFrames_;
    /// <summary>
    /// frames with Function.function_name fully matching the following
    /// regexp will be kept, even if it matches drop_functions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long KeepFrames {
      get { return keepFrames_; }
      set {
        keepFrames_ = value;
      }
    }

    /// <summary>Field number for the "time_nanos" field.</summary>
    public const int TimeNanosFieldNumber = 9;
    private long timeNanos_;
    /// <summary>
    /// Time of collection (UTC) represented as nanoseconds past the epoch.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long TimeNanos {
      get { return timeNanos_; }
      set {
        timeNanos_ = value;
      }
    }

    /// <summary>Field number for the "duration_nanos" field.</summary>
    public const int DurationNanosFieldNumber = 10;
    private long durationNanos_;
    /// <summary>
    /// Duration of the profile, if a duration makes sense.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long DurationNanos {
      get { return durationNanos_; }
      set {
        durationNanos_ = value;
      }
    }

    /// <summary>Field number for the "period_type" field.</summary>
    public const int PeriodTypeFieldNumber = 11;
    private global::Perftools.Profiles.ValueType periodType_;
    /// <summary>
    /// The kind of events between sampled ocurrences.
    /// e.g [ "cpu","cycles" ] or [ "heap","bytes" ]
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Perftools.Profiles.ValueType PeriodType {
      get { return periodType_; }
      set {
        periodType_ = value;
      }
    }

    /// <summary>Field number for the "period" field.</summary>
    public const int PeriodFieldNumber = 12;
    private long period_;
    /// <summary>
    /// The number of events between sampled occurrences.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Period {
      get { return period_; }
      set {
        period_ = value;
      }
    }

    /// <summary>Field number for the "comment" field.</summary>
    public const int CommentFieldNumber = 13;
    private static readonly pb::FieldCodec<long> _repeated_comment_codec
        = pb::FieldCodec.ForInt64(106);
    private readonly pbc::RepeatedField<long> comment_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// Freeform text associated to the profile.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> Comment {
      get { return comment_; }
    }

    /// <summary>Field number for the "default_sample_type" field.</summary>
    public const int DefaultSampleTypeFieldNumber = 14;
    private long defaultSampleType_;
    /// <summary>
    /// Index into the string table of the type of the preferred sample
    /// value. If unset, clients should default to the last sample value.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long DefaultSampleType {
      get { return defaultSampleType_; }
      set {
        defaultSampleType_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Profile);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Profile other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!sampleType_.Equals(other.sampleType_)) return false;
      if(!sample_.Equals(other.sample_)) return false;
      if(!mapping_.Equals(other.mapping_)) return false;
      if(!location_.Equals(other.location_)) return false;
      if(!function_.Equals(other.function_)) return false;
      if(!stringTable_.Equals(other.stringTable_)) return false;
      if (DropFrames != other.DropFrames) return false;
      if (KeepFrames != other.KeepFrames) return false;
      if (TimeNanos != other.TimeNanos) return false;
      if (DurationNanos != other.DurationNanos) return false;
      if (!object.Equals(PeriodType, other.PeriodType)) return false;
      if (Period != other.Period) return false;
      if(!comment_.Equals(other.comment_)) return false;
      if (DefaultSampleType != other.DefaultSampleType) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= sampleType_.GetHashCode();
      hash ^= sample_.GetHashCode();
      hash ^= mapping_.GetHashCode();
      hash ^= location_.GetHashCode();
      hash ^= function_.GetHashCode();
      hash ^= stringTable_.GetHashCode();
      if (DropFrames != 0L) hash ^= DropFrames.GetHashCode();
      if (KeepFrames != 0L) hash ^= KeepFrames.GetHashCode();
      if (TimeNanos != 0L) hash ^= TimeNanos.GetHashCode();
      if (DurationNanos != 0L) hash ^= DurationNanos.GetHashCode();
      if (periodType_ != null) hash ^= PeriodType.GetHashCode();
      if (Period != 0L) hash ^= Period.GetHashCode();
      hash ^= comment_.GetHashCode();
      if (DefaultSampleType != 0L) hash ^= DefaultSampleType.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      sampleType_.WriteTo(output, _repeated_sampleType_codec);
      sample_.WriteTo(output, _repeated_sample_codec);
      mapping_.WriteTo(output, _repeated_mapping_codec);
      location_.WriteTo(output, _repeated_location_codec);
      function_.WriteTo(output, _repeated_function_codec);
      stringTable_.WriteTo(output, _repeated_stringTable_codec);
      if (DropFrames != 0L) {
        output.WriteRawTag(56);
        output.WriteInt64(DropFrames);
      }
      if (KeepFrames != 0L) {
        output.WriteRawTag(64);
        output.WriteInt64(KeepFrames);
      }
      if (TimeNanos != 0L) {
        output.WriteRawTag(72);
        output.WriteInt64(TimeNanos);
      }
      if (DurationNanos != 0L) {
        output.WriteRawTag(80);
        output.WriteInt64(DurationNanos);
      }
      if (periodType_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(PeriodType);
      }
      if (Period != 0L) {
        output.WriteRawTag(96);
        output.WriteInt64(Period);
      }
      comment_.WriteTo(output, _repeated_comment_codec);
      if (DefaultSampleType != 0L) {
        output.WriteRawTag(112);
        output.WriteInt64(DefaultSampleType);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += sampleType_.CalculateSize(_repeated_sampleType_codec);
      size += sample_.CalculateSize(_repeated_sample_codec);
      size += mapping_.CalculateSize(_repeated_mapping_codec);
      size += location_.CalculateSize(_repeated_location_codec);
      size += function_.CalculateSize(_repeated_function_codec);
      size += stringTable_.CalculateSize(_repeated_stringTable_codec);
      if (DropFrames != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(DropFrames);
      }
      if (KeepFrames != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(KeepFrames);
      }
      if (TimeNanos != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(TimeNanos);
      }
      if (DurationNanos != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(DurationNanos);
      }
      if (periodType_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PeriodType);
      }
      if (Period != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Period);
      }
      size += comment_.CalculateSize(_repeated_comment_codec);
      if (DefaultSampleType != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(DefaultSampleType);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Profile other) {
      if (other == null) {
        return;
      }
      sampleType_.Add(other.sampleType_);
      sample_.Add(other.sample_);
      mapping_.Add(other.mapping_);
      location_.Add(other.location_);
      function_.Add(other.function_);
      stringTable_.Add(other.stringTable_);
      if (other.DropFrames != 0L) {
        DropFrames = other.DropFrames;
      }
      if (other.KeepFrames != 0L) {
        KeepFrames = other.KeepFrames;
      }
      if (other.TimeNanos != 0L) {
        TimeNanos = other.TimeNanos;
      }
      if (other.DurationNanos != 0L) {
        DurationNanos = other.DurationNanos;
      }
      if (other.periodType_ != null) {
        if (periodType_ == null) {
          PeriodType = new global::Perftools.Profiles.ValueType();
        }
        PeriodType.MergeFrom(other.PeriodType);
      }
      if (other.Period != 0L) {
        Period = other.Period;
      }
      comment_.Add(other.comment_);
      if (other.DefaultSampleType != 0L) {
        DefaultSampleType = other.DefaultSampleType;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            sampleType_.AddEntriesFrom(input, _repeated_sampleType_codec);
            break;
          }
          case 18: {
            sample_.AddEntriesFrom(input, _repeated_sample_codec);
            break;
          }
          case 26: {
            mapping_.AddEntriesFrom(input, _repeated_mapping_codec);
            break;
          }
          case 34: {
            location_.AddEntriesFrom(input, _repeated_location_codec);
            break;
          }
          case 42: {
            function_.AddEntriesFrom(input, _repeated_function_codec);
            break;
          }
          case 50: {
            stringTable_.AddEntriesFrom(input, _repeated_stringTable_codec);
            break;
          }
          case 56: {
            DropFrames = input.ReadInt64();
            break;
          }
          case 64: {
            KeepFrames = input.ReadInt64();
            break;
          }
          case 72: {
            TimeNanos = input.ReadInt64();
            break;
          }
          case 80: {
            DurationNanos = input.ReadInt64();
            break;
          }
          case 90: {
            if (periodType_ == null) {
              PeriodType = new global::Perftools.Profiles.ValueType();
            }
            input.ReadMessage(PeriodType);
            break;
          }
          case 96: {
            Period = input.ReadInt64();
            break;
          }
          case 106:
          case 104: {
            comment_.AddEntriesFrom(input, _repeated_comment_codec);
            break;
          }
          case 112: {
            DefaultSampleType = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// ValueType describes the semantics and measurement units of a value.
  /// </summary>
  public sealed partial class ValueType : pb::IMessage<ValueType> {
    private static readonly pb::MessageParser<ValueType> _parser = new pb::MessageParser<ValueType>(() => new ValueType());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ValueType> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Perftools.Profiles.PprofReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueType() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueType(ValueType other) : this() {
      type_ = other.type_;
      unit_ = other.unit_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueType Clone() {
      return new ValueType(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private long type_;
    /// <summary>
    /// Index into string table.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "unit" field.</summary>
    public const int UnitFieldNumber = 2;
    private long unit_;
    /// <summary>
    /// Index into string table.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Unit {
      get { return unit_; }
      set {
        unit_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ValueType);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ValueType other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (Unit != other.Unit) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Type != 0L) hash ^= Type.GetHashCode();
      if (Unit != 0L) hash ^= Unit.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Type != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Type);
      }
      if (Unit != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Unit);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Type != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Type);
      }
      if (Unit != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Unit);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ValueType other) {
      if (other == null) {
        return;
      }
      if (other.Type != 0L) {
        Type = other.Type;
      }
      if (other.Unit != 0L) {
        Unit = other.Unit;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Type = input.ReadInt64();
            break;
          }
          case 16: {
            Unit = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Each Sample records values encountered in some program
  /// context. The program context is typically a stack trace, perhaps
  /// augmented with auxiliary information like the thread-id, some
  /// indicator of a higher level request being handled etc.
  /// </summary>
  public sealed partial class Sample : pb::IMessage<Sample> {
    private static readonly pb::MessageParser<Sample> _parser = new pb::MessageParser<Sample>(() => new Sample());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Sample> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Perftools.Profiles.PprofReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Sample() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Sample(Sample other) : this() {
      locationId_ = other.locationId_.Clone();
      value_ = other.value_.Clone();
      label_ = other.label_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Sample Clone() {
      return new Sample(this);
    }

    /// <summary>Field number for the "location_id" field.</summary>
    public const int LocationIdFieldNumber = 1;
    private static readonly pb::FieldCodec<ulong> _repeated_locationId_codec
        = pb::FieldCodec.ForUInt64(10);
    private readonly pbc::RepeatedField<ulong> locationId_ = new pbc::RepeatedField<ulong>();
    /// <summary>
    /// The ids recorded here correspond to a Profile.location.id.
    /// The leaf is at location_id[0].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<ulong> LocationId {
      get { return locationId_; }
    }

    /// <summary>Field number for the "value" field.</summary>
    public const int ValueFieldNumber = 2;
    private static readonly pb::FieldCodec<long> _repeated_value_codec
        = pb::FieldCodec.ForInt64(18);
    private readonly pbc::RepeatedField<long> value_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The type and unit of each value is defined by the corresponding
    /// entry in Profile.sample_type. All samples must have the same
    /// number of values, the same as the length of Profile.sample_type.
    /// When aggregating multiple samples into a single sample, the
    /// result has a list of values that is the elemntwise sum of the
    /// lists of the originals.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> Value {
      get { return value_; }
    }

    /// <summary>Field number for the "label" field.</summary>
    public const int LabelFieldNumber = 3;
    private static readonly pb::FieldCodec<global::Perftools.Profiles.Label> _repeated_label_codec
        = pb::FieldCodec.ForMessage(26, global::Perftools.Profiles.Label.Parser);
    private readonly pbc::RepeatedField<global::Perftools.Profiles.Label> label_ = new pbc::RepeatedField<global::Perftools.Profiles.Label>();
    /// <summary>
    /// label includes additional context for this sample. It can include
    /// things like a thread id, allocation size, etc
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Perftools.Profiles.Label> Label {
      get { return label_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Sample);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Sample other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!locationId_.Equals(other.locationId_)) return false;
      if(!value_.Equals(other.value_)) return false;
      if(!label_.Equals(other.label_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= locationId_.GetHashCode();
      hash ^= value_.GetHashCode();
      hash ^= label_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      locationId_.WriteTo(output, _repeated_locationId_codec);
      value_.WriteTo(output, _repeated_value_codec);
      label_.WriteTo(output, _repeated_label_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += locationId_.CalculateSize(_repeated_locationId_codec);
      size += value_.CalculateSize(_repeated_value_codec);
      size += label_.CalculateSize(_repeated_label_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Sample other) {
      if (other == null) {
        return;
      }
      locationId_.Add(other.locationId_);
      value_.Add(other.value_);
      label_.Add(other.label_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            locationId_.AddEntriesFrom(input, _repeated_locationId_codec);
            break;
          }
          case 18:
          case 16: {
            value_.AddEntriesFrom(input, _repeated_value_codec);
            break;
          }
          case 26: {
            label_.AddEntriesFrom(input, _repeated_label_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class Label : pb::IMessage<Label> {
    private static readonly pb::MessageParser<Label> _parser = new pb::MessageParser<Label>(() => new Label());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Label> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Perftools.Profiles.PprofReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Label() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Label(Label other) : this() {
      key_ = other.key_;
      str_ = other.str_;
      num_ = other.num_;
      numUnit_ = other.numUnit_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Label Clone() {
      return new Label(this);
    }

    /// <summary>Field number for the "key" field.</summary>
    public const int KeyFieldNumber = 1;
    private long key_;
    /// <summary>
    /// Index into string table
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Key {
      get { return key_; }
      set {
        key_ = value;
      }
    }

    /// <summary>Field number for the "str" field.</summary>
    public const int StrFieldNumber = 2;
    private long str_;
    /// <summary>
    /// At most one of the following must be present
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Str {
      get { return str_; }
      set {
        str_ = value;
      }
    }

    /// <summary>Field number for the "num" field.</summary>
    public const int NumFieldNumber = 3;
    private long num_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Num {
      get { return num_; }
      set {
        num_ = value;
      }
    }

    /// <summary>Field number for the "num_unit" field.</summary>
    public const int NumUnitFieldNumber = 4;
    private long numUnit_;
    /// <summary>
    /// Should only be present when num is present.
    /// Specifies the units of num.
    /// Use arbitrary string (for example, "requests") as a custom count unit.
    /// If no unit is specified, consumer may apply heuristic to deduce the unit.
    /// Consumers may also  interpret units like "bytes" and "kilobytes" as memory
    /// units and units like "seconds" and "nanoseconds" as time units,
    /// and apply appropriate unit conversions to these.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long NumUnit {
      get { return numUnit_; }
      set {
        numUnit_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Label);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Label other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Key != other.Key) return false;
      if (Str != other.Str) return false;
      if (Num != other.Num) return false;
      if (NumUnit != other.NumUnit) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Key != 0L) hash ^= Key.GetHashCode();
      if (Str != 0L) hash ^= Str.GetHashCode();
      if (Num != 0L) hash ^= Num.GetHashCode();
      if (NumUnit != 0L) hash ^= NumUnit.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Key != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(Key);
      }
      if (Str != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Str);
      }
      if (Num != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(Num);
      }
      if (NumUnit != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(NumUnit);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Key != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Key);
      }
      if (Str != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Str);
      }
      if (Num != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Num);
      }
      if (NumUnit != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(NumUnit);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Label other) {
      if (other == null) {
        return;
      }
      if (other.Key != 0L) {
        Key = other.Key;
      }
      if (other.Str != 0L) {
        Str = other.Str;
      }
      if (other.Num != 0L) {
        Num = other.Num;
      }
      if (other.NumUnit != 0L) {
        NumUnit = other.NumUnit;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Key = input.ReadInt64();
            break;
          }
          case 16: {
            Str = input.ReadInt64();
            break;
          }
          case 24: {
            Num = input.ReadInt64();
            break;
          }
          case 32: {
            NumUnit = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  public sealed partial class Mapping : pb::IMessage<Mapping> {
    private static readonly pb::MessageParser<Mapping> _parser = new pb::MessageParser<Mapping>(() => new Mapping());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Mapping> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Perftools.Profiles.PprofReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Mapping() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Mapping(Mapping other) : this() {
      id_ = other.id_;
      memoryStart_ = other.memoryStart_;
      memoryLimit_ = other.memoryLimit_;
      fileOffset_ = other.fileOffset_;
      filename_ = other.filename_;
      buildId_ = other.buildId_;
      hasFunctions_ = other.hasFunctions_;
      hasFilenames_ = other.hasFilenames_;
      hasLineNumbers_ = other.hasLineNumbers_;
      hasInlineFrames_ = other.hasInlineFrames_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Mapping Clone() {
      return new Mapping(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private ulong id_;
    /// <summary>
    /// Unique nonzero id for the mapping.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "memory_start" field.</summary>
    public const int MemoryStartFieldNumber = 2;
    private ulong memoryStart_;
    /// <summary>
    /// Address at which the binary (or DLL) is loaded into memory.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong MemoryStart {
      get { return memoryStart_; }
      set {
        memoryStart_ = value;
      }
    }

    /// <summary>Field number for the "memory_limit" field.</summary>
    public const int MemoryLimitFieldNumber = 3;
    private ulong memoryLimit_;
    /// <summary>
    /// The limit of the address range occupied by this mapping.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong MemoryLimit {
      get { return memoryLimit_; }
      set {
        memoryLimit_ = value;
      }
    }

    /// <summary>Field number for the "file_offset" field.</summary>
    public const int FileOffsetFieldNumber = 4;
    private ulong fileOffset_;
    /// <summary>
    /// Offset in the binary that corresponds to the first mapped address.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong FileOffset {
      get { return fileOffset_; }
      set {
        fileOffset_ = value;
      }
    }

    /// <summary>Field number for the "filename" field.</summary>
    public const int FilenameFieldNumber = 5;
    private long filename_;
    /// <summary>
    /// The object this entry is loaded from.  This can be a filename on
    /// disk for the main binary and shared libraries, or virtual
    /// abstractions like "[vdso]".
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Filename {
      get { return filename_; }
      set {
        filename_ = value;
      }
    }

    /// <summary>Field number for the "build_id" field.</summary>
    public const int BuildIdFieldNumber = 6;
    private long buildId_;
    /// <summary>
    /// A string that uniquely identifies a particular program version
    /// with high probability. E.g., for binaries generated by GNU tools,
    /// it could be the contents of the .note.gnu.build-id field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long BuildId {
      get { return buildId_; }
      set {
        buildId_ = value;
      }
    }

    /// <summary>Field number for the "has_functions" field.</summary>
    public const int HasFunctionsFieldNumber = 7;
    private bool hasFunctions_;
    /// <summary>
    /// The following fields indicate the resolution of symbolic info.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFunctions {
      get { return hasFunctions_; }
      set {
        hasFunctions_ = value;
      }
    }

    /// <summary>Field number for the "has_filenames" field.</summary>
    public const int HasFilenamesFieldNumber = 8;
    private bool hasFilenames_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasFilenames {
      get { return hasFilenames_; }
      set {
        hasFilenames_ = value;
      }
    }

    /// <summary>Field number for the "has_line_numbers" field.</summary>
    public const int HasLineNumbersFieldNumber = 9;
    private bool hasLineNumbers_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasLineNumbers {
      get { return hasLineNumbers_; }
      set {
        hasLineNumbers_ = value;
      }
    }

    /// <summary>Field number for the "has_inline_frames" field.</summary>
    public const int HasInlineFramesFieldNumber = 10;
    private bool hasInlineFrames_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HasInlineFrames {
      get { return hasInlineFrames_; }
      set {
        hasInlineFrames_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Mapping);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Mapping other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (MemoryStart != other.MemoryStart) return false;
      if (MemoryLimit != other.MemoryLimit) return false;
      if (FileOffset != other.FileOffset) return false;
      if (Filename != other.Filename) return false;
      if (BuildId != other.BuildId) return false;
      if (HasFunctions != other.HasFunctions) return false;
      if (HasFilenames != other.HasFilenames) return false;
      if (HasLineNumbers != other.HasLineNumbers) return false;
      if (HasInlineFrames != other.HasInlineFrames) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id != 0UL) hash ^= Id.GetHashCode();
      if (MemoryStart != 0UL) hash ^= MemoryStart.GetHashCode();
      if (MemoryLimit != 0UL) hash ^= MemoryLimit.GetHashCode();
      if (FileOffset != 0UL) hash ^= FileOffset.GetHashCode();
      if (Filename != 0L) hash ^= Filename.GetHashCode();
      if (BuildId != 0L) hash ^= BuildId.GetHashCode();
      if (HasFunctions != false) hash ^= HasFunctions.GetHashCode();
      if (HasFilenames != false) hash ^= HasFilenames.GetHashCode();
      if (HasLineNumbers != false) hash ^= HasLineNumbers.GetHashCode();
      if (HasInlineFrames != false) hash ^= HasInlineFrames.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Id != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Id);
      }
      if (MemoryStart != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(MemoryStart);
      }
      if (MemoryLimit != 0UL) {
        output.WriteRawTag(24);
        output.WriteUInt64(MemoryLimit);
      }
      if (FileOffset != 0UL) {
        output.WriteRawTag(32);
        output.WriteUInt64(FileOffset);
      }
      if (Filename != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(Filename);
      }
      if (BuildId != 0L) {
        output.WriteRawTag(48);
        output.WriteInt64(BuildId);
      }
      if (HasFunctions != false) {
        output.WriteRawTag(56);
        output.WriteBool(HasFunctions);
      }
      if (HasFilenames != false) {
        output.WriteRawTag(64);
        output.WriteBool(HasFilenames);
      }
      if (HasLineNumbers != false) {
        output.WriteRawTag(72);
        output.WriteBool(HasLineNumbers);
      }
      if (HasInlineFrames != false) {
        output.WriteRawTag(80);
        output.WriteBool(HasInlineFrames);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Id);
      }
      if (MemoryStart != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MemoryStart);
      }
      if (MemoryLimit != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MemoryLimit);
      }
      if (FileOffset != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(FileOffset);
      }
      if (Filename != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Filename);
      }
      if (BuildId != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(BuildId);
      }
      if (HasFunctions != false) {
        size += 1 + 1;
      }
      if (HasFilenames != false) {
        size += 1 + 1;
      }
      if (HasLineNumbers != false) {
        size += 1 + 1;
      }
      if (HasInlineFrames != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Mapping other) {
      if (other == null) {
        return;
      }
      if (other.Id != 0UL) {
        Id = other.Id;
      }
      if (other.MemoryStart != 0UL) {
        MemoryStart = other.MemoryStart;
      }
      if (other.MemoryLimit != 0UL) {
        MemoryLimit = other.MemoryLimit;
      }
      if (other.FileOffset != 0UL) {
        FileOffset = other.FileOffset;
      }
      if (other.Filename != 0L) {
        Filename = other.Filename;
      }
      if (other.BuildId != 0L) {
        BuildId = other.BuildId;
      }
      if (other.HasFunctions != false) {
        HasFunctions = other.HasFunctions;
      }
      if (other.HasFilenames != false) {
        HasFilenames = other.HasFilenames;
      }
      if (other.HasLineNumbers != false) {
        HasLineNumbers = other.HasLineNumbers;
      }
      if (other.HasInlineFrames != false) {
        HasInlineFrames = other.HasInlineFrames;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadUInt64();
            break;
          }
          case 16: {
            MemoryStart = input.ReadUInt64();
            break;
          }
          case 24: {
            MemoryLimit = input.ReadUInt64();
            break;
          }
          case 32: {
            FileOffset = input.ReadUInt64();
            break;
          }
          case 40: {
            Filename = input.ReadInt64();
            break;
          }
          case 48: {
            BuildId = input.ReadInt64();
            break;
          }
          case 56: {
            HasFunctions = input.ReadBool();
            break;
          }
          case 64: {
            HasFilenames = input.ReadBool();
            break;
          }
          case 72: {
            HasLineNumbers = input.ReadBool();
            break;
          }
          case 80: {
            HasInlineFrames = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Describes function and line table debug information.
  /// </summary>
  public sealed partial class Location : pb::IMessage<Location> {
    private static readonly pb::MessageParser<Location> _parser = new pb::MessageParser<Location>(() => new Location());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Location> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Perftools.Profiles.PprofReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Location() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Location(Location other) : this() {
      id_ = other.id_;
      mappingId_ = other.mappingId_;
      address_ = other.address_;
      line_ = other.line_.Clone();
      isFolded_ = other.isFolded_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Location Clone() {
      return new Location(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private ulong id_;
    /// <summary>
    /// Unique nonzero id for the location.  A profile could use
    /// instruction addresses or any integer sequence as ids.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "mapping_id" field.</summary>
    public const int MappingIdFieldNumber = 2;
    private ulong mappingId_;
    /// <summary>
    /// The id of the corresponding profile.Mapping for this location.
    /// It can be unset if the mapping is unknown or not applicable for
    /// this profile type.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong MappingId {
      get { return mappingId_; }
      set {
        mappingId_ = value;
      }
    }

    /// <summary>Field number for the "address" field.</summary>
    public const int AddressFieldNumber = 3;
    private ulong address_;
    /// <summary>
    /// The instruction address for this location, if available.  It
    /// should be within [Mapping.memory_start...Mapping.memory_limit]
    /// for the corresponding mapping. A non-leaf address may be in the
    /// middle of a call instruction. It is up to display tools to find
    /// the beginning of the instruction if necessary.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Address {
      get { return address_; }
      set {
        address_ = value;
      }
    }

    /// <summary>Field number for the "line" field.</summary>
    public const int LineFieldNumber = 4;
    private static readonly pb::FieldCodec<global::Perftools.Profiles.Line> _repeated_line_codec
        = pb::FieldCodec.ForMessage(34, global::Perftools.Profiles.Line.Parser);
    private readonly pbc::RepeatedField<global::Perftools.Profiles.Line> line_ = new pbc::RepeatedField<global::Perftools.Profiles.Line>();
    /// <summary>
    /// Multiple line indicates this location has inlined functions,
    /// where the last entry represents the caller into which the
    /// preceding entries were inlined.
    ///
    /// E.g., if memcpy() is inlined into printf:
    ///    line[0].function_name == "memcpy"
    ///    line[1].function_name == "printf"
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Perftools.Profiles.Line> Line {
      get { return line_; }
    }

    /// <summary>Field number for the "is_folded" field.</summary>
    public const int IsFoldedFieldNumber = 5;
    private bool isFolded_;
    /// <summary>
    /// Provides an indication that multiple symbols map to this location's
    /// address, for example due to identical code folding by the linker. In that
    /// case the line information above represents one of the multiple
    /// symbols. This field must be recomputed when the symbolization state of the
    /// profile changes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IsFolded {
      get { return isFolded_; }
      set {
        isFolded_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Location);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Location other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (MappingId != other.MappingId) return false;
      if (Address != other.Address) return false;
      if(!line_.Equals(other.line_)) return false;
      if (IsFolded != other.IsFolded) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id != 0UL) hash ^= Id.GetHashCode();
      if (MappingId != 0UL) hash ^= MappingId.GetHashCode();
      if (Address != 0UL) hash ^= Address.GetHashCode();
      hash ^= line_.GetHashCode();
      if (IsFolded != false) hash ^= IsFolded.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Id != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Id);
      }
      if (MappingId != 0UL) {
        output.WriteRawTag(16);
        output.WriteUInt64(MappingId);
      }
      if (Address != 0UL) {
        output.WriteRawTag(24);
        output.WriteUInt64(Address);
      }
      line_.WriteTo(output, _repeated_line_codec);
      if (IsFolded != false) {
        output.WriteRawTag(40);
        output.WriteBool(IsFolded);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Id);
      }
      if (MappingId != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(MappingId);
      }
      if (Address != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Address);
      }
      size += line_.CalculateSize(_repeated_line_codec);
      if (IsFolded != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Location other) {
      if (other == null) {
        return;
      }
      if (other.Id != 0UL) {
        Id = other.Id;
      }
      if (other.MappingId != 0UL) {
        MappingId = other.MappingId;
      }
      if (other.Address != 0UL) {
        Address = other.Address;
      }
      line_.Add(other.line_);
      if (other.IsFolded != false) {
        IsFolded = other.IsFolded;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadUInt64();
            break;
          }
          case 16: {
            MappingId = input.ReadUInt64();
            break;
          }
          case 24: {
            Address = input.ReadUInt64();
            break;
          }
          case 34: {
            line_.AddEntriesFrom(input, _repeated_line_codec);
            break;
          }
          case 40: {
            IsFolded = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  public sealed partial class Line : pb::IMessage<Line> {
    private static readonly pb::MessageParser<Line> _parser = new pb::MessageParser<Line>(() => new Line());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Line> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Perftools.Profiles.PprofReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Line() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Line(Line other) : this() {
      functionId_ = other.functionId_;
      line_ = other.line_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Line Clone() {
      return new Line(this);
    }

    /// <summary>Field number for the "function_id" field.</summary>
    public const int FunctionIdFieldNumber = 1;
    private ulong functionId_;
    /// <summary>
    /// The id of the corresponding profile.Function for this line.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong FunctionId {
      get { return functionId_; }
      set {
        functionId_ = value;
      }
    }

    /// <summary>Field number for the "line" field.</summary>
    public const int Line_FieldNumber = 2;
    private long line_;
    /// <summary>
    /// Line number in source code.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Line_ {
      get { return line_; }
      set {
        line_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Line);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Line other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (FunctionId != other.FunctionId) return false;
      if (Line_ != other.Line_) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (FunctionId != 0UL) hash ^= FunctionId.GetHashCode();
      if (Line_ != 0L) hash ^= Line_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (FunctionId != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(FunctionId);
      }
      if (Line_ != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Line_);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (FunctionId != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(FunctionId);
      }
      if (Line_ != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Line_);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Line other) {
      if (other == null) {
        return;
      }
      if (other.FunctionId != 0UL) {
        FunctionId = other.FunctionId;
      }
      if (other.Line_ != 0L) {
        Line_ = other.Line_;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            FunctionId = input.ReadUInt64();
            break;
          }
          case 16: {
            Line_ = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  public sealed partial class Function : pb::IMessage<Function> {
    private static readonly pb::MessageParser<Function> _parser = new pb::MessageParser<Function>(() => new Function());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Function> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Perftools.Profiles.PprofReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Function() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Function(Function other) : this() {
      id_ = other.id_;
      name_ = other.name_;
      systemName_ = other.systemName_;
      filename_ = other.filename_;
      startLine_ = other.startLine_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Function Clone() {
      return new Function(this);
    }

    /// <summary>Field number for the "id" field.</summary>
    public const int IdFieldNumber = 1;
    private ulong id_;
    /// <summary>
    /// Unique nonzero id for the function.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ulong Id {
      get { return id_; }
      set {
        id_ = value;
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private long name_;
    /// <summary>
    /// Name of the function, in human-readable form if available.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Name {
      get { return name_; }
      set {
        name_ = value;
      }
    }

    /// <summary>Field number for the "system_name" field.</summary>
    public const int SystemNameFieldNumber = 3;
    private long systemName_;
    /// <summary>
    /// Name of the function, as identified by the system.
    /// For instance, it can be a C++ mangled name.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long SystemName {
      get { return systemName_; }
      set {
        systemName_ = value;
      }
    }

    /// <summary>Field number for the "filename" field.</summary>
    public const int FilenameFieldNumber = 4;
    private long filename_;
    /// <summary>
    /// Source file containing the function.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long Filename {
      get { return filename_; }
      set {
        filename_ = value;
      }
    }

    /// <summary>Field number for the "start_line" field.</summary>
    public const int StartLineFieldNumber = 5;
    private long startLine_;
    /// <summary>
    /// Line number in source file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long StartLine {
      get { return startLine_; }
      set {
        startLine_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Function);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Function other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Id != other.Id) return false;
      if (Name != other.Name) return false;
      if (SystemName != other.SystemName) return false;
      if (Filename != other.Filename) return false;
      if (StartLine != other.StartLine) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Id != 0UL) hash ^= Id.GetHashCode();
      if (Name != 0L) hash ^= Name.GetHashCode();
      if (SystemName != 0L) hash ^= SystemName.GetHashCode();
      if (Filename != 0L) hash ^= Filename.GetHashCode();
      if (StartLine != 0L) hash ^= StartLine.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Id != 0UL) {
        output.WriteRawTag(8);
        output.WriteUInt64(Id);
      }
      if (Name != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(Name);
      }
      if (SystemName != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(SystemName);
      }
      if (Filename != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(Filename);
      }
      if (StartLine != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(StartLine);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Id != 0UL) {
        size += 1 + pb::CodedOutputStream.ComputeUInt64Size(Id);
      }
      if (Name != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Name);
      }
      if (SystemName != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(SystemName);
      }
      if (Filename != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(Filename);
      }
      if (StartLine != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(StartLine);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Function other) {
      if (other == null) {
        return;
      }
      if (other.Id != 0UL) {
        Id = other.Id;
      }
      if (other.Name != 0L) {
        Name = other.Name;
      }
      if (other.SystemName != 0L) {
        SystemName = other.SystemName;
      }
      if (other.Filename != 0L) {
        Filename = other.Filename;
      }
      if (other.StartLine != 0L) {
        StartLine = other.StartLine;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Id = input.ReadUInt64();
            break;
          }
          case 16: {
            Name = input.ReadInt64();
            break;
          }
          case 24: {
            SystemName = input.ReadInt64();
            break;
          }
          case 32: {
            Filename = input.ReadInt64();
            break;
          }
          case 40: {
            StartLine = input.ReadInt64();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
#pragma warning restore CS8981 // The type name only contains lower-cased ascii characters. Such names may become reserved for the language.
