// <copyright file="Sources.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Datadog.Trace.SourceGenerators.InstrumentationDefinitions
{
    internal static class Sources
    {
        public static string CreateCallTargetDefinitions(
            IReadOnlyCollection<CallTargetDefinitionSource> definitions)
        {
            var sb = new StringBuilder();
            sb.Append(@"// <auto-generated/>
#nullable enable

namespace Datadog.Trace.ClrProfiler
{
    internal static partial class InstrumentationDefinitions
    {
        private static NativeCallTargetDefinition[] GetDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {");

            var orderedDefinitions = definitions
                                    .OrderBy(static x => x.IntegrationName)
                                    .ThenBy(static x => x.AssemblyName)
                                    .ThenBy(static x => x.TargetTypeName)
                                    .ThenBy(static x => x.TargetMethodName)
                                    .ToList();

            string? integrationName = null;

            foreach (var definition in orderedDefinitions)
            {
                if (definition.IntegrationType != 0)
                {
                    // skip derived definitions
                    continue;
                }

                integrationName = WriteDefinition(definition, integrationName, sb);
            }

            sb.Append(@"
            };

        private static NativeCallTargetDefinition[] GetDerivedDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {");

            integrationName = null;
            foreach (var definition in orderedDefinitions)
            {
                if (definition.IntegrationType == 0)
                {
                    // only derived definitions
                    continue;
                }

                integrationName = WriteDefinition(definition, integrationName, sb);
            }

            sb.Append(@"
            };
    }
}
");

            return sb.ToString();
        }

        private static string WriteDefinition(CallTargetDefinitionSource definition, string? integrationName, StringBuilder sb)
        {
            if (definition.IntegrationName != integrationName)
            {
                if (integrationName is not null)
                {
                    sb.AppendLine();
                }

                integrationName = definition.IntegrationName;
                sb.Append(
                    $@"
                // {integrationName}");
            }

            sb.Append(
                   @"
                new(""")
              .Append(definition.AssemblyName)
              .Append(@""", """)
              .Append(definition.TargetTypeName)
              .Append(@""", """)
              .Append(definition.TargetMethodName)
              .Append(@""",  new[] { """)
              .Append(definition.TargetReturnType)
              .Append(@"""");

            if (definition.TargetParameterTypes is { Length: > 0 } types)
            {
                foreach (var parameterType in types)
                {
                    sb.Append(@", """)
                      .Append(parameterType)
                      .Append('"');
                }
            }

            var min = definition.MinimumVersion;
            var max = definition.MaximumVersion;
            sb.Append(" }, ")
              .Append(min.Major)
              .Append(", ")
              .Append(min.Minor)
              .Append(", ")
              .Append(min.Patch)
              .Append(", ")
              .Append(max.Major)
              .Append(", ")
              .Append(max.Minor)
              .Append(", ")
              .Append(max.Patch);

            sb.Append(@", assemblyFullName, """)
              .Append(definition.InstrumentationTypeName)
              .Append(@"""),");

            return integrationName;
        }
    }
}
