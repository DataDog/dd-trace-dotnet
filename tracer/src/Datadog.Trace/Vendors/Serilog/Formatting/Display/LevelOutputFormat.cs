//------------------------------------------------------------------------------
// <auto-generated />
// This file was automatically generated by the UpdateVendors tool.
//------------------------------------------------------------------------------
#pragma warning disable CS0618, CS0649, CS1574, CS1580, CS1581, CS1584, CS1591, CS1573, CS8018, SYSLIB0011, SYSLIB0032
#nullable enable
using global::System;
using global::System.Collections.Generic;
using global::System.IO;
using global::System.Linq;
#if !NETFRAMEWORK
using global::System.Net.Http;
#endif
using global::System.Threading;
using global::System.Threading.Tasks;
using System.Collections;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Text;
using System.Text.RegularExpressions;
using Datadog.Trace.Vendors.Serilog.Capturing;
using Datadog.Trace.Vendors.Serilog.Configuration;
using Datadog.Trace.Vendors.Serilog.Context;
using Datadog.Trace.Vendors.Serilog.Core;
using Datadog.Trace.Vendors.Serilog.Core.Enrichers;
using Datadog.Trace.Vendors.Serilog.Core.Filters;
using Datadog.Trace.Vendors.Serilog.Core.Pipeline;
using Datadog.Trace.Vendors.Serilog.Core.Sinks;
using Datadog.Trace.Vendors.Serilog.Data;
using Datadog.Trace.Vendors.Serilog.Debugging;
using Datadog.Trace.Vendors.Serilog.Events;
using Datadog.Trace.Vendors.Serilog.Formatting.Json;
using Datadog.Trace.Vendors.Serilog.Parsing;
using Datadog.Trace.Vendors.Serilog.Policies;
using Datadog.Trace.Vendors.Serilog.Rendering;
using Datadog.Trace.Vendors.Serilog.Settings.KeyValuePairs;
// Copyright 2017 Serilog Contributors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

namespace Datadog.Trace.Vendors.Serilog.Formatting.Display;

/// <summary>
/// Implements the {Level} element.
/// can now have a fixed width applied to it, as well as casing rules.
/// Width is set through formats like "u3" (uppercase three chars),
/// "w1" (one lowercase char), or "t4" (title case four chars).
/// </summary>
static class LevelOutputFormat
{
    static readonly string[][] _titleCaseLevelMap = {
        new []{ "V", "Vb", "Vrb", "Verb", "Verbo", "Verbos", "Verbose" },
        new []{ "D", "De", "Dbg", "Dbug", "Debug" },
        new []{ "I", "In", "Inf", "Info", "Infor", "Inform", "Informa", "Informat", "Informati", "Informatio", "Information" },
        new []{ "W", "Wn", "Wrn", "Warn", "Warni", "Warnin", "Warning" },
        new []{ "E", "Er", "Err", "Eror", "Error" },
        new []{ "F", "Fa", "Ftl", "Fatl", "Fatal" }
    };

    static readonly string[][] _lowerCaseLevelMap = {
        new []{ "v", "vb", "vrb", "verb", "verbo", "verbos", "verbose" },
        new []{ "d", "de", "dbg", "dbug", "debug" },
        new []{ "i", "in", "inf", "info", "infor", "inform", "informa", "informat", "informati", "informatio", "information" },
        new []{ "w", "wn", "wrn", "warn", "warni", "warnin", "warning" },
        new []{ "e", "er", "err", "eror", "error" },
        new []{ "f", "fa", "ftl", "fatl", "fatal" }
    };

    static readonly string[][] _upperCaseLevelMap = {
        new []{ "V", "VB", "VRB", "VERB", "VERBO", "VERBOS", "VERBOSE" },
        new []{ "D", "DE", "DBG", "DBUG", "DEBUG" },
        new []{ "I", "IN", "INF", "INFO", "INFOR", "INFORM", "INFORMA", "INFORMAT", "INFORMATI", "INFORMATIO", "INFORMATION" },
        new []{ "W", "WN", "WRN", "WARN", "WARNI", "WARNIN", "WARNING" },
        new []{ "E", "ER", "ERR", "EROR", "ERROR" },
        new []{ "F", "FA", "FTL", "FATL", "FATAL" }
    };

    public static string GetLevelMoniker(LogEventLevel value, string? format = null)
    {
        // handle unknown LogEventLevel
        if (value is < 0 or > LogEventLevel.Fatal)
            return Casing.Format(value.ToString(), format);

        if (format == null || format.Length != 2 && format.Length != 3)
            return Casing.Format(GetLevelMoniker(_titleCaseLevelMap, value), format);

        // Using int.Parse() here requires allocating a string to exclude the first character prefix.
        // Junk like "wxy" will be accepted but produce benign results.
        var width = format[1] - '0';
        if (format.Length == 3)
        {
            width *= 10;
            width += format[2] - '0';
        }

        if (width < 1)
            return string.Empty;

        return format[0] switch
        {
            'w' => GetLevelMoniker(_lowerCaseLevelMap, value, width),
            'u' => GetLevelMoniker(_upperCaseLevelMap, value, width),
            't' => GetLevelMoniker(_titleCaseLevelMap, value, width),
            _ => Casing.Format(GetLevelMoniker(_titleCaseLevelMap, value), format)
        };
    }

    static string GetLevelMoniker(string[][] caseLevelMap, LogEventLevel level, int width)
    {
        var caseLevel = caseLevelMap[(int)level];
        return caseLevel[Math.Min(width, caseLevel.Length) - 1];
    }

    static string GetLevelMoniker(string[][] caseLevelMap, LogEventLevel level)
    {
        var caseLevel = caseLevelMap[(int)level];
        return caseLevel[caseLevel.Length - 1];
    }
}
