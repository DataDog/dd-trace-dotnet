//------------------------------------------------------------------------------
// <auto-generated />
// This file was automatically generated by the UpdateVendors tool.
//------------------------------------------------------------------------------
#pragma warning disable CS0618, CS0649, CS1574, CS1580, CS1581, CS1584, CS1591, CS1573, CS8018, SYSLIB0011, SYSLIB0032
#pragma warning disable CS8600, CS8601, CS8602, CS8603, CS8604, CS8618, CS8620, CS8714, CS8762, CS8765, CS8766, CS8767, CS8768, CS8769, CS8612, CS8629, CS8774
#nullable enable
#if NETCOREAPP3_1_OR_GREATER
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.

using System;
using System.Diagnostics.CodeAnalysis;

namespace Datadog.Trace.Vendors.IndieSystem.Text.RegularExpressions
{
    internal static class ThrowHelper
    {
#if !NETFRAMEWORK && !NETSTANDARD
        [DoesNotReturn]
#endif
        internal static void ThrowArgumentNullException(ExceptionArgument arg) =>
            throw new ArgumentNullException(GetStringForExceptionArgument(arg));

#if !NETFRAMEWORK && !NETSTANDARD
        [DoesNotReturn]
#endif
        internal static void ThrowArgumentOutOfRangeException(ExceptionArgument arg) =>
            throw new ArgumentOutOfRangeException(GetStringForExceptionArgument(arg));

#if !NETFRAMEWORK && !NETSTANDARD
        [DoesNotReturn]
#endif
        internal static void ThrowArgumentOutOfRangeException(ExceptionArgument arg, ExceptionResource resource) =>
            throw new ArgumentOutOfRangeException(GetStringForExceptionArgument(arg), GetStringForExceptionResource(resource));

        private static string? GetStringForExceptionArgument(ExceptionArgument arg) =>
            arg switch
            {
                ExceptionArgument.assemblyname => nameof(ExceptionArgument.assemblyname),
                ExceptionArgument.array => nameof(ExceptionArgument.array),
                ExceptionArgument.arrayIndex => nameof(ExceptionArgument.arrayIndex),
                ExceptionArgument.count => nameof(ExceptionArgument.count),
                ExceptionArgument.evaluator => nameof(ExceptionArgument.evaluator),
                ExceptionArgument.i => nameof(ExceptionArgument.i),
                ExceptionArgument.inner => nameof(ExceptionArgument.inner),
                ExceptionArgument.input => nameof(ExceptionArgument.input),
                ExceptionArgument.length => nameof(ExceptionArgument.length),
                ExceptionArgument.matchTimeout => nameof(ExceptionArgument.matchTimeout),
                ExceptionArgument.name => nameof(ExceptionArgument.name),
                ExceptionArgument.options => nameof(ExceptionArgument.options),
                ExceptionArgument.pattern => nameof(ExceptionArgument.pattern),
                ExceptionArgument.replacement => nameof(ExceptionArgument.replacement),
                ExceptionArgument.startat => nameof(ExceptionArgument.startat),
                ExceptionArgument.str => nameof(ExceptionArgument.str),
                ExceptionArgument.value => nameof(ExceptionArgument.value),
                _ => null
            };

        private static string? GetStringForExceptionResource(ExceptionResource resource) =>
            resource switch
            {
                ExceptionResource.BeginIndexNotNegative => SR.BeginIndexNotNegative,
                ExceptionResource.CountTooSmall => SR.CountTooSmall,
                ExceptionResource.LengthNotNegative => SR.LengthNotNegative,
                _ => null
            };
    }

    internal enum ExceptionArgument
    {
        assemblyname,
        array,
        arrayIndex,
        count,
        evaluator,
        i,
        inner,
        input,
        length,
        matchTimeout,
        name,
        options,
        pattern,
        replacement,
        startat,
        str,
        value,
    }

    internal enum ExceptionResource
    {
        BeginIndexNotNegative,
        CountTooSmall,
        LengthNotNegative,
    }
}

#endif