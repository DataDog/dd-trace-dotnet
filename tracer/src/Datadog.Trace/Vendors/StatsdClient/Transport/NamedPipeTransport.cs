//------------------------------------------------------------------------------
// <auto-generated />
// This file was automatically generated by the UpdateVendors tool.
//------------------------------------------------------------------------------
#if NAMED_PIPE_AVAILABLE
using System;
using System.IO;
using System.IO.Pipes;
using System.Text;
using System.Threading;
using Datadog.Trace.Logging;
using Datadog.Trace.Vendors.StatsdClient.Bufferize;

namespace Datadog.Trace.Vendors.StatsdClient.Transport
{
    internal class NamedPipeTransport : ITransport
    {
        private static readonly IDatadogLogger Log = DatadogLogging.GetLoggerFor<NamedPipeTransport>();

        private static long Counter = 0;
        private static long Count = 0;

        private readonly NamedPipeClientStream _namedPipe;
        private readonly TimeSpan _timeout;
        private byte[] _internalbuffer = new byte[0];

        // `SpinLock` is a struct. A struct marked as `readonly` is copied each time a mutating function is called.
        // When calling `_lock.Enter` and `_lock.Exit()` the `SpinLock` instance is copied. Calling `_lock.Exit()` raises an
        // error as the instance does not hold the lock (System.Threading.SynchronizationLockException : The calling
        // thread does not hold the lock.)
        // For this reason, `_lock` is not marked as `readonly`
        private SpinLock _lock = new SpinLock(enableThreadOwnerTracking: true);

        public NamedPipeTransport(string pipeName, TimeSpan? timeout = null)
        {
            _namedPipe = new NamedPipeClientStream(".", pipeName, PipeDirection.Out, PipeOptions.Asynchronous);
            _timeout = timeout ?? TimeSpan.FromSeconds(2);
        }

        public TransportType TransportType => TransportType.NamedPipe;

        public string TelemetryClientTransport => "named_pipe";

        public bool Send(byte[] buffer, int length)
        {
            var content = Encoding.UTF8.GetString(buffer, 0, length);

            var token = Interlocked.Increment(ref Counter);
            var waiters = Interlocked.Increment(ref Count);

            Log.Information("Namedpipe transport send {Counter} - waiters {Count}: {Content}", token, waiters, content);
            var gotLock = false;
            try
            {
                _lock.Enter(ref gotLock);

                waiters = Interlocked.Decrement(ref Count);

                Log.Information("Namedpipe transport lock acquired {Counter} - remaining waiters: {Count}", token, waiters);

                if (_internalbuffer.Length < length + 1)
                {
                    _internalbuffer = new byte[length + 1];
                }

                // Server expects messages to end with '\n'
                Array.Copy(buffer, 0, _internalbuffer, 0, length);
                _internalbuffer[length] = (byte)'\n';

                return SendBuffer(_internalbuffer, length + 1, allowRetry: true);
            }
            finally
            {
                if (gotLock)
                {
                    _lock.Exit();
                }
            }
        }

        public void Dispose()
        {
            _namedPipe.Dispose();
        }

        private bool SendBuffer(byte[] buffer, int length, bool allowRetry)
        {
            try
            {
                if (!_namedPipe.IsConnected)
                {
                    Log.Information("Connecting to named pipe");
                    _namedPipe.Connect((int)_timeout.TotalMilliseconds);
                }
            }
            catch (TimeoutException)
            {
                return false;
            }

            var cts = new CancellationTokenSource(_timeout);

            try
            {
                // WriteAsync overload with a CancellationToken instance seems to not work.
                _namedPipe.WriteAsync(buffer, 0, length).Wait(cts.Token);
                Log.Information("Written");
                return true;
            }
            catch (OperationCanceledException ex)
            {
                Log.Warning(ex, "OperatioNCanceledException in NamedPipeTransport");

                return false;
            }
            catch (IOException ex)
            {
                // When the server disconnects, IOException is raised with the message "Pipe is broken".
                // In this case, we try to reconnect once.
                if (allowRetry)
                {
                    Log.Warning(ex, "IOException in NamedPipeTransport, retrying");
                    return SendBuffer(buffer, length, allowRetry: false);
                }

                Log.Warning(ex, "IOException in NamedPipeTransport, giving up");

                return false;
            }
        }
    }
}
#endif
