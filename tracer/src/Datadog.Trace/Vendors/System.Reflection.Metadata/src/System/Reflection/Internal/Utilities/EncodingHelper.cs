//------------------------------------------------------------------------------
// <auto-generated />
// This file was automatically generated by the UpdateVendors tool.
//------------------------------------------------------------------------------
#pragma warning disable CS0618, CS0649, CS1574, CS1580, CS1581, CS1584, CS1591, CS1573, CS8018, SYSLIB0011, SYSLIB0032
#pragma warning disable CS8600, CS8601, CS8602, CS8603, CS8604, CS8618, CS8620, CS8714, CS8762, CS8765, CS8766, CS8767, CS8768, CS8769, CS8612, CS8629, CS8774
// Decompiled with JetBrains decompiler
// Type: System.Reflection.Internal.EncodingHelper
// Assembly: System.Reflection.Metadata, Version=7.0.0.2, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: 2EB35F4B-CF50-496F-AFB8-CC6F6F79CB72

using System;
using System.Runtime.InteropServices;
using Datadog.Trace.VendoredMicrosoftCode.System.Reflection.Metadata;


#nullable enable
namespace Datadog.Trace.VendoredMicrosoftCode.System.Reflection.Internal
{
    /// <summary>
    /// Provides helpers to decode strings from unmanaged memory to System.String while avoiding
    /// intermediate allocation.
    /// </summary>
    internal static class EncodingHelper
  {
    public const int PooledBufferSize = 200;

    #nullable disable
    private static readonly ObjectPool<byte[]> s_pool = new ObjectPool<byte[]>((Func<byte[]>) (() => new byte[200]));


    #nullable enable
    public static unsafe string DecodeUtf8(
      byte* bytes,
      int byteCount,
      byte[] prefix,
      MetadataStringDecoder utf8Decoder)
    {
      if (prefix != null)
        return EncodingHelper.DecodeUtf8Prefixed(bytes, byteCount, prefix, utf8Decoder);
      return byteCount == 0 ? string.Empty : utf8Decoder.GetString(bytes, byteCount);
    }


    #nullable disable
    private static unsafe string DecodeUtf8Prefixed(
      byte* bytes,
      int byteCount,
      byte[] prefix,
      MetadataStringDecoder utf8Decoder)
    {
      int byteCount1 = byteCount + prefix.Length;
      if (byteCount1 == 0)
        return string.Empty;
      byte[] numArray = EncodingHelper.AcquireBuffer(byteCount1);
      prefix.CopyTo((Array) numArray, 0);
      Marshal.Copy((IntPtr) (void*) bytes, numArray, prefix.Length, byteCount);
      string str;
      fixed (byte* bytes1 = &numArray[0])
        str = utf8Decoder.GetString(bytes1, byteCount1);
      EncodingHelper.ReleaseBuffer(numArray);
      return str;
    }

    private static byte[] AcquireBuffer(int byteCount) => byteCount > 200 ? new byte[byteCount] : EncodingHelper.s_pool.Allocate();

    private static void ReleaseBuffer(byte[] buffer)
    {
      if (buffer.Length != 200)
        return;
      EncodingHelper.s_pool.Free(buffer);
    }
  }
}
