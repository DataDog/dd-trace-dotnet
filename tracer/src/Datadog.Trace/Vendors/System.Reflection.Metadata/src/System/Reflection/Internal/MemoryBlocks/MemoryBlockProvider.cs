//------------------------------------------------------------------------------
// <auto-generated />
// This file was automatically generated by the UpdateVendors tool.
//------------------------------------------------------------------------------
#pragma warning disable CS0618, CS0649, CS1574, CS1580, CS1581, CS1584, CS1591, CS1573, CS8018, SYSLIB0011, SYSLIB0032
#pragma warning disable CS8600, CS8601, CS8602, CS8603, CS8604, CS8618, CS8620, CS8714, CS8762, CS8765, CS8766, CS8767, CS8768, CS8769, CS8612, CS8629, CS8774
// Decompiled with JetBrains decompiler
// Type: System.Reflection.Internal.MemoryBlockProvider
// Assembly: System.Reflection.Metadata, Version=7.0.0.2, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a
// MVID: 2EB35F4B-CF50-496F-AFB8-CC6F6F79CB72

using System;
using System.IO;
using System.Reflection;

#nullable enable
namespace Datadog.Trace.VendoredMicrosoftCode.System.Reflection.Internal
{
    internal abstract class MemoryBlockProvider : IDisposable
  {
    /// <summary>
    /// Creates and hydrates a memory block representing all data.
    /// </summary>
    /// <exception cref="T:System.IO.IOException">Error while reading from the memory source.</exception>
    public AbstractMemoryBlock GetMemoryBlock() => this.GetMemoryBlockImpl(0, this.Size);

    /// <summary>
    /// Creates and hydrates a memory block representing data in the specified range.
    /// </summary>
    /// <param name="start">Starting offset relative to the beginning of the data represented by this provider.</param>
    /// <param name="size">Size of the resulting block.</param>
    /// <exception cref="T:System.IO.IOException">Error while reading from the memory source.</exception>
    public AbstractMemoryBlock GetMemoryBlock(int start, int size)
    {
      if ((ulong) (uint) start + (ulong) (uint) size > (ulong) this.Size)
        Throw.ImageTooSmallOrContainsInvalidOffsetOrCount();
      return this.GetMemoryBlockImpl(start, size);
    }

    /// <exception cref="T:System.IO.IOException">IO error while reading from the underlying stream.</exception>
    protected abstract AbstractMemoryBlock GetMemoryBlockImpl(int start, int size);

    /// <summary>
    /// Gets a seekable and readable <see cref="T:System.IO.Stream" /> that can be used to read all data.
    /// The operations on the stream has to be done under a lock of <see cref="F:System.Reflection.Internal.StreamConstraints.GuardOpt" /> if non-null.
    /// The image starts at <see cref="F:System.Reflection.Internal.StreamConstraints.ImageStart" /> and has size <see cref="F:System.Reflection.Internal.StreamConstraints.ImageSize" />.
    /// It is the caller's responsibility not to read outside those bounds.
    /// </summary>
    public abstract Stream GetStream(out StreamConstraints constraints);

    /// <summary>The size of the data.</summary>
    public abstract int Size { get; }

    protected abstract void Dispose(bool disposing);

    public void Dispose()
    {
      this.Dispose(true);
      GC.SuppressFinalize((object) this);
    }
  }
}
