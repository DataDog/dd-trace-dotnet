//------------------------------------------------------------------------------
// <auto-generated />
// This file was automatically generated by the UpdateVendors tool.
//------------------------------------------------------------------------------
#pragma warning disable CS0618, CS0649, CS1574, CS1580, CS1581, CS1584, CS1591, CS1573, CS8018, SYSLIB0011, SYSLIB0032
#pragma warning disable CS8600, CS8601, CS8602, CS8603, CS8604, CS8618, CS8620, CS8714, CS8762, CS8765, CS8766, CS8767, CS8768, CS8769, CS8612, CS8629, CS8774
#nullable enable
// Decompiled with JetBrains decompiler
// Type: System.Buffers.ArrayMemoryPool`1
// Assembly: System.Memory, Version=4.0.1.2, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51
// MVID: 805945F3-27B0-47AD-B8F6-389D9D8F82C3

using System;
using Datadog.Trace.VendoredMicrosoftCode.System.Runtime.CompilerServices.Unsafe;
#pragma warning disable CS8625

namespace Datadog.Trace.VendoredMicrosoftCode.System.Buffers
{
    internal sealed class ArrayMemoryPool<T> : MemoryPool<T>
  {
    private const int s_maxBufferSize = 2147483647;

    public override sealed int MaxBufferSize => int.MaxValue;

    public override sealed IMemoryOwner<T> Rent(int minimumBufferSize = -1)
    {
      if (minimumBufferSize == -1)
        minimumBufferSize = 1 + 4095 / Unsafe.SizeOf<T>();
      else if ((uint) minimumBufferSize > (uint) int.MaxValue)
        ThrowHelper.ThrowArgumentOutOfRangeException(ExceptionArgument.minimumBufferSize);
      return (IMemoryOwner<T>) new ArrayMemoryPool<T>.ArrayMemoryPoolBuffer(minimumBufferSize);
    }

    protected override sealed void Dispose(bool disposing)
    {
    }

    private sealed class ArrayMemoryPoolBuffer : IMemoryOwner<T>, IDisposable
    {
      private T[] _array;

      public ArrayMemoryPoolBuffer(int size) => this._array = ArrayPool<T>.Shared.Rent(size);

      public Memory<T> Memory
      {
        get
        {
          T[] array = this._array;
          if (array == null)
            ThrowHelper.ThrowObjectDisposedException_ArrayMemoryPoolBuffer();
          return new Memory<T>(array);
        }
      }

      public void Dispose()
      {
        T[] array = this._array;
        if (array == null)
          return;
        this._array = (T[]) null;
        ArrayPool<T>.Shared.Return(array, false);
      }
    }
  }
}
