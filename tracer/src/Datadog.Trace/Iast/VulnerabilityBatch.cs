// <copyright file="VulnerabilityBatch.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

#nullable enable

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using Datadog.Trace.AppSec.Rasp;
using Datadog.Trace.Iast.SensitiveData;
using Datadog.Trace.Iast.Settings;
using Datadog.Trace.Logging;
using Datadog.Trace.Util.Http;
using Datadog.Trace.Vendors.dnlib;
using Datadog.Trace.Vendors.Newtonsoft.Json;
using Datadog.Trace.Vendors.Newtonsoft.Json.Serialization;

namespace Datadog.Trace.Iast;

internal class VulnerabilityBatch
{
    private const int MaxSpanTagSize = 25000; // In bytes
    private static readonly IDatadogLogger Log = DatadogLogging.GetLoggerFor(typeof(VulnerabilityBatch));

    private static JsonSerializerSettings? _defaultSettings = null;
    private static JsonSerializerSettings? _redactionSettings = null;
    private static Lazy<JsonSerializerSettings> _truncatedSettings = new(() => CreateTruncatedSettings());

    private readonly int _truncationMaxValueLength;
    private EvidenceRedactor? _evidenceRedactor;
    private JsonSerializerSettings _serializerSettings;
    private string? _vulnerabilitiesJson;
    private bool _isTruncated;

    public VulnerabilityBatch(int truncationMaxValueLength = IastSettings.TruncationMaxValueLengthDefault, EvidenceRedactor? evidenceRedactor = null)
    {
        _evidenceRedactor = evidenceRedactor;
        _truncationMaxValueLength = truncationMaxValueLength;
        if (_evidenceRedactor is null)
        {
            _defaultSettings ??= CreateSerializerSettings(truncationMaxValueLength, false);
            _serializerSettings = _defaultSettings;
        }
        else
        {
            _redactionSettings ??= CreateSerializerSettings(truncationMaxValueLength, true);
            _serializerSettings = _redactionSettings;
        }
    }

    public List<Vulnerability> Vulnerabilities { get; } = new List<Vulnerability>();

    public List<Source>? Sources { get; private set; } = null;

    public bool IsTruncated() => _isTruncated;

    public bool IsRedactionEnabled() => _evidenceRedactor != null;

    public int GetTruncationMaxValueLength() => _truncationMaxValueLength;

    internal static JsonSerializerSettings CreateSerializerSettings(int truncationMaxValueLength, bool redacted)
    {
        List<JsonConverter> converters = [new SourceJsonConverter(truncationMaxValueLength), new EvidenceJsonConverter(truncationMaxValueLength, redacted)];
        return new JsonSerializerSettings()
        {
            NullValueHandling = NullValueHandling.Ignore,
            ContractResolver = new CamelCasePropertyNamesContractResolver(),
            Converters = converters
        };
    }

    private static JsonSerializerSettings CreateTruncatedSettings()
    {
        List<JsonConverter> converters = [new TruncatedVulnerabilities.VulnerabilityConverter(), new TruncatedVulnerabilities.EvidenceConverter()];

        return new JsonSerializerSettings()
        {
            NullValueHandling = NullValueHandling.Ignore,
            ContractResolver = new CamelCasePropertyNamesContractResolver(),
            Converters = converters
        };
    }

    public void Add(Vulnerability vulnerability)
    {
        _vulnerabilitiesJson = null;
        var ranges = vulnerability.Evidence?.Ranges;

        if (ranges != null)
        {
            foreach (var range in ranges)
            {
                if (Sources is null)
                {
                    Sources = new List<Source>();
                }

                if (range.Source != null && !Sources.Contains(range.Source))
                {
                    range.Source.SetInternalId(Sources.Count);
                    Sources.Add(range.Source);
                }
            }
        }

        Vulnerabilities.Add(vulnerability);
    }

    public string ToJson()
    {
        try
        {
            if (_vulnerabilitiesJson == null)
            {
                if (_evidenceRedactor == null)
                {
                    _vulnerabilitiesJson = JsonConvert.SerializeObject(this, Formatting.Indented, _serializerSettings);
                }
                else
                {
                    if (Sources != null)
                    {
                        foreach (var source in Sources)
                        {
                            _evidenceRedactor.Process(source);
                        }
                    }

                    for (int x = 0; x < Vulnerabilities.Count; x++)
                    {
                        Vulnerabilities[x] = _evidenceRedactor.RedactVulnerability(Vulnerabilities[x]);
                    }

                    _vulnerabilitiesJson = JsonConvert.SerializeObject(this, Formatting.Indented, _serializerSettings);
                }

                if (System.Text.ASCIIEncoding.Unicode.GetByteCount(_vulnerabilitiesJson) > MaxSpanTagSize)
                {
                    _vulnerabilitiesJson = ToTruncatedJson();
                    _isTruncated = true;
                }
            }

            return _vulnerabilitiesJson;
        }
        catch (Exception ex)
        {
            Log.Error(ex, $"Error in {nameof(VulnerabilityBatch)}.{nameof(ToJson)}");
            return string.Empty;
        }
    }

    public byte[] ToMessagePack()
    {
        try
        {
            byte[] result;
            Dictionary<string, object> toSerialize;

            if (_evidenceRedactor == null)
            {
                toSerialize = MetaStructHelper.VulnerabilityBatchToDictionary(this);
                result = MetaStructHelper.ObjectToByteArray(toSerialize);
            }
            else
            {
                if (Sources != null)
                {
                    foreach (var source in Sources)
                    {
                        _evidenceRedactor.Process(source);
                    }
                }

                for (var x = 0; x < Vulnerabilities.Count; x++)
                {
                    Vulnerabilities[x] = _evidenceRedactor.RedactVulnerability(Vulnerabilities[x]);
                }

                toSerialize = MetaStructHelper.VulnerabilityBatchToDictionary(this);
                result = MetaStructHelper.ObjectToByteArray(toSerialize);
            }

            if (result.Length > MaxSpanTagSize)
            {
                result = ToTruncatedMessagePack(toSerialize);
                _isTruncated = true;
            }

            return result;
        }
        catch (Exception ex)
        {
            Log.Error(ex, $"Error in {nameof(VulnerabilityBatch)}.{nameof(ToMessagePack)}");
            return [];
        }
    }

    internal string ToTruncatedJson()
    {
        return JsonConvert.SerializeObject(new TruncatedVulnerabilities(Vulnerabilities), Formatting.Indented, _truncatedSettings.Value);
    }

    internal byte[] ToTruncatedMessagePack(Dictionary<string, object> vulnerabilityBatchDictionary)
    {
        if (vulnerabilityBatchDictionary["vulnerabilities"] is List<Dictionary<string, object>> vulnerabilities)
        {
            foreach (var vulnerability in vulnerabilities)
            {
                if (vulnerability["evidence"] is Dictionary<string, object> evidence)
                {
                    evidence.Clear();
                    evidence["value"] = TruncatedVulnerabilities.MaxSizeExceeded;
                }
            }
        }

        vulnerabilityBatchDictionary.Remove("sources");

        return MetaStructHelper.ObjectToByteArray(vulnerabilityBatchDictionary);
    }

    public override string ToString()
    {
        return ToJson();
    }
}
