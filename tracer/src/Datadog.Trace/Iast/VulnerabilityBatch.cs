// <copyright file="VulnerabilityBatch.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

#nullable enable

using System;
using System.Collections.Generic;
using Datadog.Trace.AppSec.Rasp;
using Datadog.Trace.Iast.SensitiveData;
using Datadog.Trace.Iast.Settings;
using Datadog.Trace.Logging;
using Datadog.Trace.Util.Json;
using Datadog.Trace.Vendors.Newtonsoft.Json;
using Datadog.Trace.Vendors.Newtonsoft.Json.Serialization;

namespace Datadog.Trace.Iast;

internal sealed class VulnerabilityBatch
{
    private const int MaxSpanTagSize = 25000; // In bytes
    private static readonly IDatadogLogger Log = DatadogLogging.GetLoggerFor(typeof(VulnerabilityBatch));

    private static JsonSerializerSettings? _defaultSettings = null;
    private static JsonSerializerSettings? _redactionSettings = null;
    private static Lazy<JsonSerializerSettings> _truncatedSettings = new(() => CreateTruncatedSettings());

    private readonly int _truncationMaxValueLength;
    private readonly List<Vulnerability> _vulnerabilities = new List<Vulnerability>();
    private List<Source>? _sources = null;
    private EvidenceRedactor? _evidenceRedactor;
    private JsonSerializerSettings _serializerSettings;
    private string? _vulnerabilitiesJson;
    private bool _isTruncated;

    public VulnerabilityBatch(int truncationMaxValueLength = IastSettings.TruncationMaxValueLengthDefault, EvidenceRedactor? evidenceRedactor = null)
    {
        _evidenceRedactor = evidenceRedactor;
        _truncationMaxValueLength = truncationMaxValueLength;
        if (_evidenceRedactor is null)
        {
            _defaultSettings ??= CreateSerializerSettings(truncationMaxValueLength, false);
            _serializerSettings = _defaultSettings;
        }
        else
        {
            _redactionSettings ??= CreateSerializerSettings(truncationMaxValueLength, true);
            _serializerSettings = _redactionSettings;
        }
    }

    public ICollection<Vulnerability> Vulnerabilities => _vulnerabilities;

    public ICollection<Source>? Sources => _sources;

    public bool IsTruncated() => _isTruncated;

    public bool IsRedactionEnabled() => _evidenceRedactor != null;

    public int GetTruncationMaxValueLength() => _truncationMaxValueLength;

    internal static JsonSerializerSettings CreateSerializerSettings(int truncationMaxValueLength, bool redacted)
    {
        List<JsonConverter> converters = [new SourceJsonConverter(truncationMaxValueLength), new EvidenceJsonConverter(truncationMaxValueLength, redacted)];
        return new JsonSerializerSettings()
        {
            NullValueHandling = NullValueHandling.Ignore,
            ContractResolver = new CamelCasePropertyNamesContractResolver(),
            Converters = converters
        };
    }

    private static JsonSerializerSettings CreateTruncatedSettings()
    {
        List<JsonConverter> converters = [new TruncatedVulnerabilities.VulnerabilityConverter(), new TruncatedVulnerabilities.EvidenceConverter()];

        return new JsonSerializerSettings()
        {
            NullValueHandling = NullValueHandling.Ignore,
            ContractResolver = new CamelCasePropertyNamesContractResolver(),
            Converters = converters
        };
    }

    public void Add(Vulnerability vulnerability)
    {
        lock (_vulnerabilities)
        {
            _vulnerabilitiesJson = null;
            var ranges = vulnerability.Evidence?.Ranges;

            if (ranges != null)
            {
                foreach (var range in ranges)
                {
                    if (Sources is null)
                    {
                        _sources = new List<Source>();
                    }

                    if (range.Source != null && _sources is not null && !_sources.Contains(range.Source))
                    {
                        range.Source.SetInternalId(_sources.Count);
                        _sources.Add(range.Source);
                    }
                }
            }

            _vulnerabilities.Add(vulnerability);
        }
    }

    public string ToJson()
    {
        try
        {
            if (_vulnerabilitiesJson == null)
            {
                lock (_vulnerabilities)
                {
                    if (_evidenceRedactor == null)
                    {
                        _vulnerabilitiesJson = JsonHelper.SerializeObject(this, Formatting.Indented, _serializerSettings);
                    }
                    else
                    {
                        if (Sources != null)
                        {
                            foreach (var source in Sources)
                            {
                                _evidenceRedactor.Process(source);
                            }
                        }

                        for (int x = 0; x < _vulnerabilities.Count; x++)
                        {
                            _vulnerabilities[x] = _evidenceRedactor.RedactVulnerability(_vulnerabilities[x]);
                        }

                        _vulnerabilitiesJson = JsonHelper.SerializeObject(this, Formatting.Indented, _serializerSettings);
                    }

                    if (System.Text.ASCIIEncoding.Unicode.GetByteCount(_vulnerabilitiesJson) > MaxSpanTagSize)
                    {
                        _vulnerabilitiesJson = ToTruncatedJson();
                        _isTruncated = true;
                    }
                }
            }

            return _vulnerabilitiesJson;
        }
        catch (Exception ex)
        {
            Log.Error(ex, $"Error in {nameof(VulnerabilityBatch)}.{nameof(ToJson)}");
            return string.Empty;
        }
    }

    public byte[] ToMessagePack()
    {
        try
        {
            lock (_vulnerabilities)
            {
                byte[] result;
                Dictionary<string, object> toSerialize;

                if (_evidenceRedactor == null)
                {
                    toSerialize = MetaStructHelper.VulnerabilityBatchToDictionary(this);
                    result = MetaStructHelper.ObjectToByteArray(toSerialize);
                }
                else
                {
                    if (Sources != null)
                    {
                        foreach (var source in Sources)
                        {
                            _evidenceRedactor.Process(source);
                        }
                    }

                    for (var x = 0; x < _vulnerabilities.Count; x++)
                    {
                        _vulnerabilities[x] = _evidenceRedactor.RedactVulnerability(_vulnerabilities[x]);
                    }

                    toSerialize = MetaStructHelper.VulnerabilityBatchToDictionary(this);
                    result = MetaStructHelper.ObjectToByteArray(toSerialize);
                }

                if (result.Length > MaxSpanTagSize)
                {
                    result = ToTruncatedMessagePack(toSerialize);
                    _isTruncated = true;
                }

                return result;
            }
        }
        catch (Exception ex)
        {
            Log.Error(ex, $"Error in {nameof(VulnerabilityBatch)}.{nameof(ToMessagePack)}");
            return [];
        }
    }

    internal string ToTruncatedJson()
    {
        lock (_vulnerabilities)
        {
            return JsonHelper.SerializeObject(new TruncatedVulnerabilities(_vulnerabilities), Formatting.Indented, _truncatedSettings.Value);
        }
    }

    internal byte[] ToTruncatedMessagePack(Dictionary<string, object> vulnerabilityBatchDictionary)
    {
        lock (_vulnerabilities)
        {
            if (vulnerabilityBatchDictionary["vulnerabilities"] is List<Dictionary<string, object>> vulnerabilities)
            {
                foreach (var vulnerability in vulnerabilities)
                {
                    if (vulnerability["evidence"] is Dictionary<string, object> evidence)
                    {
                        evidence.Clear();
                        evidence["value"] = TruncatedVulnerabilities.MaxSizeExceeded;
                    }
                }
            }

            vulnerabilityBatchDictionary.Remove("sources");

            return MetaStructHelper.ObjectToByteArray(vulnerabilityBatchDictionary);
        }
    }

    public override string ToString()
    {
        return ToJson();
    }
}
