// <copyright file="VulnerabilityBatch.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

#nullable enable

using System.Collections.Generic;
using System.IO;
using System.Text;
using Datadog.Trace.Iast.SensitiveData;
using Datadog.Trace.Util.Http;
using Datadog.Trace.Vendors.Newtonsoft.Json;
using Datadog.Trace.Vendors.Newtonsoft.Json.Serialization;

namespace Datadog.Trace.Iast;

internal class VulnerabilityBatch
{
    private static JsonSerializerSettings _defaultSettings = new JsonSerializerSettings()
    {
        NullValueHandling = NullValueHandling.Ignore,
        ContractResolver = new CamelCasePropertyNamesContractResolver(),
        Converters = new List<JsonConverter> { new SourceConverter(), new EvidenceConverter(false) }
    };

    private static JsonSerializerSettings _redactionSettings = new JsonSerializerSettings()
    {
        NullValueHandling = NullValueHandling.Ignore,
        ContractResolver = new CamelCasePropertyNamesContractResolver(),
        Converters = new List<JsonConverter> { new SourceConverter(), new EvidenceConverter(true) }
    };

    private EvidenceRedactor? _evidenceRedactor;
    private JsonSerializerSettings _serializerSettings;
    private string? _vulnerabilitiesJson;

    public VulnerabilityBatch(EvidenceRedactor? evidenceRedactor = null)
    {
        _evidenceRedactor = evidenceRedactor;
        _serializerSettings = _evidenceRedactor != null ? _redactionSettings : _defaultSettings;
    }

    internal static JsonSerializerSettings JsonRedactionSettings => _redactionSettings;

    public List<Vulnerability> Vulnerabilities { get; } = new List<Vulnerability>();

    public List<Source>? Sources { get; private set; } = null;

    public void Add(Vulnerability vulnerability)
    {
        _vulnerabilitiesJson = null;
        var ranges = vulnerability.Evidence?.Ranges;

        if (ranges != null)
        {
            foreach (var range in ranges)
            {
                if (Sources is null)
                {
                    Sources = new List<Source>();
                }

                if (range.Source != null && !Sources.Contains(range.Source))
                {
                    range.Source.SetInternalId(Sources.Count);
                    Sources.Add(range.Source);
                }
            }
        }

        Vulnerabilities.Add(vulnerability);
    }

    public string ToJson()
    {
        if (_vulnerabilitiesJson == null)
        {
            if (_evidenceRedactor == null)
            {
                _vulnerabilitiesJson = JsonConvert.SerializeObject(this, Formatting.Indented, _serializerSettings);
            }
            else
            {
                if (Sources != null)
                {
                    foreach (var source in Sources)
                    {
                        _evidenceRedactor.Process(source);
                    }
                }

                for (int x = 0; x < Vulnerabilities.Count; x++)
                {
                    Vulnerabilities[x] = _evidenceRedactor.RedactVulnerability(Vulnerabilities[x]);
                }

                _vulnerabilitiesJson = JsonConvert.SerializeObject(this, Formatting.Indented, _serializerSettings);
            }
        }

        return _vulnerabilitiesJson;
    }

    public override string ToString()
    {
        return ToJson();
    }
}
