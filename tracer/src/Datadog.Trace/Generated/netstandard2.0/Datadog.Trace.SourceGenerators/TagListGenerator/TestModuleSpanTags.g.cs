// <copyright company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>
// <auto-generated/>

#nullable enable

using Datadog.Trace.Processors;
using Datadog.Trace.Tagging;
using System;

namespace Datadog.Trace.Ci.Tagging
{
    partial class TestModuleSpanTags
    {
        // IntelligentTestRunnerSkippingCountBytes = MessagePack.Serialize("test.itr.tests_skipping.count");
        private static ReadOnlySpan<byte> IntelligentTestRunnerSkippingCountBytes => new byte[] { 189, 116, 101, 115, 116, 46, 105, 116, 114, 46, 116, 101, 115, 116, 115, 95, 115, 107, 105, 112, 112, 105, 110, 103, 46, 99, 111, 117, 110, 116 };
        // TypeBytes = MessagePack.Serialize("test.type");
        private static ReadOnlySpan<byte> TypeBytes => new byte[] { 169, 116, 101, 115, 116, 46, 116, 121, 112, 101 };
        // ModuleBytes = MessagePack.Serialize("test.module");
        private static ReadOnlySpan<byte> ModuleBytes => new byte[] { 171, 116, 101, 115, 116, 46, 109, 111, 100, 117, 108, 101 };
        // BundleBytes = MessagePack.Serialize("test.bundle");
        private static ReadOnlySpan<byte> BundleBytes => new byte[] { 171, 116, 101, 115, 116, 46, 98, 117, 110, 100, 108, 101 };
        // FrameworkBytes = MessagePack.Serialize("test.framework");
        private static ReadOnlySpan<byte> FrameworkBytes => new byte[] { 174, 116, 101, 115, 116, 46, 102, 114, 97, 109, 101, 119, 111, 114, 107 };
        // FrameworkVersionBytes = MessagePack.Serialize("test.framework_version");
        private static ReadOnlySpan<byte> FrameworkVersionBytes => new byte[] { 182, 116, 101, 115, 116, 46, 102, 114, 97, 109, 101, 119, 111, 114, 107, 95, 118, 101, 114, 115, 105, 111, 110 };
        // RuntimeNameBytes = MessagePack.Serialize("runtime.name");
        private static ReadOnlySpan<byte> RuntimeNameBytes => new byte[] { 172, 114, 117, 110, 116, 105, 109, 101, 46, 110, 97, 109, 101 };
        // RuntimeVersionBytes = MessagePack.Serialize("runtime.version");
        private static ReadOnlySpan<byte> RuntimeVersionBytes => new byte[] { 175, 114, 117, 110, 116, 105, 109, 101, 46, 118, 101, 114, 115, 105, 111, 110 };
        // RuntimeArchitectureBytes = MessagePack.Serialize("runtime.architecture");
        private static ReadOnlySpan<byte> RuntimeArchitectureBytes => new byte[] { 180, 114, 117, 110, 116, 105, 109, 101, 46, 97, 114, 99, 104, 105, 116, 101, 99, 116, 117, 114, 101 };
        // OSArchitectureBytes = MessagePack.Serialize("os.architecture");
        private static ReadOnlySpan<byte> OSArchitectureBytes => new byte[] { 175, 111, 115, 46, 97, 114, 99, 104, 105, 116, 101, 99, 116, 117, 114, 101 };
        // OSPlatformBytes = MessagePack.Serialize("os.platform");
        private static ReadOnlySpan<byte> OSPlatformBytes => new byte[] { 171, 111, 115, 46, 112, 108, 97, 116, 102, 111, 114, 109 };
        // OSVersionBytes = MessagePack.Serialize("os.version");
        private static ReadOnlySpan<byte> OSVersionBytes => new byte[] { 170, 111, 115, 46, 118, 101, 114, 115, 105, 111, 110 };

        public override string? GetTag(string key)
        {
            return key switch
            {
                "test.type" => Type,
                "test.module" => Module,
                "test.bundle" => Bundle,
                "test.framework" => Framework,
                "test.framework_version" => FrameworkVersion,
                "runtime.name" => RuntimeName,
                "runtime.version" => RuntimeVersion,
                "runtime.architecture" => RuntimeArchitecture,
                "os.architecture" => OSArchitecture,
                "os.platform" => OSPlatform,
                "os.version" => OSVersion,
                _ => base.GetTag(key),
            };
        }

        public override void SetTag(string key, string value)
        {
            switch(key)
            {
                case "test.type": 
                    Type = value;
                    break;
                case "test.module": 
                    Module = value;
                    break;
                case "test.framework": 
                    Framework = value;
                    break;
                case "test.framework_version": 
                    FrameworkVersion = value;
                    break;
                case "runtime.name": 
                    RuntimeName = value;
                    break;
                case "runtime.version": 
                    RuntimeVersion = value;
                    break;
                case "runtime.architecture": 
                    RuntimeArchitecture = value;
                    break;
                case "os.architecture": 
                    OSArchitecture = value;
                    break;
                case "os.platform": 
                    OSPlatform = value;
                    break;
                case "os.version": 
                    OSVersion = value;
                    break;
                case "test.bundle": 
                    Logger.Value.Warning("Attempted to set readonly tag {TagName} on {TagType}. Ignoring.", key, nameof(TestModuleSpanTags));
                    break;
                default: 
                    base.SetTag(key, value);
                    break;
            }
        }

        public override void EnumerateTags<TProcessor>(ref TProcessor processor)
        {
            if (Type is not null)
            {
                processor.Process(new TagItem<string>("test.type", Type, TypeBytes));
            }

            if (Module is not null)
            {
                processor.Process(new TagItem<string>("test.module", Module, ModuleBytes));
            }

            if (Bundle is not null)
            {
                processor.Process(new TagItem<string>("test.bundle", Bundle, BundleBytes));
            }

            if (Framework is not null)
            {
                processor.Process(new TagItem<string>("test.framework", Framework, FrameworkBytes));
            }

            if (FrameworkVersion is not null)
            {
                processor.Process(new TagItem<string>("test.framework_version", FrameworkVersion, FrameworkVersionBytes));
            }

            if (RuntimeName is not null)
            {
                processor.Process(new TagItem<string>("runtime.name", RuntimeName, RuntimeNameBytes));
            }

            if (RuntimeVersion is not null)
            {
                processor.Process(new TagItem<string>("runtime.version", RuntimeVersion, RuntimeVersionBytes));
            }

            if (RuntimeArchitecture is not null)
            {
                processor.Process(new TagItem<string>("runtime.architecture", RuntimeArchitecture, RuntimeArchitectureBytes));
            }

            if (OSArchitecture is not null)
            {
                processor.Process(new TagItem<string>("os.architecture", OSArchitecture, OSArchitectureBytes));
            }

            if (OSPlatform is not null)
            {
                processor.Process(new TagItem<string>("os.platform", OSPlatform, OSPlatformBytes));
            }

            if (OSVersion is not null)
            {
                processor.Process(new TagItem<string>("os.version", OSVersion, OSVersionBytes));
            }

            base.EnumerateTags(ref processor);
        }

        protected override void WriteAdditionalTags(System.Text.StringBuilder sb)
        {
            if (Type is not null)
            {
                sb.Append("test.type (tag):")
                  .Append(Type)
                  .Append(',');
            }

            if (Module is not null)
            {
                sb.Append("test.module (tag):")
                  .Append(Module)
                  .Append(',');
            }

            if (Bundle is not null)
            {
                sb.Append("test.bundle (tag):")
                  .Append(Bundle)
                  .Append(',');
            }

            if (Framework is not null)
            {
                sb.Append("test.framework (tag):")
                  .Append(Framework)
                  .Append(',');
            }

            if (FrameworkVersion is not null)
            {
                sb.Append("test.framework_version (tag):")
                  .Append(FrameworkVersion)
                  .Append(',');
            }

            if (RuntimeName is not null)
            {
                sb.Append("runtime.name (tag):")
                  .Append(RuntimeName)
                  .Append(',');
            }

            if (RuntimeVersion is not null)
            {
                sb.Append("runtime.version (tag):")
                  .Append(RuntimeVersion)
                  .Append(',');
            }

            if (RuntimeArchitecture is not null)
            {
                sb.Append("runtime.architecture (tag):")
                  .Append(RuntimeArchitecture)
                  .Append(',');
            }

            if (OSArchitecture is not null)
            {
                sb.Append("os.architecture (tag):")
                  .Append(OSArchitecture)
                  .Append(',');
            }

            if (OSPlatform is not null)
            {
                sb.Append("os.platform (tag):")
                  .Append(OSPlatform)
                  .Append(',');
            }

            if (OSVersion is not null)
            {
                sb.Append("os.version (tag):")
                  .Append(OSVersion)
                  .Append(',');
            }

            base.WriteAdditionalTags(sb);
        }
        public override double? GetMetric(string key)
        {
            return key switch
            {
                "test.itr.tests_skipping.count" => IntelligentTestRunnerSkippingCount,
                _ => base.GetMetric(key),
            };
        }

        public override void SetMetric(string key, double? value)
        {
            switch(key)
            {
                case "test.itr.tests_skipping.count": 
                    Logger.Value.Warning("Attempted to set readonly metric {MetricName} on {TagType}. Ignoring.", key, nameof(TestModuleSpanTags));
                    break;
                default: 
                    base.SetMetric(key, value);
                    break;
            }
        }

        public override void EnumerateMetrics<TProcessor>(ref TProcessor processor)
        {
            if (IntelligentTestRunnerSkippingCount is not null)
            {
                processor.Process(new TagItem<double>("test.itr.tests_skipping.count", IntelligentTestRunnerSkippingCount.Value, IntelligentTestRunnerSkippingCountBytes));
            }

            base.EnumerateMetrics(ref processor);
        }

        protected override void WriteAdditionalMetrics(System.Text.StringBuilder sb)
        {
            if (IntelligentTestRunnerSkippingCount is not null)
            {
                sb.Append("test.itr.tests_skipping.count (metric):")
                  .Append(IntelligentTestRunnerSkippingCount.Value)
                  .Append(',');
            }

            base.WriteAdditionalMetrics(sb);
        }
    }
}
