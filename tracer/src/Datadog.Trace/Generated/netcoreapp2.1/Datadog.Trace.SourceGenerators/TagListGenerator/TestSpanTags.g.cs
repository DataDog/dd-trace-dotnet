// <copyright company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>
// <auto-generated/>

#nullable enable

using Datadog.Trace.Processors;
using Datadog.Trace.Tagging;
using System;

namespace Datadog.Trace.Ci.Tagging
{
    partial class TestSpanTags
    {
        // SourceStartBytes = MessagePack.Serialize("test.source.start");
        private static ReadOnlySpan<byte> SourceStartBytes => new byte[] { 177, 116, 101, 115, 116, 46, 115, 111, 117, 114, 99, 101, 46, 115, 116, 97, 114, 116 };
        // SourceEndBytes = MessagePack.Serialize("test.source.end");
        private static ReadOnlySpan<byte> SourceEndBytes => new byte[] { 175, 116, 101, 115, 116, 46, 115, 111, 117, 114, 99, 101, 46, 101, 110, 100 };
        // NameBytes = MessagePack.Serialize("test.name");
        private static ReadOnlySpan<byte> NameBytes => new byte[] { 169, 116, 101, 115, 116, 46, 110, 97, 109, 101 };
        // ParametersBytes = MessagePack.Serialize("test.parameters");
        private static ReadOnlySpan<byte> ParametersBytes => new byte[] { 175, 116, 101, 115, 116, 46, 112, 97, 114, 97, 109, 101, 116, 101, 114, 115 };
        // SourceFileBytes = MessagePack.Serialize("test.source.file");
        private static ReadOnlySpan<byte> SourceFileBytes => new byte[] { 176, 116, 101, 115, 116, 46, 115, 111, 117, 114, 99, 101, 46, 102, 105, 108, 101 };
        // CodeOwnersBytes = MessagePack.Serialize("test.codeowners");
        private static ReadOnlySpan<byte> CodeOwnersBytes => new byte[] { 175, 116, 101, 115, 116, 46, 99, 111, 100, 101, 111, 119, 110, 101, 114, 115 };
        // TraitsBytes = MessagePack.Serialize("test.traits");
        private static ReadOnlySpan<byte> TraitsBytes => new byte[] { 171, 116, 101, 115, 116, 46, 116, 114, 97, 105, 116, 115 };
        // SkipReasonBytes = MessagePack.Serialize("test.skip_reason");
        private static ReadOnlySpan<byte> SkipReasonBytes => new byte[] { 176, 116, 101, 115, 116, 46, 115, 107, 105, 112, 95, 114, 101, 97, 115, 111, 110 };
        // SkippedByIntelligentTestRunnerBytes = MessagePack.Serialize("test.skipped_by_itr");
        private static ReadOnlySpan<byte> SkippedByIntelligentTestRunnerBytes => new byte[] { 179, 116, 101, 115, 116, 46, 115, 107, 105, 112, 112, 101, 100, 95, 98, 121, 95, 105, 116, 114 };
        // UnskippableBytes = MessagePack.Serialize("test.itr.unskippable");
        private static ReadOnlySpan<byte> UnskippableBytes => new byte[] { 180, 116, 101, 115, 116, 46, 105, 116, 114, 46, 117, 110, 115, 107, 105, 112, 112, 97, 98, 108, 101 };
        // ForcedRunBytes = MessagePack.Serialize("test.itr.forced_run");
        private static ReadOnlySpan<byte> ForcedRunBytes => new byte[] { 179, 116, 101, 115, 116, 46, 105, 116, 114, 46, 102, 111, 114, 99, 101, 100, 95, 114, 117, 110 };
        // EarlyFlakeDetectionTestIsNewBytes = MessagePack.Serialize("test.is_new");
        private static ReadOnlySpan<byte> EarlyFlakeDetectionTestIsNewBytes => new byte[] { 171, 116, 101, 115, 116, 46, 105, 115, 95, 110, 101, 119 };
        // EarlyFlakeDetectionTestIsRetryBytes = MessagePack.Serialize("test.is_retry");
        private static ReadOnlySpan<byte> EarlyFlakeDetectionTestIsRetryBytes => new byte[] { 173, 116, 101, 115, 116, 46, 105, 115, 95, 114, 101, 116, 114, 121 };
        // BrowserDriverBytes = MessagePack.Serialize("test.browser.driver");
        private static ReadOnlySpan<byte> BrowserDriverBytes => new byte[] { 179, 116, 101, 115, 116, 46, 98, 114, 111, 119, 115, 101, 114, 46, 100, 114, 105, 118, 101, 114 };
        // BrowserDriverVersionBytes = MessagePack.Serialize("test.browser.driver_version");
        private static ReadOnlySpan<byte> BrowserDriverVersionBytes => new byte[] { 187, 116, 101, 115, 116, 46, 98, 114, 111, 119, 115, 101, 114, 46, 100, 114, 105, 118, 101, 114, 95, 118, 101, 114, 115, 105, 111, 110 };
        // BrowserNameBytes = MessagePack.Serialize("test.browser.name");
        private static ReadOnlySpan<byte> BrowserNameBytes => new byte[] { 177, 116, 101, 115, 116, 46, 98, 114, 111, 119, 115, 101, 114, 46, 110, 97, 109, 101 };
        // BrowserVersionBytes = MessagePack.Serialize("test.browser.version");
        private static ReadOnlySpan<byte> BrowserVersionBytes => new byte[] { 180, 116, 101, 115, 116, 46, 98, 114, 111, 119, 115, 101, 114, 46, 118, 101, 114, 115, 105, 111, 110 };
        // IsRumActiveBytes = MessagePack.Serialize("test.is_rum_active");
        private static ReadOnlySpan<byte> IsRumActiveBytes => new byte[] { 178, 116, 101, 115, 116, 46, 105, 115, 95, 114, 117, 109, 95, 97, 99, 116, 105, 118, 101 };

        public override string? GetTag(string key)
        {
            return key switch
            {
                "test.name" => Name,
                "test.parameters" => Parameters,
                "test.source.file" => SourceFile,
                "test.codeowners" => CodeOwners,
                "test.traits" => Traits,
                "test.skip_reason" => SkipReason,
                "test.skipped_by_itr" => SkippedByIntelligentTestRunner,
                "test.itr.unskippable" => Unskippable,
                "test.itr.forced_run" => ForcedRun,
                "test.is_new" => EarlyFlakeDetectionTestIsNew,
                "test.is_retry" => EarlyFlakeDetectionTestIsRetry,
                "test.browser.driver" => BrowserDriver,
                "test.browser.driver_version" => BrowserDriverVersion,
                "test.browser.name" => BrowserName,
                "test.browser.version" => BrowserVersion,
                "test.is_rum_active" => IsRumActive,
                _ => base.GetTag(key),
            };
        }

        public override void SetTag(string key, string value)
        {
            switch(key)
            {
                case "test.name": 
                    Name = value;
                    break;
                case "test.parameters": 
                    Parameters = value;
                    break;
                case "test.source.file": 
                    SourceFile = value;
                    break;
                case "test.codeowners": 
                    CodeOwners = value;
                    break;
                case "test.traits": 
                    Traits = value;
                    break;
                case "test.skip_reason": 
                    SkipReason = value;
                    break;
                case "test.skipped_by_itr": 
                    SkippedByIntelligentTestRunner = value;
                    break;
                case "test.itr.unskippable": 
                    Unskippable = value;
                    break;
                case "test.itr.forced_run": 
                    ForcedRun = value;
                    break;
                case "test.is_new": 
                    EarlyFlakeDetectionTestIsNew = value;
                    break;
                case "test.is_retry": 
                    EarlyFlakeDetectionTestIsRetry = value;
                    break;
                case "test.browser.driver": 
                    BrowserDriver = value;
                    break;
                case "test.browser.driver_version": 
                    BrowserDriverVersion = value;
                    break;
                case "test.browser.name": 
                    BrowserName = value;
                    break;
                case "test.browser.version": 
                    BrowserVersion = value;
                    break;
                case "test.is_rum_active": 
                    IsRumActive = value;
                    break;
                default: 
                    base.SetTag(key, value);
                    break;
            }
        }

        public override void EnumerateTags<TProcessor>(ref TProcessor processor)
        {
            if (Name is not null)
            {
                processor.Process(new TagItem<string>("test.name", Name, NameBytes));
            }

            if (Parameters is not null)
            {
                processor.Process(new TagItem<string>("test.parameters", Parameters, ParametersBytes));
            }

            if (SourceFile is not null)
            {
                processor.Process(new TagItem<string>("test.source.file", SourceFile, SourceFileBytes));
            }

            if (CodeOwners is not null)
            {
                processor.Process(new TagItem<string>("test.codeowners", CodeOwners, CodeOwnersBytes));
            }

            if (Traits is not null)
            {
                processor.Process(new TagItem<string>("test.traits", Traits, TraitsBytes));
            }

            if (SkipReason is not null)
            {
                processor.Process(new TagItem<string>("test.skip_reason", SkipReason, SkipReasonBytes));
            }

            if (SkippedByIntelligentTestRunner is not null)
            {
                processor.Process(new TagItem<string>("test.skipped_by_itr", SkippedByIntelligentTestRunner, SkippedByIntelligentTestRunnerBytes));
            }

            if (Unskippable is not null)
            {
                processor.Process(new TagItem<string>("test.itr.unskippable", Unskippable, UnskippableBytes));
            }

            if (ForcedRun is not null)
            {
                processor.Process(new TagItem<string>("test.itr.forced_run", ForcedRun, ForcedRunBytes));
            }

            if (EarlyFlakeDetectionTestIsNew is not null)
            {
                processor.Process(new TagItem<string>("test.is_new", EarlyFlakeDetectionTestIsNew, EarlyFlakeDetectionTestIsNewBytes));
            }

            if (EarlyFlakeDetectionTestIsRetry is not null)
            {
                processor.Process(new TagItem<string>("test.is_retry", EarlyFlakeDetectionTestIsRetry, EarlyFlakeDetectionTestIsRetryBytes));
            }

            if (BrowserDriver is not null)
            {
                processor.Process(new TagItem<string>("test.browser.driver", BrowserDriver, BrowserDriverBytes));
            }

            if (BrowserDriverVersion is not null)
            {
                processor.Process(new TagItem<string>("test.browser.driver_version", BrowserDriverVersion, BrowserDriverVersionBytes));
            }

            if (BrowserName is not null)
            {
                processor.Process(new TagItem<string>("test.browser.name", BrowserName, BrowserNameBytes));
            }

            if (BrowserVersion is not null)
            {
                processor.Process(new TagItem<string>("test.browser.version", BrowserVersion, BrowserVersionBytes));
            }

            if (IsRumActive is not null)
            {
                processor.Process(new TagItem<string>("test.is_rum_active", IsRumActive, IsRumActiveBytes));
            }

            base.EnumerateTags(ref processor);
        }

        protected override void WriteAdditionalTags(System.Text.StringBuilder sb)
        {
            if (Name is not null)
            {
                sb.Append("test.name (tag):")
                  .Append(Name)
                  .Append(',');
            }

            if (Parameters is not null)
            {
                sb.Append("test.parameters (tag):")
                  .Append(Parameters)
                  .Append(',');
            }

            if (SourceFile is not null)
            {
                sb.Append("test.source.file (tag):")
                  .Append(SourceFile)
                  .Append(',');
            }

            if (CodeOwners is not null)
            {
                sb.Append("test.codeowners (tag):")
                  .Append(CodeOwners)
                  .Append(',');
            }

            if (Traits is not null)
            {
                sb.Append("test.traits (tag):")
                  .Append(Traits)
                  .Append(',');
            }

            if (SkipReason is not null)
            {
                sb.Append("test.skip_reason (tag):")
                  .Append(SkipReason)
                  .Append(',');
            }

            if (SkippedByIntelligentTestRunner is not null)
            {
                sb.Append("test.skipped_by_itr (tag):")
                  .Append(SkippedByIntelligentTestRunner)
                  .Append(',');
            }

            if (Unskippable is not null)
            {
                sb.Append("test.itr.unskippable (tag):")
                  .Append(Unskippable)
                  .Append(',');
            }

            if (ForcedRun is not null)
            {
                sb.Append("test.itr.forced_run (tag):")
                  .Append(ForcedRun)
                  .Append(',');
            }

            if (EarlyFlakeDetectionTestIsNew is not null)
            {
                sb.Append("test.is_new (tag):")
                  .Append(EarlyFlakeDetectionTestIsNew)
                  .Append(',');
            }

            if (EarlyFlakeDetectionTestIsRetry is not null)
            {
                sb.Append("test.is_retry (tag):")
                  .Append(EarlyFlakeDetectionTestIsRetry)
                  .Append(',');
            }

            if (BrowserDriver is not null)
            {
                sb.Append("test.browser.driver (tag):")
                  .Append(BrowserDriver)
                  .Append(',');
            }

            if (BrowserDriverVersion is not null)
            {
                sb.Append("test.browser.driver_version (tag):")
                  .Append(BrowserDriverVersion)
                  .Append(',');
            }

            if (BrowserName is not null)
            {
                sb.Append("test.browser.name (tag):")
                  .Append(BrowserName)
                  .Append(',');
            }

            if (BrowserVersion is not null)
            {
                sb.Append("test.browser.version (tag):")
                  .Append(BrowserVersion)
                  .Append(',');
            }

            if (IsRumActive is not null)
            {
                sb.Append("test.is_rum_active (tag):")
                  .Append(IsRumActive)
                  .Append(',');
            }

            base.WriteAdditionalTags(sb);
        }
        public override double? GetMetric(string key)
        {
            return key switch
            {
                "test.source.start" => SourceStart,
                "test.source.end" => SourceEnd,
                _ => base.GetMetric(key),
            };
        }

        public override void SetMetric(string key, double? value)
        {
            switch(key)
            {
                case "test.source.start": 
                    SourceStart = value;
                    break;
                case "test.source.end": 
                    SourceEnd = value;
                    break;
                default: 
                    base.SetMetric(key, value);
                    break;
            }
        }

        public override void EnumerateMetrics<TProcessor>(ref TProcessor processor)
        {
            if (SourceStart is not null)
            {
                processor.Process(new TagItem<double>("test.source.start", SourceStart.Value, SourceStartBytes));
            }

            if (SourceEnd is not null)
            {
                processor.Process(new TagItem<double>("test.source.end", SourceEnd.Value, SourceEndBytes));
            }

            base.EnumerateMetrics(ref processor);
        }

        protected override void WriteAdditionalMetrics(System.Text.StringBuilder sb)
        {
            if (SourceStart is not null)
            {
                sb.Append("test.source.start (metric):")
                  .Append(SourceStart.Value)
                  .Append(',');
            }

            if (SourceEnd is not null)
            {
                sb.Append("test.source.end (metric):")
                  .Append(SourceEnd.Value)
                  .Append(',');
            }

            base.WriteAdditionalMetrics(sb);
        }
    }
}
