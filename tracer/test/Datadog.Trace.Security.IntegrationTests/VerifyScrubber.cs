// <copyright file="VerifyScrubber.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

#nullable enable

using System.Text.RegularExpressions;
using Datadog.Trace.TestHelpers;
using VerifyTests;

namespace Datadog.Trace.Security.IntegrationTests;

internal static class VerifyScrubber
{
    // the fingerprint is as follows: ssn-<user id hash>-<cookie fields hash>-<cookie values hash>-<session id hash>
    private static readonly Regex AppSecFingerPrintCookiesAndSession = new(@"_dd\.appsec\.fp\.session: ssn-[a-zA-Z0-9]*-(?<CookieFields>[a-zA-Z0-9]*)-(?<CookieValues>[a-zA-Z0-9]*)-(?<SessionFp>[a-zA-Z0-9]*),", RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Multiline);
    private static readonly Regex AppSecFingerPrintSession = new(@"_dd\.appsec\.fp\.session: ssn-[a-zA-Z0-9]*-[a-zA-Z0-9]*-[a-zA-Z0-9]*-(?<SessionFp>[a-zA-Z0-9]*),", RegexOptions.IgnoreCase | RegexOptions.Compiled | RegexOptions.Multiline);
    private static readonly Regex AuthenticationCollectionMode = new(@"_dd.appsec.user.collection_mode: .*,", RegexOptions.IgnoreCase | RegexOptions.Compiled);

    /// <summary>
    /// for login events we remove everything as diff versions of net core behave differently, calling httpcontext.setuser on the login call.
    /// it doesn't matter as this is tested and ensured by authenticated requests tests (HttpContext.SetUser instrum)
    /// </summary>
    /// <param name="settings">settings</param>
    internal static void ScrubAuthenticationCollectionMode(this VerifySettings settings)
    {
        // these tags are added by HttpContext.SetUser. After a login event it's not always called by all framework versions
        // we dont want to test authenticated tags here anyway, as they're tested by TestAuthenticatedRequest
        settings.AddRegexScrubber(AuthenticationCollectionMode, string.Empty);
    }

    /// <summary>
    /// Everytime we are going to have a different session id so we need to at least scrub the part with the session generated by the aspnet core everytime auth takes place
    /// No need to scrub user id as we know it beforehands
    /// this is _dd.appsec.fp.session: ssn-[userid]-[cookiesfield]-[cookies]-[sessionfp],
    /// if we have: _dd.appsec.fp.session: ssn-asd1-asd2-asd3-1234 > _dd.appsec.fp.session: ssn-asd1-dffds1-<CookieValues>-<SessionFp>,
    /// if we have: _dd.appsec.fp.session: ssn-asd1---1234 > _dd.appsec.fp.session: ssn-asd1---<SessionFp>,
    /// if we have: _dd.appsec.fp.session: ssn-asd1--- > _dd.appsec.fp.session: ssn-asd1---,
    /// </summary>
    /// <param name="settings">settings</param>
    /// <param name="scrubCookiesFingerprint">in general if request is authenticated or there's a login event, cookie values and fields might be changing constantly</param>
    internal static void ScrubSessionFingerprint(this VerifySettings settings, bool scrubCookiesFingerprint = false)
    {
        settings.AddScrubber(
            s =>
            {
                var result = scrubCookiesFingerprint ? AppSecFingerPrintCookiesAndSession.Matches(s.ToString()) : AppSecFingerPrintSession.Matches(s.ToString());
                var indexAdjustment = 0;
                if (result.Count == 0) { return; }

                foreach (Match? match in result)
                {
                    if (match is { Groups.Count: > 0 })
                    {
#if NETFRAMEWORK
                        var index = 0;
                        string[] groups = scrubCookiesFingerprint ? ["<CookieFields>", "<CookieValues>", "<SessionFp>"] : ["<SessionFp>"];
#endif
                        foreach (var res in match.Groups)
                        {
                            if (res is not Match && res is Group { Success: true } g)
                            {
                                var oldValue = g.Value;
                                if (string.IsNullOrEmpty(oldValue))
                                {
                                    continue;
                                }
#if !NETFRAMEWORK
                                var replaceValue = string.IsNullOrEmpty(g.Value) ? string.Empty : $"<{g.Name}>";
#else

                                var replaceValue = string.IsNullOrEmpty(g.Value) ? string.Empty : groups[index++];
#endif
                                s.Replace(g.Value, replaceValue, g.Index + indexAdjustment, g.Length);
                                indexAdjustment += replaceValue.Length - oldValue.Length;
                            }
                        }
                    }
                }
            });
    }
}
