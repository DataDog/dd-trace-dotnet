// <copyright file="AspNetCoreTestFixture.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using Xunit.Abstractions;

namespace Datadog.Trace.TestHelpers
{
    public sealed class AspNetCoreTestFixture : IDisposable
    {
        private const string TracingHeaderName1WithMapping = "datadog-header-name";
        private const string TracingHeaderValue1 = "asp-net-core";
        private const string TracingHeaderName2 = "sample.correlation.identifier";
        private const string TracingHeaderValue2 = "0000-0000-0000";

        private readonly HttpClient _httpClient;
        private ITestOutputHelper _currentOutput;
        private object _outputLock = new();

        public AspNetCoreTestFixture()
        {
            _httpClient = new HttpClient();
            _httpClient.DefaultRequestHeaders.Add(HttpHeaderNames.TracingEnabled, "false");
            _httpClient.DefaultRequestHeaders.Add(HttpHeaderNames.UserAgent, "testhelper");
            _httpClient.DefaultRequestHeaders.Add(TracingHeaderName1WithMapping, TracingHeaderValue1);
            _httpClient.DefaultRequestHeaders.Add(TracingHeaderName2, TracingHeaderValue2);

#if NETCOREAPP2_1
            // Keep-alive is causing some weird failures on aspnetcore 2.1
            _httpClient.DefaultRequestHeaders.ConnectionClose = true;
#endif
        }

        public Process Process { get; private set; }

        public MockTracerAgent.TcpUdpAgent Agent { get; private set; }

        public int HttpPort { get; private set; }

        public void SetOutput(ITestOutputHelper output)
        {
            lock (_outputLock)
            {
                _currentOutput = output;
            }
        }

        /// <summary>
        /// Starts the test application and, if sendHealthCheck=true, sends an HTTP request
        /// with retries to application endpoint "/alive-check" and returns only after receiving
        /// a 200 status code.
        /// </summary>
        /// <param name="helper">test helper</param>
        /// <param name="enableSecurity">should asm be enabled</param>
        /// <param name="externalRulesFile">should we provide a static rule file for asm</param>
        /// <param name="sendHealthCheck">WARNING: Setting sendHealthCheck=false may potentially cause flake because we return without confirming that the application is ready to receive requests, so do this sparingly!
        /// Cases where this is needed includes testing WAF Initialization (only the first span generated by the application carries WAF information tags) and testing IAST sampling.</param>
        /// <param name="packageVersion">package version</param>
        /// <param name="agentConfiguration">custom agent configuration</param>
        /// <param name="useTelemetry">use telemetry</param>
        /// <exception cref="Exception">exception, dont timeout</exception>
        /// <returns>Awaits the Response to the alive check</returns>
        public async Task TryStartApp(TestHelper helper, bool? enableSecurity = null, string externalRulesFile = null, bool sendHealthCheck = true, string packageVersion = "", MockTracerAgent.AgentConfiguration agentConfiguration = null, bool useTelemetry = false)
        {
            if (Process is not null)
            {
                return;
            }

            if (Process is null)
            {
                var initialAgentPort = TcpPortProvider.GetOpenPort();

                Agent = MockTracerAgent.Create(_currentOutput, initialAgentPort, agentConfiguration: agentConfiguration, useTelemetry: useTelemetry);
                WriteToOutput($"Starting aspnetcore sample, agentPort: {Agent.Port}");
                Process = await helper.StartSample(Agent, arguments: null, packageVersion: packageVersion, aspNetCorePort: 0, enableSecurity: enableSecurity, externalRulesFile: externalRulesFile);

                using var mutex = new ManualResetEventSlim();

                int? port = null;

                Process.OutputDataReceived += (_, args) =>
                {
                    if (args.Data != null)
                    {
                        if (args.Data.Contains("Now listening on:"))
                        {
                            var splitIndex = args.Data.LastIndexOf(':');
                            port = int.Parse(args.Data.Substring(splitIndex + 1));
                        }

                        if (args.Data.Contains("Unable to start Kestrel"))
                        {
                            mutex.Set();
                        }

                        if (args.Data.Contains("Webserver started") || args.Data.Contains("Application started"))
                        {
                            mutex.Set();
                        }

                        WriteToOutput($"[webserver][stdout] {args.Data}");
                    }
                };

                Process.ErrorDataReceived += (_, args) =>
                {
                    if (args.Data != null)
                    {
                        WriteToOutput($"[webserver][stderr] {args.Data}");
                    }
                };

                Process.BeginOutputReadLine();
                Process.BeginErrorReadLine();

                if (!mutex.Wait(TimeSpan.FromSeconds(60)))
                {
                    WriteToOutput("Timeout while waiting for the proces to start");
                }

                if (port == null)
                {
                    WriteToOutput("Unable to determine port application is listening on");
                    throw new Exception("Unable to determine port application is listening on");
                }

                HttpPort = port.Value;
                WriteToOutput($"Started aspnetcore sample, listening on {HttpPort}");
            }

            await EnsureServerStarted(sendHealthCheck);
            Agent.SpanFilters.Add(IsNotServerLifeCheck);
        }

        public void Dispose()
        {
            if (HttpPort is not 0)
            {
                var request = WebRequest.CreateHttp($"http://localhost:{HttpPort}/shutdown");
                request.GetResponse().Close();
            }

            if (Process is not null)
            {
                try
                {
                    if (!Process.HasExited)
                    {
                        if (!Process.WaitForExit(5000))
                        {
                            Process.Kill();
                        }
                    }
                }
                catch
                {
                    // in some circumstances the HasExited property throws, this means the process probably hasn't even started correctly
                }

                Process.Dispose();
            }

            Agent?.Dispose();

            _currentOutput = null;
        }

        public HttpRequestMessage CreateRequest(HttpMethod method, string path, Dictionary<string, string> headers = null)
        {
            var message = new HttpRequestMessage(method, $"http://localhost:{HttpPort}{path}");
            if (headers != null)
            {
                foreach (var header in headers)
                {
                    message.Headers.Add(header.Key, header.Value);
                }
            }

            return message;
        }

        public async Task<HttpStatusCode> SendHttpRequest(HttpRequestMessage request)
        {
            var response = await _httpClient.SendAsync(request);
            var responseText = await response.Content.ReadAsStringAsync();

            WriteToOutput($"[http] {response.StatusCode} {responseText}");
            return response.StatusCode;
        }

        /// <summary>
        /// Creates a request, sends it to the sample app, and waits for a span to be generated.
        /// </summary>
        /// <param name="path">The relative path to the http endpoint in the sample app.</param>
        /// <param name="method">The http method to use for the request.</param>
        /// <returns>A list of spans generated by the sample app.</returns>
        public async Task<IImmutableList<MockSpan>> WaitForSpans(string path, HttpMethod method = null, Dictionary<string, string> headers = null)
        {
            method ??= HttpMethod.Get;
            var request = CreateRequest(method, path, headers);
            var now = DateTimeOffset.UtcNow;

            await SendHttpRequest(request);

            return await Agent.WaitForSpansAsync(
                       count: 1,
                       minDateTime: now,
                       returnAllOperations: true);
        }

        private async Task EnsureServerStarted(bool sendHealthCheck)
        {
            var maxMillisecondsToWait = 30_000;
            var intervalMilliseconds = 500;
            var intervals = maxMillisecondsToWait / intervalMilliseconds;
            var serverReady = false;

            // if we end up retrying, accept spans from previous attempts
            var dateTime = DateTime.UtcNow;

            // wait for server to be ready to receive requests
            while (intervals-- > 0)
            {
                DateTime startTime = DateTime.Now;
                try
                {
                    if (sendHealthCheck)
                    {
                        var request = new HttpRequestMessage(HttpMethod.Get, $"http://localhost:{HttpPort}/alive-check");
                        var responseCode = await SendHttpRequest(request);

                        if (responseCode == HttpStatusCode.OK)
                        {
                            await Agent.WaitForSpansAsync(1, minDateTime: dateTime);
                            serverReady = true;
                        }
                    }
                    else
                    {
                        serverReady = await IsPortListeningAsync(HttpPort);
                    }
                }
                catch
                {
                    // ignore
                }

                if (serverReady)
                {
                    break;
                }

                var milisecondsElapsed = (DateTime.Now - startTime).TotalMilliseconds;

                if (milisecondsElapsed < intervalMilliseconds)
                {
                    await Task.Delay((int)(intervalMilliseconds - milisecondsElapsed));
                }
            }

            if (!serverReady)
            {
                throw new Exception("Couldn't verify the application is ready to receive requests.");
            }
        }

        private async Task<bool> IsPortListeningAsync(int port)
        {
            try
            {
                using (var client = new TcpClient())
                {
                    var task = client.ConnectAsync("127.0.0.1", port);
                    if (await Task.WhenAny(task, Task.Delay(1000)) == task)
                    {
                        return client.Connected;
                    }
                }
            }
            catch
            {
                // If there's an exception, the server is not listening on this port
            }

            return false;
        }

        private bool IsNotServerLifeCheck(MockSpan span)
        {
            var resource = span.Resource;

            if (resource != null && (resource.Contains("alive-check") || resource.Contains("shutdown")))
            {
                return false;
            }

            span.Tags.TryGetValue(Tags.HttpUrl, out var url);

            if (url != null && (url.Contains("alive-check") || url.Contains("shutdown")))
            {
                return false;
            }

            return true;
        }

        private void WriteToOutput(string line)
        {
            lock (_outputLock)
            {
                _currentOutput?.WriteLine(line);
            }
        }
    }
}
