// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: opentelemetry/proto/metrics/v1/metrics.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021, 8981
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace OpenTelemetry.Proto.Metrics.V1 {

  /// <summary>Holder for reflection information generated from opentelemetry/proto/metrics/v1/metrics.proto</summary>
  public static partial class MetricsReflection {

    #region Descriptor
    /// <summary>File descriptor for opentelemetry/proto/metrics/v1/metrics.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static MetricsReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CixvcGVudGVsZW1ldHJ5L3Byb3RvL21ldHJpY3MvdjEvbWV0cmljcy5wcm90",
            "bxIeb3BlbnRlbGVtZXRyeS5wcm90by5tZXRyaWNzLnYxGipvcGVudGVsZW1l",
            "dHJ5L3Byb3RvL2NvbW1vbi92MS9jb21tb24ucHJvdG8aLm9wZW50ZWxlbWV0",
            "cnkvcHJvdG8vcmVzb3VyY2UvdjEvcmVzb3VyY2UucHJvdG8iWAoLTWV0cmlj",
            "c0RhdGESSQoQcmVzb3VyY2VfbWV0cmljcxgBIAMoCzIvLm9wZW50ZWxlbWV0",
            "cnkucHJvdG8ubWV0cmljcy52MS5SZXNvdXJjZU1ldHJpY3MirwEKD1Jlc291",
            "cmNlTWV0cmljcxI7CghyZXNvdXJjZRgBIAEoCzIpLm9wZW50ZWxlbWV0cnku",
            "cHJvdG8ucmVzb3VyY2UudjEuUmVzb3VyY2USQwoNc2NvcGVfbWV0cmljcxgC",
            "IAMoCzIsLm9wZW50ZWxlbWV0cnkucHJvdG8ubWV0cmljcy52MS5TY29wZU1l",
            "dHJpY3MSEgoKc2NoZW1hX3VybBgDIAEoCUoGCOgHEOkHIp8BCgxTY29wZU1l",
            "dHJpY3MSQgoFc2NvcGUYASABKAsyMy5vcGVudGVsZW1ldHJ5LnByb3RvLmNv",
            "bW1vbi52MS5JbnN0cnVtZW50YXRpb25TY29wZRI3CgdtZXRyaWNzGAIgAygL",
            "MiYub3BlbnRlbGVtZXRyeS5wcm90by5tZXRyaWNzLnYxLk1ldHJpYxISCgpz",
            "Y2hlbWFfdXJsGAMgASgJIs0DCgZNZXRyaWMSDAoEbmFtZRgBIAEoCRITCgtk",
            "ZXNjcmlwdGlvbhgCIAEoCRIMCgR1bml0GAMgASgJEjYKBWdhdWdlGAUgASgL",
            "MiUub3BlbnRlbGVtZXRyeS5wcm90by5tZXRyaWNzLnYxLkdhdWdlSAASMgoD",
            "c3VtGAcgASgLMiMub3BlbnRlbGVtZXRyeS5wcm90by5tZXRyaWNzLnYxLlN1",
            "bUgAEj4KCWhpc3RvZ3JhbRgJIAEoCzIpLm9wZW50ZWxlbWV0cnkucHJvdG8u",
            "bWV0cmljcy52MS5IaXN0b2dyYW1IABJVChVleHBvbmVudGlhbF9oaXN0b2dy",
            "YW0YCiABKAsyNC5vcGVudGVsZW1ldHJ5LnByb3RvLm1ldHJpY3MudjEuRXhw",
            "b25lbnRpYWxIaXN0b2dyYW1IABI6CgdzdW1tYXJ5GAsgASgLMicub3BlbnRl",
            "bGVtZXRyeS5wcm90by5tZXRyaWNzLnYxLlN1bW1hcnlIABI5CghtZXRhZGF0",
            "YRgMIAMoCzInLm9wZW50ZWxlbWV0cnkucHJvdG8uY29tbW9uLnYxLktleVZh",
            "bHVlQgYKBGRhdGFKBAgEEAVKBAgGEAdKBAgIEAkiTQoFR2F1Z2USRAoLZGF0",
            "YV9wb2ludHMYASADKAsyLy5vcGVudGVsZW1ldHJ5LnByb3RvLm1ldHJpY3Mu",
            "djEuTnVtYmVyRGF0YVBvaW50IroBCgNTdW0SRAoLZGF0YV9wb2ludHMYASAD",
            "KAsyLy5vcGVudGVsZW1ldHJ5LnByb3RvLm1ldHJpY3MudjEuTnVtYmVyRGF0",
            "YVBvaW50ElcKF2FnZ3JlZ2F0aW9uX3RlbXBvcmFsaXR5GAIgASgOMjYub3Bl",
            "bnRlbGVtZXRyeS5wcm90by5tZXRyaWNzLnYxLkFnZ3JlZ2F0aW9uVGVtcG9y",
            "YWxpdHkSFAoMaXNfbW9ub3RvbmljGAMgASgIIq0BCglIaXN0b2dyYW0SRwoL",
            "ZGF0YV9wb2ludHMYASADKAsyMi5vcGVudGVsZW1ldHJ5LnByb3RvLm1ldHJp",
            "Y3MudjEuSGlzdG9ncmFtRGF0YVBvaW50ElcKF2FnZ3JlZ2F0aW9uX3RlbXBv",
            "cmFsaXR5GAIgASgOMjYub3BlbnRlbGVtZXRyeS5wcm90by5tZXRyaWNzLnYx",
            "LkFnZ3JlZ2F0aW9uVGVtcG9yYWxpdHkiwwEKFEV4cG9uZW50aWFsSGlzdG9n",
            "cmFtElIKC2RhdGFfcG9pbnRzGAEgAygLMj0ub3BlbnRlbGVtZXRyeS5wcm90",
            "by5tZXRyaWNzLnYxLkV4cG9uZW50aWFsSGlzdG9ncmFtRGF0YVBvaW50ElcK",
            "F2FnZ3JlZ2F0aW9uX3RlbXBvcmFsaXR5GAIgASgOMjYub3BlbnRlbGVtZXRy",
            "eS5wcm90by5tZXRyaWNzLnYxLkFnZ3JlZ2F0aW9uVGVtcG9yYWxpdHkiUAoH",
            "U3VtbWFyeRJFCgtkYXRhX3BvaW50cxgBIAMoCzIwLm9wZW50ZWxlbWV0cnku",
            "cHJvdG8ubWV0cmljcy52MS5TdW1tYXJ5RGF0YVBvaW50IoYCCg9OdW1iZXJE",
            "YXRhUG9pbnQSOwoKYXR0cmlidXRlcxgHIAMoCzInLm9wZW50ZWxlbWV0cnku",
            "cHJvdG8uY29tbW9uLnYxLktleVZhbHVlEhwKFHN0YXJ0X3RpbWVfdW5peF9u",
            "YW5vGAIgASgGEhYKDnRpbWVfdW5peF9uYW5vGAMgASgGEhMKCWFzX2RvdWJs",
            "ZRgEIAEoAUgAEhAKBmFzX2ludBgGIAEoEEgAEjsKCWV4ZW1wbGFycxgFIAMo",
            "CzIoLm9wZW50ZWxlbWV0cnkucHJvdG8ubWV0cmljcy52MS5FeGVtcGxhchIN",
            "CgVmbGFncxgIIAEoDUIHCgV2YWx1ZUoECAEQAiLmAgoSSGlzdG9ncmFtRGF0",
            "YVBvaW50EjsKCmF0dHJpYnV0ZXMYCSADKAsyJy5vcGVudGVsZW1ldHJ5LnBy",
            "b3RvLmNvbW1vbi52MS5LZXlWYWx1ZRIcChRzdGFydF90aW1lX3VuaXhfbmFu",
            "bxgCIAEoBhIWCg50aW1lX3VuaXhfbmFubxgDIAEoBhINCgVjb3VudBgEIAEo",
            "BhIQCgNzdW0YBSABKAFIAIgBARIVCg1idWNrZXRfY291bnRzGAYgAygGEhcK",
            "D2V4cGxpY2l0X2JvdW5kcxgHIAMoARI7CglleGVtcGxhcnMYCCADKAsyKC5v",
            "cGVudGVsZW1ldHJ5LnByb3RvLm1ldHJpY3MudjEuRXhlbXBsYXISDQoFZmxh",
            "Z3MYCiABKA0SEAoDbWluGAsgASgBSAGIAQESEAoDbWF4GAwgASgBSAKIAQFC",
            "BgoEX3N1bUIGCgRfbWluQgYKBF9tYXhKBAgBEAIi2gQKHUV4cG9uZW50aWFs",
            "SGlzdG9ncmFtRGF0YVBvaW50EjsKCmF0dHJpYnV0ZXMYASADKAsyJy5vcGVu",
            "dGVsZW1ldHJ5LnByb3RvLmNvbW1vbi52MS5LZXlWYWx1ZRIcChRzdGFydF90",
            "aW1lX3VuaXhfbmFubxgCIAEoBhIWCg50aW1lX3VuaXhfbmFubxgDIAEoBhIN",
            "CgVjb3VudBgEIAEoBhIQCgNzdW0YBSABKAFIAIgBARINCgVzY2FsZRgGIAEo",
            "ERISCgp6ZXJvX2NvdW50GAcgASgGElcKCHBvc2l0aXZlGAggASgLMkUub3Bl",
            "bnRlbGVtZXRyeS5wcm90by5tZXRyaWNzLnYxLkV4cG9uZW50aWFsSGlzdG9n",
            "cmFtRGF0YVBvaW50LkJ1Y2tldHMSVwoIbmVnYXRpdmUYCSABKAsyRS5vcGVu",
            "dGVsZW1ldHJ5LnByb3RvLm1ldHJpY3MudjEuRXhwb25lbnRpYWxIaXN0b2dy",
            "YW1EYXRhUG9pbnQuQnVja2V0cxINCgVmbGFncxgKIAEoDRI7CglleGVtcGxh",
            "cnMYCyADKAsyKC5vcGVudGVsZW1ldHJ5LnByb3RvLm1ldHJpY3MudjEuRXhl",
            "bXBsYXISEAoDbWluGAwgASgBSAGIAQESEAoDbWF4GA0gASgBSAKIAQESFgoO",
            "emVyb190aHJlc2hvbGQYDiABKAEaMAoHQnVja2V0cxIOCgZvZmZzZXQYASAB",
            "KBESFQoNYnVja2V0X2NvdW50cxgCIAMoBEIGCgRfc3VtQgYKBF9taW5CBgoE",
            "X21heCLFAgoQU3VtbWFyeURhdGFQb2ludBI7CgphdHRyaWJ1dGVzGAcgAygL",
            "Micub3BlbnRlbGVtZXRyeS5wcm90by5jb21tb24udjEuS2V5VmFsdWUSHAoU",
            "c3RhcnRfdGltZV91bml4X25hbm8YAiABKAYSFgoOdGltZV91bml4X25hbm8Y",
            "AyABKAYSDQoFY291bnQYBCABKAYSCwoDc3VtGAUgASgBElkKD3F1YW50aWxl",
            "X3ZhbHVlcxgGIAMoCzJALm9wZW50ZWxlbWV0cnkucHJvdG8ubWV0cmljcy52",
            "MS5TdW1tYXJ5RGF0YVBvaW50LlZhbHVlQXRRdWFudGlsZRINCgVmbGFncxgI",
            "IAEoDRoyCg9WYWx1ZUF0UXVhbnRpbGUSEAoIcXVhbnRpbGUYASABKAESDQoF",
            "dmFsdWUYAiABKAFKBAgBEAIiwQEKCEV4ZW1wbGFyEkQKE2ZpbHRlcmVkX2F0",
            "dHJpYnV0ZXMYByADKAsyJy5vcGVudGVsZW1ldHJ5LnByb3RvLmNvbW1vbi52",
            "MS5LZXlWYWx1ZRIWCg50aW1lX3VuaXhfbmFubxgCIAEoBhITCglhc19kb3Vi",
            "bGUYAyABKAFIABIQCgZhc19pbnQYBiABKBBIABIPCgdzcGFuX2lkGAQgASgM",
            "EhAKCHRyYWNlX2lkGAUgASgMQgcKBXZhbHVlSgQIARACKowBChZBZ2dyZWdh",
            "dGlvblRlbXBvcmFsaXR5EicKI0FHR1JFR0FUSU9OX1RFTVBPUkFMSVRZX1VO",
            "U1BFQ0lGSUVEEAASIQodQUdHUkVHQVRJT05fVEVNUE9SQUxJVFlfREVMVEEQ",
            "ARImCiJBR0dSRUdBVElPTl9URU1QT1JBTElUWV9DVU1VTEFUSVZFEAIqXgoO",
            "RGF0YVBvaW50RmxhZ3MSHwobREFUQV9QT0lOVF9GTEFHU19ET19OT1RfVVNF",
            "EAASKwonREFUQV9QT0lOVF9GTEFHU19OT19SRUNPUkRFRF9WQUxVRV9NQVNL",
            "EAFCfwohaW8ub3BlbnRlbGVtZXRyeS5wcm90by5tZXRyaWNzLnYxQgxNZXRy",
            "aWNzUHJvdG9QAVopZ28ub3BlbnRlbGVtZXRyeS5pby9wcm90by9vdGxwL21l",
            "dHJpY3MvdjGqAh5PcGVuVGVsZW1ldHJ5LlByb3RvLk1ldHJpY3MuVjFiBnBy",
            "b3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::OpenTelemetry.Proto.Common.V1.CommonReflection.Descriptor, global::OpenTelemetry.Proto.Resource.V1.ResourceReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality), typeof(global::OpenTelemetry.Proto.Metrics.V1.DataPointFlags), }, null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.MetricsData), global::OpenTelemetry.Proto.Metrics.V1.MetricsData.Parser, new[]{ "ResourceMetrics" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.ResourceMetrics), global::OpenTelemetry.Proto.Metrics.V1.ResourceMetrics.Parser, new[]{ "Resource", "ScopeMetrics", "SchemaUrl" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.ScopeMetrics), global::OpenTelemetry.Proto.Metrics.V1.ScopeMetrics.Parser, new[]{ "Scope", "Metrics", "SchemaUrl" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.Metric), global::OpenTelemetry.Proto.Metrics.V1.Metric.Parser, new[]{ "Name", "Description", "Unit", "Gauge", "Sum", "Histogram", "ExponentialHistogram", "Summary", "Metadata" }, new[]{ "Data" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.Gauge), global::OpenTelemetry.Proto.Metrics.V1.Gauge.Parser, new[]{ "DataPoints" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.Sum), global::OpenTelemetry.Proto.Metrics.V1.Sum.Parser, new[]{ "DataPoints", "AggregationTemporality", "IsMonotonic" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.Histogram), global::OpenTelemetry.Proto.Metrics.V1.Histogram.Parser, new[]{ "DataPoints", "AggregationTemporality" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogram), global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogram.Parser, new[]{ "DataPoints", "AggregationTemporality" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.Summary), global::OpenTelemetry.Proto.Metrics.V1.Summary.Parser, new[]{ "DataPoints" }, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.NumberDataPoint), global::OpenTelemetry.Proto.Metrics.V1.NumberDataPoint.Parser, new[]{ "Attributes", "StartTimeUnixNano", "TimeUnixNano", "AsDouble", "AsInt", "Exemplars", "Flags" }, new[]{ "Value" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.HistogramDataPoint), global::OpenTelemetry.Proto.Metrics.V1.HistogramDataPoint.Parser, new[]{ "Attributes", "StartTimeUnixNano", "TimeUnixNano", "Count", "Sum", "BucketCounts", "ExplicitBounds", "Exemplars", "Flags", "Min", "Max" }, new[]{ "Sum", "Min", "Max" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint), global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint.Parser, new[]{ "Attributes", "StartTimeUnixNano", "TimeUnixNano", "Count", "Sum", "Scale", "ZeroCount", "Positive", "Negative", "Flags", "Exemplars", "Min", "Max", "ZeroThreshold" }, new[]{ "Sum", "Min", "Max" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint.Types.Buckets), global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint.Types.Buckets.Parser, new[]{ "Offset", "BucketCounts" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.SummaryDataPoint), global::OpenTelemetry.Proto.Metrics.V1.SummaryDataPoint.Parser, new[]{ "Attributes", "StartTimeUnixNano", "TimeUnixNano", "Count", "Sum", "QuantileValues", "Flags" }, null, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.SummaryDataPoint.Types.ValueAtQuantile), global::OpenTelemetry.Proto.Metrics.V1.SummaryDataPoint.Types.ValueAtQuantile.Parser, new[]{ "Quantile", "Value" }, null, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::OpenTelemetry.Proto.Metrics.V1.Exemplar), global::OpenTelemetry.Proto.Metrics.V1.Exemplar.Parser, new[]{ "FilteredAttributes", "TimeUnixNano", "AsDouble", "AsInt", "SpanId", "TraceId" }, new[]{ "Value" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// AggregationTemporality defines how a metric aggregator reports aggregated
  /// values. It describes how those values relate to the time interval over
  /// which they are aggregated.
  /// </summary>
  public enum AggregationTemporality {
    /// <summary>
    /// UNSPECIFIED is the default AggregationTemporality, it MUST not be used.
    /// </summary>
    [pbr::OriginalName("AGGREGATION_TEMPORALITY_UNSPECIFIED")] Unspecified = 0,
    /// <summary>
    /// DELTA is an AggregationTemporality for a metric aggregator which reports
    /// changes since last report time. Successive metrics contain aggregation of
    /// values from continuous and non-overlapping intervals.
    ///
    /// The values for a DELTA metric are based only on the time interval
    /// associated with one measurement cycle. There is no dependency on
    /// previous measurements like is the case for CUMULATIVE metrics.
    ///
    /// For example, consider a system measuring the number of requests that
    /// it receives and reports the sum of these requests every second as a
    /// DELTA metric:
    ///
    ///   1. The system starts receiving at time=t_0.
    ///   2. A request is received, the system measures 1 request.
    ///   3. A request is received, the system measures 1 request.
    ///   4. A request is received, the system measures 1 request.
    ///   5. The 1 second collection cycle ends. A metric is exported for the
    ///      number of requests received over the interval of time t_0 to
    ///      t_0+1 with a value of 3.
    ///   6. A request is received, the system measures 1 request.
    ///   7. A request is received, the system measures 1 request.
    ///   8. The 1 second collection cycle ends. A metric is exported for the
    ///      number of requests received over the interval of time t_0+1 to
    ///      t_0+2 with a value of 2.
    /// </summary>
    [pbr::OriginalName("AGGREGATION_TEMPORALITY_DELTA")] Delta = 1,
    /// <summary>
    /// CUMULATIVE is an AggregationTemporality for a metric aggregator which
    /// reports changes since a fixed start time. This means that current values
    /// of a CUMULATIVE metric depend on all previous measurements since the
    /// start time. Because of this, the sender is required to retain this state
    /// in some form. If this state is lost or invalidated, the CUMULATIVE metric
    /// values MUST be reset and a new fixed start time following the last
    /// reported measurement time sent MUST be used.
    ///
    /// For example, consider a system measuring the number of requests that
    /// it receives and reports the sum of these requests every second as a
    /// CUMULATIVE metric:
    ///
    ///   1. The system starts receiving at time=t_0.
    ///   2. A request is received, the system measures 1 request.
    ///   3. A request is received, the system measures 1 request.
    ///   4. A request is received, the system measures 1 request.
    ///   5. The 1 second collection cycle ends. A metric is exported for the
    ///      number of requests received over the interval of time t_0 to
    ///      t_0+1 with a value of 3.
    ///   6. A request is received, the system measures 1 request.
    ///   7. A request is received, the system measures 1 request.
    ///   8. The 1 second collection cycle ends. A metric is exported for the
    ///      number of requests received over the interval of time t_0 to
    ///      t_0+2 with a value of 5.
    ///   9. The system experiences a fault and loses state.
    ///   10. The system recovers and resumes receiving at time=t_1.
    ///   11. A request is received, the system measures 1 request.
    ///   12. The 1 second collection cycle ends. A metric is exported for the
    ///      number of requests received over the interval of time t_1 to
    ///      t_0+1 with a value of 1.
    ///
    /// Note: Even though, when reporting changes since last report time, using
    /// CUMULATIVE is valid, it is not recommended. This may cause problems for
    /// systems that do not use start_time to determine when the aggregation
    /// value was reset (e.g. Prometheus).
    /// </summary>
    [pbr::OriginalName("AGGREGATION_TEMPORALITY_CUMULATIVE")] Cumulative = 2,
  }

  /// <summary>
  /// DataPointFlags is defined as a protobuf 'uint32' type and is to be used as a
  /// bit-field representing 32 distinct boolean flags.  Each flag defined in this
  /// enum is a bit-mask.  To test the presence of a single flag in the flags of
  /// a data point, for example, use an expression like:
  ///
  ///   (point.flags &amp; DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK) == DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK
  /// </summary>
  public enum DataPointFlags {
    /// <summary>
    /// The zero value for the enum. Should not be used for comparisons.
    /// Instead use bitwise "and" with the appropriate mask as shown above.
    /// </summary>
    [pbr::OriginalName("DATA_POINT_FLAGS_DO_NOT_USE")] DoNotUse = 0,
    /// <summary>
    /// This DataPoint is valid but has no recorded value.  This value
    /// SHOULD be used to reflect explicitly missing data in a series, as
    /// for an equivalent to the Prometheus "staleness marker".
    /// </summary>
    [pbr::OriginalName("DATA_POINT_FLAGS_NO_RECORDED_VALUE_MASK")] NoRecordedValueMask = 1,
  }

  #endregion

  #region Messages
  /// <summary>
  /// MetricsData represents the metrics data that can be stored in a persistent
  /// storage, OR can be embedded by other protocols that transfer OTLP metrics
  /// data but do not implement the OTLP protocol.
  ///
  /// MetricsData
  /// └─── ResourceMetrics
  ///   ├── Resource
  ///   ├── SchemaURL
  ///   └── ScopeMetrics
  ///      ├── Scope
  ///      ├── SchemaURL
  ///      └── Metric
  ///         ├── Name
  ///         ├── Description
  ///         ├── Unit
  ///         └── data
  ///            ├── Gauge
  ///            ├── Sum
  ///            ├── Histogram
  ///            ├── ExponentialHistogram
  ///            └── Summary
  ///
  /// The main difference between this message and collector protocol is that
  /// in this message there will not be any "control" or "metadata" specific to
  /// OTLP protocol.
  ///
  /// When new fields are added into this message, the OTLP request MUST be updated
  /// as well.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class MetricsData : pb::IMessage<MetricsData>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<MetricsData> _parser = new pb::MessageParser<MetricsData>(() => new MetricsData());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<MetricsData> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::OpenTelemetry.Proto.Metrics.V1.MetricsReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MetricsData() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MetricsData(MetricsData other) : this() {
      resourceMetrics_ = other.resourceMetrics_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public MetricsData Clone() {
      return new MetricsData(this);
    }

    /// <summary>Field number for the "resource_metrics" field.</summary>
    public const int ResourceMetricsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Metrics.V1.ResourceMetrics> _repeated_resourceMetrics_codec
        = pb::FieldCodec.ForMessage(10, global::OpenTelemetry.Proto.Metrics.V1.ResourceMetrics.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.ResourceMetrics> resourceMetrics_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.ResourceMetrics>();
    /// <summary>
    /// An array of ResourceMetrics.
    /// For data coming from a single resource this array will typically contain
    /// one element. Intermediary nodes that receive data from multiple origins
    /// typically batch the data before forwarding further and in that case this
    /// array will contain multiple elements.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.ResourceMetrics> ResourceMetrics {
      get { return resourceMetrics_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as MetricsData);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(MetricsData other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!resourceMetrics_.Equals(other.resourceMetrics_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= resourceMetrics_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      resourceMetrics_.WriteTo(output, _repeated_resourceMetrics_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      resourceMetrics_.WriteTo(ref output, _repeated_resourceMetrics_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += resourceMetrics_.CalculateSize(_repeated_resourceMetrics_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(MetricsData other) {
      if (other == null) {
        return;
      }
      resourceMetrics_.Add(other.resourceMetrics_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            resourceMetrics_.AddEntriesFrom(input, _repeated_resourceMetrics_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            resourceMetrics_.AddEntriesFrom(ref input, _repeated_resourceMetrics_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A collection of ScopeMetrics from a Resource.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ResourceMetrics : pb::IMessage<ResourceMetrics>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ResourceMetrics> _parser = new pb::MessageParser<ResourceMetrics>(() => new ResourceMetrics());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ResourceMetrics> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::OpenTelemetry.Proto.Metrics.V1.MetricsReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceMetrics() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceMetrics(ResourceMetrics other) : this() {
      resource_ = other.resource_ != null ? other.resource_.Clone() : null;
      scopeMetrics_ = other.scopeMetrics_.Clone();
      schemaUrl_ = other.schemaUrl_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ResourceMetrics Clone() {
      return new ResourceMetrics(this);
    }

    /// <summary>Field number for the "resource" field.</summary>
    public const int ResourceFieldNumber = 1;
    private global::OpenTelemetry.Proto.Resource.V1.Resource resource_;
    /// <summary>
    /// The resource for the metrics in this message.
    /// If this field is not set then no resource info is known.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::OpenTelemetry.Proto.Resource.V1.Resource Resource {
      get { return resource_; }
      set {
        resource_ = value;
      }
    }

    /// <summary>Field number for the "scope_metrics" field.</summary>
    public const int ScopeMetricsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Metrics.V1.ScopeMetrics> _repeated_scopeMetrics_codec
        = pb::FieldCodec.ForMessage(18, global::OpenTelemetry.Proto.Metrics.V1.ScopeMetrics.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.ScopeMetrics> scopeMetrics_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.ScopeMetrics>();
    /// <summary>
    /// A list of metrics that originate from a resource.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.ScopeMetrics> ScopeMetrics {
      get { return scopeMetrics_; }
    }

    /// <summary>Field number for the "schema_url" field.</summary>
    public const int SchemaUrlFieldNumber = 3;
    private string schemaUrl_ = "";
    /// <summary>
    /// The Schema URL, if known. This is the identifier of the Schema that the resource data
    /// is recorded in. Notably, the last part of the URL path is the version number of the
    /// schema: http[s]://server[:port]/path/&lt;version>. To learn more about Schema URL see
    /// https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
    /// This schema_url applies to the data in the "resource" field. It does not apply
    /// to the data in the "scope_metrics" field which have their own schema_url field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SchemaUrl {
      get { return schemaUrl_; }
      set {
        schemaUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ResourceMetrics);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ResourceMetrics other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Resource, other.Resource)) return false;
      if(!scopeMetrics_.Equals(other.scopeMetrics_)) return false;
      if (SchemaUrl != other.SchemaUrl) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (resource_ != null) hash ^= Resource.GetHashCode();
      hash ^= scopeMetrics_.GetHashCode();
      if (SchemaUrl.Length != 0) hash ^= SchemaUrl.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (resource_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Resource);
      }
      scopeMetrics_.WriteTo(output, _repeated_scopeMetrics_codec);
      if (SchemaUrl.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(SchemaUrl);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (resource_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Resource);
      }
      scopeMetrics_.WriteTo(ref output, _repeated_scopeMetrics_codec);
      if (SchemaUrl.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(SchemaUrl);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (resource_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Resource);
      }
      size += scopeMetrics_.CalculateSize(_repeated_scopeMetrics_codec);
      if (SchemaUrl.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SchemaUrl);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ResourceMetrics other) {
      if (other == null) {
        return;
      }
      if (other.resource_ != null) {
        if (resource_ == null) {
          Resource = new global::OpenTelemetry.Proto.Resource.V1.Resource();
        }
        Resource.MergeFrom(other.Resource);
      }
      scopeMetrics_.Add(other.scopeMetrics_);
      if (other.SchemaUrl.Length != 0) {
        SchemaUrl = other.SchemaUrl;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (resource_ == null) {
              Resource = new global::OpenTelemetry.Proto.Resource.V1.Resource();
            }
            input.ReadMessage(Resource);
            break;
          }
          case 18: {
            scopeMetrics_.AddEntriesFrom(input, _repeated_scopeMetrics_codec);
            break;
          }
          case 26: {
            SchemaUrl = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (resource_ == null) {
              Resource = new global::OpenTelemetry.Proto.Resource.V1.Resource();
            }
            input.ReadMessage(Resource);
            break;
          }
          case 18: {
            scopeMetrics_.AddEntriesFrom(ref input, _repeated_scopeMetrics_codec);
            break;
          }
          case 26: {
            SchemaUrl = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// A collection of Metrics produced by an Scope.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ScopeMetrics : pb::IMessage<ScopeMetrics>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ScopeMetrics> _parser = new pb::MessageParser<ScopeMetrics>(() => new ScopeMetrics());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ScopeMetrics> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::OpenTelemetry.Proto.Metrics.V1.MetricsReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopeMetrics() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopeMetrics(ScopeMetrics other) : this() {
      scope_ = other.scope_ != null ? other.scope_.Clone() : null;
      metrics_ = other.metrics_.Clone();
      schemaUrl_ = other.schemaUrl_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ScopeMetrics Clone() {
      return new ScopeMetrics(this);
    }

    /// <summary>Field number for the "scope" field.</summary>
    public const int ScopeFieldNumber = 1;
    private global::OpenTelemetry.Proto.Common.V1.InstrumentationScope scope_;
    /// <summary>
    /// The instrumentation scope information for the metrics in this message.
    /// Semantically when InstrumentationScope isn't set, it is equivalent with
    /// an empty instrumentation scope name (unknown).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::OpenTelemetry.Proto.Common.V1.InstrumentationScope Scope {
      get { return scope_; }
      set {
        scope_ = value;
      }
    }

    /// <summary>Field number for the "metrics" field.</summary>
    public const int MetricsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Metrics.V1.Metric> _repeated_metrics_codec
        = pb::FieldCodec.ForMessage(18, global::OpenTelemetry.Proto.Metrics.V1.Metric.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.Metric> metrics_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.Metric>();
    /// <summary>
    /// A list of metrics that originate from an instrumentation library.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.Metric> Metrics {
      get { return metrics_; }
    }

    /// <summary>Field number for the "schema_url" field.</summary>
    public const int SchemaUrlFieldNumber = 3;
    private string schemaUrl_ = "";
    /// <summary>
    /// The Schema URL, if known. This is the identifier of the Schema that the metric data
    /// is recorded in. Notably, the last part of the URL path is the version number of the
    /// schema: http[s]://server[:port]/path/&lt;version>. To learn more about Schema URL see
    /// https://opentelemetry.io/docs/specs/otel/schemas/#schema-url
    /// This schema_url applies to all metrics in the "metrics" field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string SchemaUrl {
      get { return schemaUrl_; }
      set {
        schemaUrl_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ScopeMetrics);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ScopeMetrics other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(Scope, other.Scope)) return false;
      if(!metrics_.Equals(other.metrics_)) return false;
      if (SchemaUrl != other.SchemaUrl) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (scope_ != null) hash ^= Scope.GetHashCode();
      hash ^= metrics_.GetHashCode();
      if (SchemaUrl.Length != 0) hash ^= SchemaUrl.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (scope_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Scope);
      }
      metrics_.WriteTo(output, _repeated_metrics_codec);
      if (SchemaUrl.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(SchemaUrl);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (scope_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(Scope);
      }
      metrics_.WriteTo(ref output, _repeated_metrics_codec);
      if (SchemaUrl.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(SchemaUrl);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (scope_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Scope);
      }
      size += metrics_.CalculateSize(_repeated_metrics_codec);
      if (SchemaUrl.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(SchemaUrl);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ScopeMetrics other) {
      if (other == null) {
        return;
      }
      if (other.scope_ != null) {
        if (scope_ == null) {
          Scope = new global::OpenTelemetry.Proto.Common.V1.InstrumentationScope();
        }
        Scope.MergeFrom(other.Scope);
      }
      metrics_.Add(other.metrics_);
      if (other.SchemaUrl.Length != 0) {
        SchemaUrl = other.SchemaUrl;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (scope_ == null) {
              Scope = new global::OpenTelemetry.Proto.Common.V1.InstrumentationScope();
            }
            input.ReadMessage(Scope);
            break;
          }
          case 18: {
            metrics_.AddEntriesFrom(input, _repeated_metrics_codec);
            break;
          }
          case 26: {
            SchemaUrl = input.ReadString();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            if (scope_ == null) {
              Scope = new global::OpenTelemetry.Proto.Common.V1.InstrumentationScope();
            }
            input.ReadMessage(Scope);
            break;
          }
          case 18: {
            metrics_.AddEntriesFrom(ref input, _repeated_metrics_codec);
            break;
          }
          case 26: {
            SchemaUrl = input.ReadString();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Defines a Metric which has one or more timeseries.  The following is a
  /// brief summary of the Metric data model.  For more details, see:
  ///
  ///   https://github.com/open-telemetry/opentelemetry-specification/blob/main/specification/metrics/data-model.md
  ///
  /// The data model and relation between entities is shown in the
  /// diagram below. Here, "DataPoint" is the term used to refer to any
  /// one of the specific data point value types, and "points" is the term used
  /// to refer to any one of the lists of points contained in the Metric.
  ///
  /// - Metric is composed of a metadata and data.
  /// - Metadata part contains a name, description, unit.
  /// - Data is one of the possible types (Sum, Gauge, Histogram, Summary).
  /// - DataPoint contains timestamps, attributes, and one of the possible value type
  ///   fields.
  ///
  ///    Metric
  ///  +------------+
  ///  |name        |
  ///  |description |
  ///  |unit        |     +------------------------------------+
  ///  |data        |---> |Gauge, Sum, Histogram, Summary, ... |
  ///  +------------+     +------------------------------------+
  ///
  ///    Data [One of Gauge, Sum, Histogram, Summary, ...]
  ///  +-----------+
  ///  |...        |  // Metadata about the Data.
  ///  |points     |--+
  ///  +-----------+  |
  ///                 |      +---------------------------+
  ///                 |      |DataPoint 1                |
  ///                 v      |+------+------+   +------+ |
  ///              +-----+   ||label |label |...|label | |
  ///              |  1  |-->||value1|value2|...|valueN| |
  ///              +-----+   |+------+------+   +------+ |
  ///              |  .  |   |+-----+                    |
  ///              |  .  |   ||value|                    |
  ///              |  .  |   |+-----+                    |
  ///              |  .  |   +---------------------------+
  ///              |  .  |                   .
  ///              |  .  |                   .
  ///              |  .  |                   .
  ///              |  .  |   +---------------------------+
  ///              |  .  |   |DataPoint M                |
  ///              +-----+   |+------+------+   +------+ |
  ///              |  M  |-->||label |label |...|label | |
  ///              +-----+   ||value1|value2|...|valueN| |
  ///                        |+------+------+   +------+ |
  ///                        |+-----+                    |
  ///                        ||value|                    |
  ///                        |+-----+                    |
  ///                        +---------------------------+
  ///
  /// Each distinct type of DataPoint represents the output of a specific
  /// aggregation function, the result of applying the DataPoint's
  /// associated function of to one or more measurements.
  ///
  /// All DataPoint types have three common fields:
  /// - Attributes includes key-value pairs associated with the data point
  /// - TimeUnixNano is required, set to the end time of the aggregation
  /// - StartTimeUnixNano is optional, but strongly encouraged for DataPoints
  ///   having an AggregationTemporality field, as discussed below.
  ///
  /// Both TimeUnixNano and StartTimeUnixNano values are expressed as
  /// UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January 1970.
  ///
  /// # TimeUnixNano
  ///
  /// This field is required, having consistent interpretation across
  /// DataPoint types.  TimeUnixNano is the moment corresponding to when
  /// the data point's aggregate value was captured.
  ///
  /// Data points with the 0 value for TimeUnixNano SHOULD be rejected
  /// by consumers.
  ///
  /// # StartTimeUnixNano
  ///
  /// StartTimeUnixNano in general allows detecting when a sequence of
  /// observations is unbroken.  This field indicates to consumers the
  /// start time for points with cumulative and delta
  /// AggregationTemporality, and it should be included whenever possible
  /// to support correct rate calculation.  Although it may be omitted
  /// when the start time is truly unknown, setting StartTimeUnixNano is
  /// strongly encouraged.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Metric : pb::IMessage<Metric>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Metric> _parser = new pb::MessageParser<Metric>(() => new Metric());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Metric> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::OpenTelemetry.Proto.Metrics.V1.MetricsReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Metric() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Metric(Metric other) : this() {
      name_ = other.name_;
      description_ = other.description_;
      unit_ = other.unit_;
      metadata_ = other.metadata_.Clone();
      switch (other.DataCase) {
        case DataOneofCase.Gauge:
          Gauge = other.Gauge.Clone();
          break;
        case DataOneofCase.Sum:
          Sum = other.Sum.Clone();
          break;
        case DataOneofCase.Histogram:
          Histogram = other.Histogram.Clone();
          break;
        case DataOneofCase.ExponentialHistogram:
          ExponentialHistogram = other.ExponentialHistogram.Clone();
          break;
        case DataOneofCase.Summary:
          Summary = other.Summary.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Metric Clone() {
      return new Metric(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// name of the metric.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "description" field.</summary>
    public const int DescriptionFieldNumber = 2;
    private string description_ = "";
    /// <summary>
    /// description of the metric, which can be used in documentation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Description {
      get { return description_; }
      set {
        description_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "unit" field.</summary>
    public const int UnitFieldNumber = 3;
    private string unit_ = "";
    /// <summary>
    /// unit in which the metric value is reported. Follows the format
    /// described by https://unitsofmeasure.org/ucum.html.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public string Unit {
      get { return unit_; }
      set {
        unit_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "gauge" field.</summary>
    public const int GaugeFieldNumber = 5;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::OpenTelemetry.Proto.Metrics.V1.Gauge Gauge {
      get { return dataCase_ == DataOneofCase.Gauge ? (global::OpenTelemetry.Proto.Metrics.V1.Gauge) data_ : null; }
      set {
        data_ = value;
        dataCase_ = value == null ? DataOneofCase.None : DataOneofCase.Gauge;
      }
    }

    /// <summary>Field number for the "sum" field.</summary>
    public const int SumFieldNumber = 7;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::OpenTelemetry.Proto.Metrics.V1.Sum Sum {
      get { return dataCase_ == DataOneofCase.Sum ? (global::OpenTelemetry.Proto.Metrics.V1.Sum) data_ : null; }
      set {
        data_ = value;
        dataCase_ = value == null ? DataOneofCase.None : DataOneofCase.Sum;
      }
    }

    /// <summary>Field number for the "histogram" field.</summary>
    public const int HistogramFieldNumber = 9;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::OpenTelemetry.Proto.Metrics.V1.Histogram Histogram {
      get { return dataCase_ == DataOneofCase.Histogram ? (global::OpenTelemetry.Proto.Metrics.V1.Histogram) data_ : null; }
      set {
        data_ = value;
        dataCase_ = value == null ? DataOneofCase.None : DataOneofCase.Histogram;
      }
    }

    /// <summary>Field number for the "exponential_histogram" field.</summary>
    public const int ExponentialHistogramFieldNumber = 10;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogram ExponentialHistogram {
      get { return dataCase_ == DataOneofCase.ExponentialHistogram ? (global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogram) data_ : null; }
      set {
        data_ = value;
        dataCase_ = value == null ? DataOneofCase.None : DataOneofCase.ExponentialHistogram;
      }
    }

    /// <summary>Field number for the "summary" field.</summary>
    public const int SummaryFieldNumber = 11;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::OpenTelemetry.Proto.Metrics.V1.Summary Summary {
      get { return dataCase_ == DataOneofCase.Summary ? (global::OpenTelemetry.Proto.Metrics.V1.Summary) data_ : null; }
      set {
        data_ = value;
        dataCase_ = value == null ? DataOneofCase.None : DataOneofCase.Summary;
      }
    }

    /// <summary>Field number for the "metadata" field.</summary>
    public const int MetadataFieldNumber = 12;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Common.V1.KeyValue> _repeated_metadata_codec
        = pb::FieldCodec.ForMessage(98, global::OpenTelemetry.Proto.Common.V1.KeyValue.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue> metadata_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue>();
    /// <summary>
    /// Additional metadata attributes that describe the metric. [Optional].
    /// Attributes are non-identifying.
    /// Consumers SHOULD NOT need to be aware of these attributes.
    /// These attributes MAY be used to encode information allowing
    /// for lossless roundtrip translation to / from another data model.
    /// Attribute keys MUST be unique (it is not allowed to have more than one
    /// attribute with the same key).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue> Metadata {
      get { return metadata_; }
    }

    private object data_;
    /// <summary>Enum of possible cases for the "data" oneof.</summary>
    public enum DataOneofCase {
      None = 0,
      Gauge = 5,
      Sum = 7,
      Histogram = 9,
      ExponentialHistogram = 10,
      Summary = 11,
    }
    private DataOneofCase dataCase_ = DataOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public DataOneofCase DataCase {
      get { return dataCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearData() {
      dataCase_ = DataOneofCase.None;
      data_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Metric);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Metric other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (Description != other.Description) return false;
      if (Unit != other.Unit) return false;
      if (!object.Equals(Gauge, other.Gauge)) return false;
      if (!object.Equals(Sum, other.Sum)) return false;
      if (!object.Equals(Histogram, other.Histogram)) return false;
      if (!object.Equals(ExponentialHistogram, other.ExponentialHistogram)) return false;
      if (!object.Equals(Summary, other.Summary)) return false;
      if(!metadata_.Equals(other.metadata_)) return false;
      if (DataCase != other.DataCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Description.Length != 0) hash ^= Description.GetHashCode();
      if (Unit.Length != 0) hash ^= Unit.GetHashCode();
      if (dataCase_ == DataOneofCase.Gauge) hash ^= Gauge.GetHashCode();
      if (dataCase_ == DataOneofCase.Sum) hash ^= Sum.GetHashCode();
      if (dataCase_ == DataOneofCase.Histogram) hash ^= Histogram.GetHashCode();
      if (dataCase_ == DataOneofCase.ExponentialHistogram) hash ^= ExponentialHistogram.GetHashCode();
      if (dataCase_ == DataOneofCase.Summary) hash ^= Summary.GetHashCode();
      hash ^= metadata_.GetHashCode();
      hash ^= (int) dataCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Description);
      }
      if (Unit.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Unit);
      }
      if (dataCase_ == DataOneofCase.Gauge) {
        output.WriteRawTag(42);
        output.WriteMessage(Gauge);
      }
      if (dataCase_ == DataOneofCase.Sum) {
        output.WriteRawTag(58);
        output.WriteMessage(Sum);
      }
      if (dataCase_ == DataOneofCase.Histogram) {
        output.WriteRawTag(74);
        output.WriteMessage(Histogram);
      }
      if (dataCase_ == DataOneofCase.ExponentialHistogram) {
        output.WriteRawTag(82);
        output.WriteMessage(ExponentialHistogram);
      }
      if (dataCase_ == DataOneofCase.Summary) {
        output.WriteRawTag(90);
        output.WriteMessage(Summary);
      }
      metadata_.WriteTo(output, _repeated_metadata_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (Description.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Description);
      }
      if (Unit.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Unit);
      }
      if (dataCase_ == DataOneofCase.Gauge) {
        output.WriteRawTag(42);
        output.WriteMessage(Gauge);
      }
      if (dataCase_ == DataOneofCase.Sum) {
        output.WriteRawTag(58);
        output.WriteMessage(Sum);
      }
      if (dataCase_ == DataOneofCase.Histogram) {
        output.WriteRawTag(74);
        output.WriteMessage(Histogram);
      }
      if (dataCase_ == DataOneofCase.ExponentialHistogram) {
        output.WriteRawTag(82);
        output.WriteMessage(ExponentialHistogram);
      }
      if (dataCase_ == DataOneofCase.Summary) {
        output.WriteRawTag(90);
        output.WriteMessage(Summary);
      }
      metadata_.WriteTo(ref output, _repeated_metadata_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Description.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Description);
      }
      if (Unit.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Unit);
      }
      if (dataCase_ == DataOneofCase.Gauge) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Gauge);
      }
      if (dataCase_ == DataOneofCase.Sum) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Sum);
      }
      if (dataCase_ == DataOneofCase.Histogram) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Histogram);
      }
      if (dataCase_ == DataOneofCase.ExponentialHistogram) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExponentialHistogram);
      }
      if (dataCase_ == DataOneofCase.Summary) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Summary);
      }
      size += metadata_.CalculateSize(_repeated_metadata_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Metric other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Description.Length != 0) {
        Description = other.Description;
      }
      if (other.Unit.Length != 0) {
        Unit = other.Unit;
      }
      metadata_.Add(other.metadata_);
      switch (other.DataCase) {
        case DataOneofCase.Gauge:
          if (Gauge == null) {
            Gauge = new global::OpenTelemetry.Proto.Metrics.V1.Gauge();
          }
          Gauge.MergeFrom(other.Gauge);
          break;
        case DataOneofCase.Sum:
          if (Sum == null) {
            Sum = new global::OpenTelemetry.Proto.Metrics.V1.Sum();
          }
          Sum.MergeFrom(other.Sum);
          break;
        case DataOneofCase.Histogram:
          if (Histogram == null) {
            Histogram = new global::OpenTelemetry.Proto.Metrics.V1.Histogram();
          }
          Histogram.MergeFrom(other.Histogram);
          break;
        case DataOneofCase.ExponentialHistogram:
          if (ExponentialHistogram == null) {
            ExponentialHistogram = new global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogram();
          }
          ExponentialHistogram.MergeFrom(other.ExponentialHistogram);
          break;
        case DataOneofCase.Summary:
          if (Summary == null) {
            Summary = new global::OpenTelemetry.Proto.Metrics.V1.Summary();
          }
          Summary.MergeFrom(other.Summary);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Description = input.ReadString();
            break;
          }
          case 26: {
            Unit = input.ReadString();
            break;
          }
          case 42: {
            global::OpenTelemetry.Proto.Metrics.V1.Gauge subBuilder = new global::OpenTelemetry.Proto.Metrics.V1.Gauge();
            if (dataCase_ == DataOneofCase.Gauge) {
              subBuilder.MergeFrom(Gauge);
            }
            input.ReadMessage(subBuilder);
            Gauge = subBuilder;
            break;
          }
          case 58: {
            global::OpenTelemetry.Proto.Metrics.V1.Sum subBuilder = new global::OpenTelemetry.Proto.Metrics.V1.Sum();
            if (dataCase_ == DataOneofCase.Sum) {
              subBuilder.MergeFrom(Sum);
            }
            input.ReadMessage(subBuilder);
            Sum = subBuilder;
            break;
          }
          case 74: {
            global::OpenTelemetry.Proto.Metrics.V1.Histogram subBuilder = new global::OpenTelemetry.Proto.Metrics.V1.Histogram();
            if (dataCase_ == DataOneofCase.Histogram) {
              subBuilder.MergeFrom(Histogram);
            }
            input.ReadMessage(subBuilder);
            Histogram = subBuilder;
            break;
          }
          case 82: {
            global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogram subBuilder = new global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogram();
            if (dataCase_ == DataOneofCase.ExponentialHistogram) {
              subBuilder.MergeFrom(ExponentialHistogram);
            }
            input.ReadMessage(subBuilder);
            ExponentialHistogram = subBuilder;
            break;
          }
          case 90: {
            global::OpenTelemetry.Proto.Metrics.V1.Summary subBuilder = new global::OpenTelemetry.Proto.Metrics.V1.Summary();
            if (dataCase_ == DataOneofCase.Summary) {
              subBuilder.MergeFrom(Summary);
            }
            input.ReadMessage(subBuilder);
            Summary = subBuilder;
            break;
          }
          case 98: {
            metadata_.AddEntriesFrom(input, _repeated_metadata_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            Description = input.ReadString();
            break;
          }
          case 26: {
            Unit = input.ReadString();
            break;
          }
          case 42: {
            global::OpenTelemetry.Proto.Metrics.V1.Gauge subBuilder = new global::OpenTelemetry.Proto.Metrics.V1.Gauge();
            if (dataCase_ == DataOneofCase.Gauge) {
              subBuilder.MergeFrom(Gauge);
            }
            input.ReadMessage(subBuilder);
            Gauge = subBuilder;
            break;
          }
          case 58: {
            global::OpenTelemetry.Proto.Metrics.V1.Sum subBuilder = new global::OpenTelemetry.Proto.Metrics.V1.Sum();
            if (dataCase_ == DataOneofCase.Sum) {
              subBuilder.MergeFrom(Sum);
            }
            input.ReadMessage(subBuilder);
            Sum = subBuilder;
            break;
          }
          case 74: {
            global::OpenTelemetry.Proto.Metrics.V1.Histogram subBuilder = new global::OpenTelemetry.Proto.Metrics.V1.Histogram();
            if (dataCase_ == DataOneofCase.Histogram) {
              subBuilder.MergeFrom(Histogram);
            }
            input.ReadMessage(subBuilder);
            Histogram = subBuilder;
            break;
          }
          case 82: {
            global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogram subBuilder = new global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogram();
            if (dataCase_ == DataOneofCase.ExponentialHistogram) {
              subBuilder.MergeFrom(ExponentialHistogram);
            }
            input.ReadMessage(subBuilder);
            ExponentialHistogram = subBuilder;
            break;
          }
          case 90: {
            global::OpenTelemetry.Proto.Metrics.V1.Summary subBuilder = new global::OpenTelemetry.Proto.Metrics.V1.Summary();
            if (dataCase_ == DataOneofCase.Summary) {
              subBuilder.MergeFrom(Summary);
            }
            input.ReadMessage(subBuilder);
            Summary = subBuilder;
            break;
          }
          case 98: {
            metadata_.AddEntriesFrom(ref input, _repeated_metadata_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Gauge represents the type of a scalar metric that always exports the
  /// "current value" for every data point. It should be used for an "unknown"
  /// aggregation.
  ///
  /// A Gauge does not support different aggregation temporalities. Given the
  /// aggregation is unknown, points cannot be combined using the same
  /// aggregation, regardless of aggregation temporalities. Therefore,
  /// AggregationTemporality is not included. Consequently, this also means
  /// "StartTimeUnixNano" is ignored for all data points.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Gauge : pb::IMessage<Gauge>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Gauge> _parser = new pb::MessageParser<Gauge>(() => new Gauge());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Gauge> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::OpenTelemetry.Proto.Metrics.V1.MetricsReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Gauge() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Gauge(Gauge other) : this() {
      dataPoints_ = other.dataPoints_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Gauge Clone() {
      return new Gauge(this);
    }

    /// <summary>Field number for the "data_points" field.</summary>
    public const int DataPointsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Metrics.V1.NumberDataPoint> _repeated_dataPoints_codec
        = pb::FieldCodec.ForMessage(10, global::OpenTelemetry.Proto.Metrics.V1.NumberDataPoint.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.NumberDataPoint> dataPoints_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.NumberDataPoint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.NumberDataPoint> DataPoints {
      get { return dataPoints_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Gauge);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Gauge other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!dataPoints_.Equals(other.dataPoints_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= dataPoints_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      dataPoints_.WriteTo(output, _repeated_dataPoints_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      dataPoints_.WriteTo(ref output, _repeated_dataPoints_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += dataPoints_.CalculateSize(_repeated_dataPoints_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Gauge other) {
      if (other == null) {
        return;
      }
      dataPoints_.Add(other.dataPoints_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            dataPoints_.AddEntriesFrom(input, _repeated_dataPoints_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            dataPoints_.AddEntriesFrom(ref input, _repeated_dataPoints_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Sum represents the type of a scalar metric that is calculated as a sum of all
  /// reported measurements over a time interval.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Sum : pb::IMessage<Sum>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Sum> _parser = new pb::MessageParser<Sum>(() => new Sum());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Sum> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::OpenTelemetry.Proto.Metrics.V1.MetricsReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Sum() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Sum(Sum other) : this() {
      dataPoints_ = other.dataPoints_.Clone();
      aggregationTemporality_ = other.aggregationTemporality_;
      isMonotonic_ = other.isMonotonic_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Sum Clone() {
      return new Sum(this);
    }

    /// <summary>Field number for the "data_points" field.</summary>
    public const int DataPointsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Metrics.V1.NumberDataPoint> _repeated_dataPoints_codec
        = pb::FieldCodec.ForMessage(10, global::OpenTelemetry.Proto.Metrics.V1.NumberDataPoint.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.NumberDataPoint> dataPoints_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.NumberDataPoint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.NumberDataPoint> DataPoints {
      get { return dataPoints_; }
    }

    /// <summary>Field number for the "aggregation_temporality" field.</summary>
    public const int AggregationTemporalityFieldNumber = 2;
    private global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality aggregationTemporality_ = global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified;
    /// <summary>
    /// aggregation_temporality describes if the aggregator reports delta changes
    /// since last report time, or cumulative changes since a fixed start time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality AggregationTemporality {
      get { return aggregationTemporality_; }
      set {
        aggregationTemporality_ = value;
      }
    }

    /// <summary>Field number for the "is_monotonic" field.</summary>
    public const int IsMonotonicFieldNumber = 3;
    private bool isMonotonic_;
    /// <summary>
    /// If "true" means that the sum is monotonic.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool IsMonotonic {
      get { return isMonotonic_; }
      set {
        isMonotonic_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Sum);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Sum other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!dataPoints_.Equals(other.dataPoints_)) return false;
      if (AggregationTemporality != other.AggregationTemporality) return false;
      if (IsMonotonic != other.IsMonotonic) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= dataPoints_.GetHashCode();
      if (AggregationTemporality != global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified) hash ^= AggregationTemporality.GetHashCode();
      if (IsMonotonic != false) hash ^= IsMonotonic.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      dataPoints_.WriteTo(output, _repeated_dataPoints_codec);
      if (AggregationTemporality != global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) AggregationTemporality);
      }
      if (IsMonotonic != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsMonotonic);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      dataPoints_.WriteTo(ref output, _repeated_dataPoints_codec);
      if (AggregationTemporality != global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) AggregationTemporality);
      }
      if (IsMonotonic != false) {
        output.WriteRawTag(24);
        output.WriteBool(IsMonotonic);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += dataPoints_.CalculateSize(_repeated_dataPoints_codec);
      if (AggregationTemporality != global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) AggregationTemporality);
      }
      if (IsMonotonic != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Sum other) {
      if (other == null) {
        return;
      }
      dataPoints_.Add(other.dataPoints_);
      if (other.AggregationTemporality != global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified) {
        AggregationTemporality = other.AggregationTemporality;
      }
      if (other.IsMonotonic != false) {
        IsMonotonic = other.IsMonotonic;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            dataPoints_.AddEntriesFrom(input, _repeated_dataPoints_codec);
            break;
          }
          case 16: {
            AggregationTemporality = (global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality) input.ReadEnum();
            break;
          }
          case 24: {
            IsMonotonic = input.ReadBool();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            dataPoints_.AddEntriesFrom(ref input, _repeated_dataPoints_codec);
            break;
          }
          case 16: {
            AggregationTemporality = (global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality) input.ReadEnum();
            break;
          }
          case 24: {
            IsMonotonic = input.ReadBool();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Histogram represents the type of a metric that is calculated by aggregating
  /// as a Histogram of all reported measurements over a time interval.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Histogram : pb::IMessage<Histogram>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Histogram> _parser = new pb::MessageParser<Histogram>(() => new Histogram());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Histogram> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::OpenTelemetry.Proto.Metrics.V1.MetricsReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Histogram() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Histogram(Histogram other) : this() {
      dataPoints_ = other.dataPoints_.Clone();
      aggregationTemporality_ = other.aggregationTemporality_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Histogram Clone() {
      return new Histogram(this);
    }

    /// <summary>Field number for the "data_points" field.</summary>
    public const int DataPointsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Metrics.V1.HistogramDataPoint> _repeated_dataPoints_codec
        = pb::FieldCodec.ForMessage(10, global::OpenTelemetry.Proto.Metrics.V1.HistogramDataPoint.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.HistogramDataPoint> dataPoints_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.HistogramDataPoint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.HistogramDataPoint> DataPoints {
      get { return dataPoints_; }
    }

    /// <summary>Field number for the "aggregation_temporality" field.</summary>
    public const int AggregationTemporalityFieldNumber = 2;
    private global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality aggregationTemporality_ = global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified;
    /// <summary>
    /// aggregation_temporality describes if the aggregator reports delta changes
    /// since last report time, or cumulative changes since a fixed start time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality AggregationTemporality {
      get { return aggregationTemporality_; }
      set {
        aggregationTemporality_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Histogram);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Histogram other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!dataPoints_.Equals(other.dataPoints_)) return false;
      if (AggregationTemporality != other.AggregationTemporality) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= dataPoints_.GetHashCode();
      if (AggregationTemporality != global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified) hash ^= AggregationTemporality.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      dataPoints_.WriteTo(output, _repeated_dataPoints_codec);
      if (AggregationTemporality != global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) AggregationTemporality);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      dataPoints_.WriteTo(ref output, _repeated_dataPoints_codec);
      if (AggregationTemporality != global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) AggregationTemporality);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += dataPoints_.CalculateSize(_repeated_dataPoints_codec);
      if (AggregationTemporality != global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) AggregationTemporality);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Histogram other) {
      if (other == null) {
        return;
      }
      dataPoints_.Add(other.dataPoints_);
      if (other.AggregationTemporality != global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified) {
        AggregationTemporality = other.AggregationTemporality;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            dataPoints_.AddEntriesFrom(input, _repeated_dataPoints_codec);
            break;
          }
          case 16: {
            AggregationTemporality = (global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            dataPoints_.AddEntriesFrom(ref input, _repeated_dataPoints_codec);
            break;
          }
          case 16: {
            AggregationTemporality = (global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ExponentialHistogram represents the type of a metric that is calculated by aggregating
  /// as a ExponentialHistogram of all reported double measurements over a time interval.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ExponentialHistogram : pb::IMessage<ExponentialHistogram>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ExponentialHistogram> _parser = new pb::MessageParser<ExponentialHistogram>(() => new ExponentialHistogram());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ExponentialHistogram> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::OpenTelemetry.Proto.Metrics.V1.MetricsReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExponentialHistogram() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExponentialHistogram(ExponentialHistogram other) : this() {
      dataPoints_ = other.dataPoints_.Clone();
      aggregationTemporality_ = other.aggregationTemporality_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExponentialHistogram Clone() {
      return new ExponentialHistogram(this);
    }

    /// <summary>Field number for the "data_points" field.</summary>
    public const int DataPointsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint> _repeated_dataPoints_codec
        = pb::FieldCodec.ForMessage(10, global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint> dataPoints_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint> DataPoints {
      get { return dataPoints_; }
    }

    /// <summary>Field number for the "aggregation_temporality" field.</summary>
    public const int AggregationTemporalityFieldNumber = 2;
    private global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality aggregationTemporality_ = global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified;
    /// <summary>
    /// aggregation_temporality describes if the aggregator reports delta changes
    /// since last report time, or cumulative changes since a fixed start time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality AggregationTemporality {
      get { return aggregationTemporality_; }
      set {
        aggregationTemporality_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ExponentialHistogram);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ExponentialHistogram other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!dataPoints_.Equals(other.dataPoints_)) return false;
      if (AggregationTemporality != other.AggregationTemporality) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= dataPoints_.GetHashCode();
      if (AggregationTemporality != global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified) hash ^= AggregationTemporality.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      dataPoints_.WriteTo(output, _repeated_dataPoints_codec);
      if (AggregationTemporality != global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) AggregationTemporality);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      dataPoints_.WriteTo(ref output, _repeated_dataPoints_codec);
      if (AggregationTemporality != global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified) {
        output.WriteRawTag(16);
        output.WriteEnum((int) AggregationTemporality);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += dataPoints_.CalculateSize(_repeated_dataPoints_codec);
      if (AggregationTemporality != global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) AggregationTemporality);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ExponentialHistogram other) {
      if (other == null) {
        return;
      }
      dataPoints_.Add(other.dataPoints_);
      if (other.AggregationTemporality != global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality.Unspecified) {
        AggregationTemporality = other.AggregationTemporality;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            dataPoints_.AddEntriesFrom(input, _repeated_dataPoints_codec);
            break;
          }
          case 16: {
            AggregationTemporality = (global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality) input.ReadEnum();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            dataPoints_.AddEntriesFrom(ref input, _repeated_dataPoints_codec);
            break;
          }
          case 16: {
            AggregationTemporality = (global::OpenTelemetry.Proto.Metrics.V1.AggregationTemporality) input.ReadEnum();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// Summary metric data are used to convey quantile summaries,
  /// a Prometheus (see: https://prometheus.io/docs/concepts/metric_types/#summary)
  /// and OpenMetrics (see: https://github.com/prometheus/OpenMetrics/blob/4dbf6075567ab43296eed941037c12951faafb92/protos/prometheus.proto#L45)
  /// data type. These data points cannot always be merged in a meaningful way.
  /// While they can be useful in some applications, histogram data points are
  /// recommended for new applications.
  /// Summary metrics do not have an aggregation temporality field. This is
  /// because the count and sum fields of a SummaryDataPoint are assumed to be
  /// cumulative values.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Summary : pb::IMessage<Summary>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Summary> _parser = new pb::MessageParser<Summary>(() => new Summary());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Summary> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::OpenTelemetry.Proto.Metrics.V1.MetricsReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Summary() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Summary(Summary other) : this() {
      dataPoints_ = other.dataPoints_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Summary Clone() {
      return new Summary(this);
    }

    /// <summary>Field number for the "data_points" field.</summary>
    public const int DataPointsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Metrics.V1.SummaryDataPoint> _repeated_dataPoints_codec
        = pb::FieldCodec.ForMessage(10, global::OpenTelemetry.Proto.Metrics.V1.SummaryDataPoint.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.SummaryDataPoint> dataPoints_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.SummaryDataPoint>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.SummaryDataPoint> DataPoints {
      get { return dataPoints_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Summary);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Summary other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!dataPoints_.Equals(other.dataPoints_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= dataPoints_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      dataPoints_.WriteTo(output, _repeated_dataPoints_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      dataPoints_.WriteTo(ref output, _repeated_dataPoints_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += dataPoints_.CalculateSize(_repeated_dataPoints_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Summary other) {
      if (other == null) {
        return;
      }
      dataPoints_.Add(other.dataPoints_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            dataPoints_.AddEntriesFrom(input, _repeated_dataPoints_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            dataPoints_.AddEntriesFrom(ref input, _repeated_dataPoints_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// NumberDataPoint is a single data point in a timeseries that describes the
  /// time-varying scalar value of a metric.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class NumberDataPoint : pb::IMessage<NumberDataPoint>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<NumberDataPoint> _parser = new pb::MessageParser<NumberDataPoint>(() => new NumberDataPoint());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<NumberDataPoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::OpenTelemetry.Proto.Metrics.V1.MetricsReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NumberDataPoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NumberDataPoint(NumberDataPoint other) : this() {
      attributes_ = other.attributes_.Clone();
      startTimeUnixNano_ = other.startTimeUnixNano_;
      timeUnixNano_ = other.timeUnixNano_;
      exemplars_ = other.exemplars_.Clone();
      flags_ = other.flags_;
      switch (other.ValueCase) {
        case ValueOneofCase.AsDouble:
          AsDouble = other.AsDouble;
          break;
        case ValueOneofCase.AsInt:
          AsInt = other.AsInt;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public NumberDataPoint Clone() {
      return new NumberDataPoint(this);
    }

    /// <summary>Field number for the "attributes" field.</summary>
    public const int AttributesFieldNumber = 7;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Common.V1.KeyValue> _repeated_attributes_codec
        = pb::FieldCodec.ForMessage(58, global::OpenTelemetry.Proto.Common.V1.KeyValue.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue> attributes_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue>();
    /// <summary>
    /// The set of key/value pairs that uniquely identify the timeseries from
    /// where this point belongs. The list may be empty (may contain 0 elements).
    /// Attribute keys MUST be unique (it is not allowed to have more than one
    /// attribute with the same key).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue> Attributes {
      get { return attributes_; }
    }

    /// <summary>Field number for the "start_time_unix_nano" field.</summary>
    public const int StartTimeUnixNanoFieldNumber = 2;
    private ulong startTimeUnixNano_;
    /// <summary>
    /// StartTimeUnixNano is optional but strongly encouraged, see the
    /// the detailed comments above Metric.
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong StartTimeUnixNano {
      get { return startTimeUnixNano_; }
      set {
        startTimeUnixNano_ = value;
      }
    }

    /// <summary>Field number for the "time_unix_nano" field.</summary>
    public const int TimeUnixNanoFieldNumber = 3;
    private ulong timeUnixNano_;
    /// <summary>
    /// TimeUnixNano is required, see the detailed comments above Metric.
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong TimeUnixNano {
      get { return timeUnixNano_; }
      set {
        timeUnixNano_ = value;
      }
    }

    /// <summary>Field number for the "as_double" field.</summary>
    public const int AsDoubleFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double AsDouble {
      get { return HasAsDouble ? (double) value_ : 0D; }
      set {
        value_ = value;
        valueCase_ = ValueOneofCase.AsDouble;
      }
    }
    /// <summary>Gets whether the "as_double" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAsDouble {
      get { return valueCase_ == ValueOneofCase.AsDouble; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "as_double" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAsDouble() {
      if (HasAsDouble) {
        ClearValue();
      }
    }

    /// <summary>Field number for the "as_int" field.</summary>
    public const int AsIntFieldNumber = 6;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long AsInt {
      get { return HasAsInt ? (long) value_ : 0L; }
      set {
        value_ = value;
        valueCase_ = ValueOneofCase.AsInt;
      }
    }
    /// <summary>Gets whether the "as_int" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAsInt {
      get { return valueCase_ == ValueOneofCase.AsInt; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "as_int" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAsInt() {
      if (HasAsInt) {
        ClearValue();
      }
    }

    /// <summary>Field number for the "exemplars" field.</summary>
    public const int ExemplarsFieldNumber = 5;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Metrics.V1.Exemplar> _repeated_exemplars_codec
        = pb::FieldCodec.ForMessage(42, global::OpenTelemetry.Proto.Metrics.V1.Exemplar.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.Exemplar> exemplars_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.Exemplar>();
    /// <summary>
    /// (Optional) List of exemplars collected from
    /// measurements that were used to form the data point
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.Exemplar> Exemplars {
      get { return exemplars_; }
    }

    /// <summary>Field number for the "flags" field.</summary>
    public const int FlagsFieldNumber = 8;
    private uint flags_;
    /// <summary>
    /// Flags that apply to this specific data point.  See DataPointFlags
    /// for the available flags and their meaning.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Flags {
      get { return flags_; }
      set {
        flags_ = value;
      }
    }

    private object value_;
    /// <summary>Enum of possible cases for the "value" oneof.</summary>
    public enum ValueOneofCase {
      None = 0,
      AsDouble = 4,
      AsInt = 6,
    }
    private ValueOneofCase valueCase_ = ValueOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ValueOneofCase ValueCase {
      get { return valueCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearValue() {
      valueCase_ = ValueOneofCase.None;
      value_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as NumberDataPoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(NumberDataPoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!attributes_.Equals(other.attributes_)) return false;
      if (StartTimeUnixNano != other.StartTimeUnixNano) return false;
      if (TimeUnixNano != other.TimeUnixNano) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(AsDouble, other.AsDouble)) return false;
      if (AsInt != other.AsInt) return false;
      if(!exemplars_.Equals(other.exemplars_)) return false;
      if (Flags != other.Flags) return false;
      if (ValueCase != other.ValueCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= attributes_.GetHashCode();
      if (StartTimeUnixNano != 0UL) hash ^= StartTimeUnixNano.GetHashCode();
      if (TimeUnixNano != 0UL) hash ^= TimeUnixNano.GetHashCode();
      if (HasAsDouble) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(AsDouble);
      if (HasAsInt) hash ^= AsInt.GetHashCode();
      hash ^= exemplars_.GetHashCode();
      if (Flags != 0) hash ^= Flags.GetHashCode();
      hash ^= (int) valueCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (StartTimeUnixNano != 0UL) {
        output.WriteRawTag(17);
        output.WriteFixed64(StartTimeUnixNano);
      }
      if (TimeUnixNano != 0UL) {
        output.WriteRawTag(25);
        output.WriteFixed64(TimeUnixNano);
      }
      if (HasAsDouble) {
        output.WriteRawTag(33);
        output.WriteDouble(AsDouble);
      }
      exemplars_.WriteTo(output, _repeated_exemplars_codec);
      if (HasAsInt) {
        output.WriteRawTag(49);
        output.WriteSFixed64(AsInt);
      }
      attributes_.WriteTo(output, _repeated_attributes_codec);
      if (Flags != 0) {
        output.WriteRawTag(64);
        output.WriteUInt32(Flags);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (StartTimeUnixNano != 0UL) {
        output.WriteRawTag(17);
        output.WriteFixed64(StartTimeUnixNano);
      }
      if (TimeUnixNano != 0UL) {
        output.WriteRawTag(25);
        output.WriteFixed64(TimeUnixNano);
      }
      if (HasAsDouble) {
        output.WriteRawTag(33);
        output.WriteDouble(AsDouble);
      }
      exemplars_.WriteTo(ref output, _repeated_exemplars_codec);
      if (HasAsInt) {
        output.WriteRawTag(49);
        output.WriteSFixed64(AsInt);
      }
      attributes_.WriteTo(ref output, _repeated_attributes_codec);
      if (Flags != 0) {
        output.WriteRawTag(64);
        output.WriteUInt32(Flags);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += attributes_.CalculateSize(_repeated_attributes_codec);
      if (StartTimeUnixNano != 0UL) {
        size += 1 + 8;
      }
      if (TimeUnixNano != 0UL) {
        size += 1 + 8;
      }
      if (HasAsDouble) {
        size += 1 + 8;
      }
      if (HasAsInt) {
        size += 1 + 8;
      }
      size += exemplars_.CalculateSize(_repeated_exemplars_codec);
      if (Flags != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Flags);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(NumberDataPoint other) {
      if (other == null) {
        return;
      }
      attributes_.Add(other.attributes_);
      if (other.StartTimeUnixNano != 0UL) {
        StartTimeUnixNano = other.StartTimeUnixNano;
      }
      if (other.TimeUnixNano != 0UL) {
        TimeUnixNano = other.TimeUnixNano;
      }
      exemplars_.Add(other.exemplars_);
      if (other.Flags != 0) {
        Flags = other.Flags;
      }
      switch (other.ValueCase) {
        case ValueOneofCase.AsDouble:
          AsDouble = other.AsDouble;
          break;
        case ValueOneofCase.AsInt:
          AsInt = other.AsInt;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 17: {
            StartTimeUnixNano = input.ReadFixed64();
            break;
          }
          case 25: {
            TimeUnixNano = input.ReadFixed64();
            break;
          }
          case 33: {
            AsDouble = input.ReadDouble();
            break;
          }
          case 42: {
            exemplars_.AddEntriesFrom(input, _repeated_exemplars_codec);
            break;
          }
          case 49: {
            AsInt = input.ReadSFixed64();
            break;
          }
          case 58: {
            attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
            break;
          }
          case 64: {
            Flags = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 17: {
            StartTimeUnixNano = input.ReadFixed64();
            break;
          }
          case 25: {
            TimeUnixNano = input.ReadFixed64();
            break;
          }
          case 33: {
            AsDouble = input.ReadDouble();
            break;
          }
          case 42: {
            exemplars_.AddEntriesFrom(ref input, _repeated_exemplars_codec);
            break;
          }
          case 49: {
            AsInt = input.ReadSFixed64();
            break;
          }
          case 58: {
            attributes_.AddEntriesFrom(ref input, _repeated_attributes_codec);
            break;
          }
          case 64: {
            Flags = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// HistogramDataPoint is a single data point in a timeseries that describes the
  /// time-varying values of a Histogram. A Histogram contains summary statistics
  /// for a population of values, it may optionally contain the distribution of
  /// those values across a set of buckets.
  ///
  /// If the histogram contains the distribution of values, then both
  /// "explicit_bounds" and "bucket counts" fields must be defined.
  /// If the histogram does not contain the distribution of values, then both
  /// "explicit_bounds" and "bucket_counts" must be omitted and only "count" and
  /// "sum" are known.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class HistogramDataPoint : pb::IMessage<HistogramDataPoint>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<HistogramDataPoint> _parser = new pb::MessageParser<HistogramDataPoint>(() => new HistogramDataPoint());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<HistogramDataPoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::OpenTelemetry.Proto.Metrics.V1.MetricsReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HistogramDataPoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HistogramDataPoint(HistogramDataPoint other) : this() {
      _hasBits0 = other._hasBits0;
      attributes_ = other.attributes_.Clone();
      startTimeUnixNano_ = other.startTimeUnixNano_;
      timeUnixNano_ = other.timeUnixNano_;
      count_ = other.count_;
      sum_ = other.sum_;
      bucketCounts_ = other.bucketCounts_.Clone();
      explicitBounds_ = other.explicitBounds_.Clone();
      exemplars_ = other.exemplars_.Clone();
      flags_ = other.flags_;
      min_ = other.min_;
      max_ = other.max_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public HistogramDataPoint Clone() {
      return new HistogramDataPoint(this);
    }

    /// <summary>Field number for the "attributes" field.</summary>
    public const int AttributesFieldNumber = 9;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Common.V1.KeyValue> _repeated_attributes_codec
        = pb::FieldCodec.ForMessage(74, global::OpenTelemetry.Proto.Common.V1.KeyValue.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue> attributes_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue>();
    /// <summary>
    /// The set of key/value pairs that uniquely identify the timeseries from
    /// where this point belongs. The list may be empty (may contain 0 elements).
    /// Attribute keys MUST be unique (it is not allowed to have more than one
    /// attribute with the same key).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue> Attributes {
      get { return attributes_; }
    }

    /// <summary>Field number for the "start_time_unix_nano" field.</summary>
    public const int StartTimeUnixNanoFieldNumber = 2;
    private ulong startTimeUnixNano_;
    /// <summary>
    /// StartTimeUnixNano is optional but strongly encouraged, see the
    /// the detailed comments above Metric.
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong StartTimeUnixNano {
      get { return startTimeUnixNano_; }
      set {
        startTimeUnixNano_ = value;
      }
    }

    /// <summary>Field number for the "time_unix_nano" field.</summary>
    public const int TimeUnixNanoFieldNumber = 3;
    private ulong timeUnixNano_;
    /// <summary>
    /// TimeUnixNano is required, see the detailed comments above Metric.
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong TimeUnixNano {
      get { return timeUnixNano_; }
      set {
        timeUnixNano_ = value;
      }
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 4;
    private ulong count_;
    /// <summary>
    /// count is the number of values in the population. Must be non-negative. This
    /// value must be equal to the sum of the "count" fields in buckets if a
    /// histogram is provided.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Count {
      get { return count_; }
      set {
        count_ = value;
      }
    }

    /// <summary>Field number for the "sum" field.</summary>
    public const int SumFieldNumber = 5;
    private readonly static double SumDefaultValue = 0D;

    private double sum_;
    /// <summary>
    /// sum of the values in the population. If count is zero then this field
    /// must be zero.
    ///
    /// Note: Sum should only be filled out when measuring non-negative discrete
    /// events, and is assumed to be monotonic over the values of these events.
    /// Negative events *can* be recorded, but sum should not be filled out when
    /// doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
    /// see: https://github.com/prometheus/OpenMetrics/blob/v1.0.0/specification/OpenMetrics.md#histogram
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Sum {
      get { if ((_hasBits0 & 1) != 0) { return sum_; } else { return SumDefaultValue; } }
      set {
        _hasBits0 |= 1;
        sum_ = value;
      }
    }
    /// <summary>Gets whether the "sum" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSum {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "sum" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSum() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "bucket_counts" field.</summary>
    public const int BucketCountsFieldNumber = 6;
    private static readonly pb::FieldCodec<ulong> _repeated_bucketCounts_codec
        = pb::FieldCodec.ForFixed64(50);
    private readonly pbc::RepeatedField<ulong> bucketCounts_ = new pbc::RepeatedField<ulong>();
    /// <summary>
    /// bucket_counts is an optional field contains the count values of histogram
    /// for each bucket.
    ///
    /// The sum of the bucket_counts must equal the value in the count field.
    ///
    /// The number of elements in bucket_counts array must be by one greater than
    /// the number of elements in explicit_bounds array. The exception to this rule
    /// is when the length of bucket_counts is 0, then the length of explicit_bounds
    /// must also be 0.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<ulong> BucketCounts {
      get { return bucketCounts_; }
    }

    /// <summary>Field number for the "explicit_bounds" field.</summary>
    public const int ExplicitBoundsFieldNumber = 7;
    private static readonly pb::FieldCodec<double> _repeated_explicitBounds_codec
        = pb::FieldCodec.ForDouble(58);
    private readonly pbc::RepeatedField<double> explicitBounds_ = new pbc::RepeatedField<double>();
    /// <summary>
    /// explicit_bounds specifies buckets with explicitly defined bounds for values.
    ///
    /// The boundaries for bucket at index i are:
    ///
    /// (-infinity, explicit_bounds[i]] for i == 0
    /// (explicit_bounds[i-1], explicit_bounds[i]] for 0 &lt; i &lt; size(explicit_bounds)
    /// (explicit_bounds[i-1], +infinity) for i == size(explicit_bounds)
    ///
    /// The values in the explicit_bounds array must be strictly increasing.
    ///
    /// Histogram buckets are inclusive of their upper boundary, except the last
    /// bucket where the boundary is at infinity. This format is intentionally
    /// compatible with the OpenMetrics histogram definition.
    ///
    /// If bucket_counts length is 0 then explicit_bounds length must also be 0,
    /// otherwise the data point is invalid.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<double> ExplicitBounds {
      get { return explicitBounds_; }
    }

    /// <summary>Field number for the "exemplars" field.</summary>
    public const int ExemplarsFieldNumber = 8;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Metrics.V1.Exemplar> _repeated_exemplars_codec
        = pb::FieldCodec.ForMessage(66, global::OpenTelemetry.Proto.Metrics.V1.Exemplar.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.Exemplar> exemplars_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.Exemplar>();
    /// <summary>
    /// (Optional) List of exemplars collected from
    /// measurements that were used to form the data point
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.Exemplar> Exemplars {
      get { return exemplars_; }
    }

    /// <summary>Field number for the "flags" field.</summary>
    public const int FlagsFieldNumber = 10;
    private uint flags_;
    /// <summary>
    /// Flags that apply to this specific data point.  See DataPointFlags
    /// for the available flags and their meaning.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Flags {
      get { return flags_; }
      set {
        flags_ = value;
      }
    }

    /// <summary>Field number for the "min" field.</summary>
    public const int MinFieldNumber = 11;
    private readonly static double MinDefaultValue = 0D;

    private double min_;
    /// <summary>
    /// min is the minimum value over (start_time, end_time].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Min {
      get { if ((_hasBits0 & 2) != 0) { return min_; } else { return MinDefaultValue; } }
      set {
        _hasBits0 |= 2;
        min_ = value;
      }
    }
    /// <summary>Gets whether the "min" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMin {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "min" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMin() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "max" field.</summary>
    public const int MaxFieldNumber = 12;
    private readonly static double MaxDefaultValue = 0D;

    private double max_;
    /// <summary>
    /// max is the maximum value over (start_time, end_time].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Max {
      get { if ((_hasBits0 & 4) != 0) { return max_; } else { return MaxDefaultValue; } }
      set {
        _hasBits0 |= 4;
        max_ = value;
      }
    }
    /// <summary>Gets whether the "max" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMax {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "max" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMax() {
      _hasBits0 &= ~4;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as HistogramDataPoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(HistogramDataPoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!attributes_.Equals(other.attributes_)) return false;
      if (StartTimeUnixNano != other.StartTimeUnixNano) return false;
      if (TimeUnixNano != other.TimeUnixNano) return false;
      if (Count != other.Count) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Sum, other.Sum)) return false;
      if(!bucketCounts_.Equals(other.bucketCounts_)) return false;
      if(!explicitBounds_.Equals(other.explicitBounds_)) return false;
      if(!exemplars_.Equals(other.exemplars_)) return false;
      if (Flags != other.Flags) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Min, other.Min)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Max, other.Max)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= attributes_.GetHashCode();
      if (StartTimeUnixNano != 0UL) hash ^= StartTimeUnixNano.GetHashCode();
      if (TimeUnixNano != 0UL) hash ^= TimeUnixNano.GetHashCode();
      if (Count != 0UL) hash ^= Count.GetHashCode();
      if (HasSum) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Sum);
      hash ^= bucketCounts_.GetHashCode();
      hash ^= explicitBounds_.GetHashCode();
      hash ^= exemplars_.GetHashCode();
      if (Flags != 0) hash ^= Flags.GetHashCode();
      if (HasMin) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Min);
      if (HasMax) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Max);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (StartTimeUnixNano != 0UL) {
        output.WriteRawTag(17);
        output.WriteFixed64(StartTimeUnixNano);
      }
      if (TimeUnixNano != 0UL) {
        output.WriteRawTag(25);
        output.WriteFixed64(TimeUnixNano);
      }
      if (Count != 0UL) {
        output.WriteRawTag(33);
        output.WriteFixed64(Count);
      }
      if (HasSum) {
        output.WriteRawTag(41);
        output.WriteDouble(Sum);
      }
      bucketCounts_.WriteTo(output, _repeated_bucketCounts_codec);
      explicitBounds_.WriteTo(output, _repeated_explicitBounds_codec);
      exemplars_.WriteTo(output, _repeated_exemplars_codec);
      attributes_.WriteTo(output, _repeated_attributes_codec);
      if (Flags != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(Flags);
      }
      if (HasMin) {
        output.WriteRawTag(89);
        output.WriteDouble(Min);
      }
      if (HasMax) {
        output.WriteRawTag(97);
        output.WriteDouble(Max);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (StartTimeUnixNano != 0UL) {
        output.WriteRawTag(17);
        output.WriteFixed64(StartTimeUnixNano);
      }
      if (TimeUnixNano != 0UL) {
        output.WriteRawTag(25);
        output.WriteFixed64(TimeUnixNano);
      }
      if (Count != 0UL) {
        output.WriteRawTag(33);
        output.WriteFixed64(Count);
      }
      if (HasSum) {
        output.WriteRawTag(41);
        output.WriteDouble(Sum);
      }
      bucketCounts_.WriteTo(ref output, _repeated_bucketCounts_codec);
      explicitBounds_.WriteTo(ref output, _repeated_explicitBounds_codec);
      exemplars_.WriteTo(ref output, _repeated_exemplars_codec);
      attributes_.WriteTo(ref output, _repeated_attributes_codec);
      if (Flags != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(Flags);
      }
      if (HasMin) {
        output.WriteRawTag(89);
        output.WriteDouble(Min);
      }
      if (HasMax) {
        output.WriteRawTag(97);
        output.WriteDouble(Max);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += attributes_.CalculateSize(_repeated_attributes_codec);
      if (StartTimeUnixNano != 0UL) {
        size += 1 + 8;
      }
      if (TimeUnixNano != 0UL) {
        size += 1 + 8;
      }
      if (Count != 0UL) {
        size += 1 + 8;
      }
      if (HasSum) {
        size += 1 + 8;
      }
      size += bucketCounts_.CalculateSize(_repeated_bucketCounts_codec);
      size += explicitBounds_.CalculateSize(_repeated_explicitBounds_codec);
      size += exemplars_.CalculateSize(_repeated_exemplars_codec);
      if (Flags != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Flags);
      }
      if (HasMin) {
        size += 1 + 8;
      }
      if (HasMax) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(HistogramDataPoint other) {
      if (other == null) {
        return;
      }
      attributes_.Add(other.attributes_);
      if (other.StartTimeUnixNano != 0UL) {
        StartTimeUnixNano = other.StartTimeUnixNano;
      }
      if (other.TimeUnixNano != 0UL) {
        TimeUnixNano = other.TimeUnixNano;
      }
      if (other.Count != 0UL) {
        Count = other.Count;
      }
      if (other.HasSum) {
        Sum = other.Sum;
      }
      bucketCounts_.Add(other.bucketCounts_);
      explicitBounds_.Add(other.explicitBounds_);
      exemplars_.Add(other.exemplars_);
      if (other.Flags != 0) {
        Flags = other.Flags;
      }
      if (other.HasMin) {
        Min = other.Min;
      }
      if (other.HasMax) {
        Max = other.Max;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 17: {
            StartTimeUnixNano = input.ReadFixed64();
            break;
          }
          case 25: {
            TimeUnixNano = input.ReadFixed64();
            break;
          }
          case 33: {
            Count = input.ReadFixed64();
            break;
          }
          case 41: {
            Sum = input.ReadDouble();
            break;
          }
          case 50:
          case 49: {
            bucketCounts_.AddEntriesFrom(input, _repeated_bucketCounts_codec);
            break;
          }
          case 58:
          case 57: {
            explicitBounds_.AddEntriesFrom(input, _repeated_explicitBounds_codec);
            break;
          }
          case 66: {
            exemplars_.AddEntriesFrom(input, _repeated_exemplars_codec);
            break;
          }
          case 74: {
            attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
            break;
          }
          case 80: {
            Flags = input.ReadUInt32();
            break;
          }
          case 89: {
            Min = input.ReadDouble();
            break;
          }
          case 97: {
            Max = input.ReadDouble();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 17: {
            StartTimeUnixNano = input.ReadFixed64();
            break;
          }
          case 25: {
            TimeUnixNano = input.ReadFixed64();
            break;
          }
          case 33: {
            Count = input.ReadFixed64();
            break;
          }
          case 41: {
            Sum = input.ReadDouble();
            break;
          }
          case 50:
          case 49: {
            bucketCounts_.AddEntriesFrom(ref input, _repeated_bucketCounts_codec);
            break;
          }
          case 58:
          case 57: {
            explicitBounds_.AddEntriesFrom(ref input, _repeated_explicitBounds_codec);
            break;
          }
          case 66: {
            exemplars_.AddEntriesFrom(ref input, _repeated_exemplars_codec);
            break;
          }
          case 74: {
            attributes_.AddEntriesFrom(ref input, _repeated_attributes_codec);
            break;
          }
          case 80: {
            Flags = input.ReadUInt32();
            break;
          }
          case 89: {
            Min = input.ReadDouble();
            break;
          }
          case 97: {
            Max = input.ReadDouble();
            break;
          }
        }
      }
    }
    #endif

  }

  /// <summary>
  /// ExponentialHistogramDataPoint is a single data point in a timeseries that describes the
  /// time-varying values of a ExponentialHistogram of double values. A ExponentialHistogram contains
  /// summary statistics for a population of values, it may optionally contain the
  /// distribution of those values across a set of buckets.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class ExponentialHistogramDataPoint : pb::IMessage<ExponentialHistogramDataPoint>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<ExponentialHistogramDataPoint> _parser = new pb::MessageParser<ExponentialHistogramDataPoint>(() => new ExponentialHistogramDataPoint());
    private pb::UnknownFieldSet _unknownFields;
    private int _hasBits0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<ExponentialHistogramDataPoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::OpenTelemetry.Proto.Metrics.V1.MetricsReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExponentialHistogramDataPoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExponentialHistogramDataPoint(ExponentialHistogramDataPoint other) : this() {
      _hasBits0 = other._hasBits0;
      attributes_ = other.attributes_.Clone();
      startTimeUnixNano_ = other.startTimeUnixNano_;
      timeUnixNano_ = other.timeUnixNano_;
      count_ = other.count_;
      sum_ = other.sum_;
      scale_ = other.scale_;
      zeroCount_ = other.zeroCount_;
      positive_ = other.positive_ != null ? other.positive_.Clone() : null;
      negative_ = other.negative_ != null ? other.negative_.Clone() : null;
      flags_ = other.flags_;
      exemplars_ = other.exemplars_.Clone();
      min_ = other.min_;
      max_ = other.max_;
      zeroThreshold_ = other.zeroThreshold_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ExponentialHistogramDataPoint Clone() {
      return new ExponentialHistogramDataPoint(this);
    }

    /// <summary>Field number for the "attributes" field.</summary>
    public const int AttributesFieldNumber = 1;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Common.V1.KeyValue> _repeated_attributes_codec
        = pb::FieldCodec.ForMessage(10, global::OpenTelemetry.Proto.Common.V1.KeyValue.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue> attributes_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue>();
    /// <summary>
    /// The set of key/value pairs that uniquely identify the timeseries from
    /// where this point belongs. The list may be empty (may contain 0 elements).
    /// Attribute keys MUST be unique (it is not allowed to have more than one
    /// attribute with the same key).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue> Attributes {
      get { return attributes_; }
    }

    /// <summary>Field number for the "start_time_unix_nano" field.</summary>
    public const int StartTimeUnixNanoFieldNumber = 2;
    private ulong startTimeUnixNano_;
    /// <summary>
    /// StartTimeUnixNano is optional but strongly encouraged, see the
    /// the detailed comments above Metric.
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong StartTimeUnixNano {
      get { return startTimeUnixNano_; }
      set {
        startTimeUnixNano_ = value;
      }
    }

    /// <summary>Field number for the "time_unix_nano" field.</summary>
    public const int TimeUnixNanoFieldNumber = 3;
    private ulong timeUnixNano_;
    /// <summary>
    /// TimeUnixNano is required, see the detailed comments above Metric.
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong TimeUnixNano {
      get { return timeUnixNano_; }
      set {
        timeUnixNano_ = value;
      }
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 4;
    private ulong count_;
    /// <summary>
    /// count is the number of values in the population. Must be
    /// non-negative. This value must be equal to the sum of the "bucket_counts"
    /// values in the positive and negative Buckets plus the "zero_count" field.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Count {
      get { return count_; }
      set {
        count_ = value;
      }
    }

    /// <summary>Field number for the "sum" field.</summary>
    public const int SumFieldNumber = 5;
    private readonly static double SumDefaultValue = 0D;

    private double sum_;
    /// <summary>
    /// sum of the values in the population. If count is zero then this field
    /// must be zero.
    ///
    /// Note: Sum should only be filled out when measuring non-negative discrete
    /// events, and is assumed to be monotonic over the values of these events.
    /// Negative events *can* be recorded, but sum should not be filled out when
    /// doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
    /// see: https://github.com/prometheus/OpenMetrics/blob/v1.0.0/specification/OpenMetrics.md#histogram
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Sum {
      get { if ((_hasBits0 & 1) != 0) { return sum_; } else { return SumDefaultValue; } }
      set {
        _hasBits0 |= 1;
        sum_ = value;
      }
    }
    /// <summary>Gets whether the "sum" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasSum {
      get { return (_hasBits0 & 1) != 0; }
    }
    /// <summary>Clears the value of the "sum" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearSum() {
      _hasBits0 &= ~1;
    }

    /// <summary>Field number for the "scale" field.</summary>
    public const int ScaleFieldNumber = 6;
    private int scale_;
    /// <summary>
    /// scale describes the resolution of the histogram.  Boundaries are
    /// located at powers of the base, where:
    ///
    ///   base = (2^(2^-scale))
    ///
    /// The histogram bucket identified by `index`, a signed integer,
    /// contains values that are greater than (base^index) and
    /// less than or equal to (base^(index+1)).
    ///
    /// The positive and negative ranges of the histogram are expressed
    /// separately.  Negative values are mapped by their absolute value
    /// into the negative range using the same scale as the positive range.
    ///
    /// scale is not restricted by the protocol, as the permissible
    /// values depend on the range of the data.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int Scale {
      get { return scale_; }
      set {
        scale_ = value;
      }
    }

    /// <summary>Field number for the "zero_count" field.</summary>
    public const int ZeroCountFieldNumber = 7;
    private ulong zeroCount_;
    /// <summary>
    /// zero_count is the count of values that are either exactly zero or
    /// within the region considered zero by the instrumentation at the
    /// tolerated degree of precision.  This bucket stores values that
    /// cannot be expressed using the standard exponential formula as
    /// well as values that have been rounded to zero.
    ///
    /// Implementations MAY consider the zero bucket to have probability
    /// mass equal to (zero_count / count).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong ZeroCount {
      get { return zeroCount_; }
      set {
        zeroCount_ = value;
      }
    }

    /// <summary>Field number for the "positive" field.</summary>
    public const int PositiveFieldNumber = 8;
    private global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint.Types.Buckets positive_;
    /// <summary>
    /// positive carries the positive range of exponential bucket counts.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint.Types.Buckets Positive {
      get { return positive_; }
      set {
        positive_ = value;
      }
    }

    /// <summary>Field number for the "negative" field.</summary>
    public const int NegativeFieldNumber = 9;
    private global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint.Types.Buckets negative_;
    /// <summary>
    /// negative carries the negative range of exponential bucket counts.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint.Types.Buckets Negative {
      get { return negative_; }
      set {
        negative_ = value;
      }
    }

    /// <summary>Field number for the "flags" field.</summary>
    public const int FlagsFieldNumber = 10;
    private uint flags_;
    /// <summary>
    /// Flags that apply to this specific data point.  See DataPointFlags
    /// for the available flags and their meaning.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Flags {
      get { return flags_; }
      set {
        flags_ = value;
      }
    }

    /// <summary>Field number for the "exemplars" field.</summary>
    public const int ExemplarsFieldNumber = 11;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Metrics.V1.Exemplar> _repeated_exemplars_codec
        = pb::FieldCodec.ForMessage(90, global::OpenTelemetry.Proto.Metrics.V1.Exemplar.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.Exemplar> exemplars_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.Exemplar>();
    /// <summary>
    /// (Optional) List of exemplars collected from
    /// measurements that were used to form the data point
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.Exemplar> Exemplars {
      get { return exemplars_; }
    }

    /// <summary>Field number for the "min" field.</summary>
    public const int MinFieldNumber = 12;
    private readonly static double MinDefaultValue = 0D;

    private double min_;
    /// <summary>
    /// min is the minimum value over (start_time, end_time].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Min {
      get { if ((_hasBits0 & 2) != 0) { return min_; } else { return MinDefaultValue; } }
      set {
        _hasBits0 |= 2;
        min_ = value;
      }
    }
    /// <summary>Gets whether the "min" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMin {
      get { return (_hasBits0 & 2) != 0; }
    }
    /// <summary>Clears the value of the "min" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMin() {
      _hasBits0 &= ~2;
    }

    /// <summary>Field number for the "max" field.</summary>
    public const int MaxFieldNumber = 13;
    private readonly static double MaxDefaultValue = 0D;

    private double max_;
    /// <summary>
    /// max is the maximum value over (start_time, end_time].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Max {
      get { if ((_hasBits0 & 4) != 0) { return max_; } else { return MaxDefaultValue; } }
      set {
        _hasBits0 |= 4;
        max_ = value;
      }
    }
    /// <summary>Gets whether the "max" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasMax {
      get { return (_hasBits0 & 4) != 0; }
    }
    /// <summary>Clears the value of the "max" field</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearMax() {
      _hasBits0 &= ~4;
    }

    /// <summary>Field number for the "zero_threshold" field.</summary>
    public const int ZeroThresholdFieldNumber = 14;
    private double zeroThreshold_;
    /// <summary>
    /// ZeroThreshold may be optionally set to convey the width of the zero
    /// region. Where the zero region is defined as the closed interval
    /// [-ZeroThreshold, ZeroThreshold].
    /// When ZeroThreshold is 0, zero count bucket stores values that cannot be
    /// expressed using the standard exponential formula as well as values that
    /// have been rounded to zero.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double ZeroThreshold {
      get { return zeroThreshold_; }
      set {
        zeroThreshold_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as ExponentialHistogramDataPoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(ExponentialHistogramDataPoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!attributes_.Equals(other.attributes_)) return false;
      if (StartTimeUnixNano != other.StartTimeUnixNano) return false;
      if (TimeUnixNano != other.TimeUnixNano) return false;
      if (Count != other.Count) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Sum, other.Sum)) return false;
      if (Scale != other.Scale) return false;
      if (ZeroCount != other.ZeroCount) return false;
      if (!object.Equals(Positive, other.Positive)) return false;
      if (!object.Equals(Negative, other.Negative)) return false;
      if (Flags != other.Flags) return false;
      if(!exemplars_.Equals(other.exemplars_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Min, other.Min)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Max, other.Max)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(ZeroThreshold, other.ZeroThreshold)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= attributes_.GetHashCode();
      if (StartTimeUnixNano != 0UL) hash ^= StartTimeUnixNano.GetHashCode();
      if (TimeUnixNano != 0UL) hash ^= TimeUnixNano.GetHashCode();
      if (Count != 0UL) hash ^= Count.GetHashCode();
      if (HasSum) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Sum);
      if (Scale != 0) hash ^= Scale.GetHashCode();
      if (ZeroCount != 0UL) hash ^= ZeroCount.GetHashCode();
      if (positive_ != null) hash ^= Positive.GetHashCode();
      if (negative_ != null) hash ^= Negative.GetHashCode();
      if (Flags != 0) hash ^= Flags.GetHashCode();
      hash ^= exemplars_.GetHashCode();
      if (HasMin) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Min);
      if (HasMax) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Max);
      if (ZeroThreshold != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(ZeroThreshold);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      attributes_.WriteTo(output, _repeated_attributes_codec);
      if (StartTimeUnixNano != 0UL) {
        output.WriteRawTag(17);
        output.WriteFixed64(StartTimeUnixNano);
      }
      if (TimeUnixNano != 0UL) {
        output.WriteRawTag(25);
        output.WriteFixed64(TimeUnixNano);
      }
      if (Count != 0UL) {
        output.WriteRawTag(33);
        output.WriteFixed64(Count);
      }
      if (HasSum) {
        output.WriteRawTag(41);
        output.WriteDouble(Sum);
      }
      if (Scale != 0) {
        output.WriteRawTag(48);
        output.WriteSInt32(Scale);
      }
      if (ZeroCount != 0UL) {
        output.WriteRawTag(57);
        output.WriteFixed64(ZeroCount);
      }
      if (positive_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Positive);
      }
      if (negative_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Negative);
      }
      if (Flags != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(Flags);
      }
      exemplars_.WriteTo(output, _repeated_exemplars_codec);
      if (HasMin) {
        output.WriteRawTag(97);
        output.WriteDouble(Min);
      }
      if (HasMax) {
        output.WriteRawTag(105);
        output.WriteDouble(Max);
      }
      if (ZeroThreshold != 0D) {
        output.WriteRawTag(113);
        output.WriteDouble(ZeroThreshold);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      attributes_.WriteTo(ref output, _repeated_attributes_codec);
      if (StartTimeUnixNano != 0UL) {
        output.WriteRawTag(17);
        output.WriteFixed64(StartTimeUnixNano);
      }
      if (TimeUnixNano != 0UL) {
        output.WriteRawTag(25);
        output.WriteFixed64(TimeUnixNano);
      }
      if (Count != 0UL) {
        output.WriteRawTag(33);
        output.WriteFixed64(Count);
      }
      if (HasSum) {
        output.WriteRawTag(41);
        output.WriteDouble(Sum);
      }
      if (Scale != 0) {
        output.WriteRawTag(48);
        output.WriteSInt32(Scale);
      }
      if (ZeroCount != 0UL) {
        output.WriteRawTag(57);
        output.WriteFixed64(ZeroCount);
      }
      if (positive_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(Positive);
      }
      if (negative_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(Negative);
      }
      if (Flags != 0) {
        output.WriteRawTag(80);
        output.WriteUInt32(Flags);
      }
      exemplars_.WriteTo(ref output, _repeated_exemplars_codec);
      if (HasMin) {
        output.WriteRawTag(97);
        output.WriteDouble(Min);
      }
      if (HasMax) {
        output.WriteRawTag(105);
        output.WriteDouble(Max);
      }
      if (ZeroThreshold != 0D) {
        output.WriteRawTag(113);
        output.WriteDouble(ZeroThreshold);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += attributes_.CalculateSize(_repeated_attributes_codec);
      if (StartTimeUnixNano != 0UL) {
        size += 1 + 8;
      }
      if (TimeUnixNano != 0UL) {
        size += 1 + 8;
      }
      if (Count != 0UL) {
        size += 1 + 8;
      }
      if (HasSum) {
        size += 1 + 8;
      }
      if (Scale != 0) {
        size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Scale);
      }
      if (ZeroCount != 0UL) {
        size += 1 + 8;
      }
      if (positive_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Positive);
      }
      if (negative_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Negative);
      }
      if (Flags != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Flags);
      }
      size += exemplars_.CalculateSize(_repeated_exemplars_codec);
      if (HasMin) {
        size += 1 + 8;
      }
      if (HasMax) {
        size += 1 + 8;
      }
      if (ZeroThreshold != 0D) {
        size += 1 + 8;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(ExponentialHistogramDataPoint other) {
      if (other == null) {
        return;
      }
      attributes_.Add(other.attributes_);
      if (other.StartTimeUnixNano != 0UL) {
        StartTimeUnixNano = other.StartTimeUnixNano;
      }
      if (other.TimeUnixNano != 0UL) {
        TimeUnixNano = other.TimeUnixNano;
      }
      if (other.Count != 0UL) {
        Count = other.Count;
      }
      if (other.HasSum) {
        Sum = other.Sum;
      }
      if (other.Scale != 0) {
        Scale = other.Scale;
      }
      if (other.ZeroCount != 0UL) {
        ZeroCount = other.ZeroCount;
      }
      if (other.positive_ != null) {
        if (positive_ == null) {
          Positive = new global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint.Types.Buckets();
        }
        Positive.MergeFrom(other.Positive);
      }
      if (other.negative_ != null) {
        if (negative_ == null) {
          Negative = new global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint.Types.Buckets();
        }
        Negative.MergeFrom(other.Negative);
      }
      if (other.Flags != 0) {
        Flags = other.Flags;
      }
      exemplars_.Add(other.exemplars_);
      if (other.HasMin) {
        Min = other.Min;
      }
      if (other.HasMax) {
        Max = other.Max;
      }
      if (other.ZeroThreshold != 0D) {
        ZeroThreshold = other.ZeroThreshold;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
            break;
          }
          case 17: {
            StartTimeUnixNano = input.ReadFixed64();
            break;
          }
          case 25: {
            TimeUnixNano = input.ReadFixed64();
            break;
          }
          case 33: {
            Count = input.ReadFixed64();
            break;
          }
          case 41: {
            Sum = input.ReadDouble();
            break;
          }
          case 48: {
            Scale = input.ReadSInt32();
            break;
          }
          case 57: {
            ZeroCount = input.ReadFixed64();
            break;
          }
          case 66: {
            if (positive_ == null) {
              Positive = new global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint.Types.Buckets();
            }
            input.ReadMessage(Positive);
            break;
          }
          case 74: {
            if (negative_ == null) {
              Negative = new global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint.Types.Buckets();
            }
            input.ReadMessage(Negative);
            break;
          }
          case 80: {
            Flags = input.ReadUInt32();
            break;
          }
          case 90: {
            exemplars_.AddEntriesFrom(input, _repeated_exemplars_codec);
            break;
          }
          case 97: {
            Min = input.ReadDouble();
            break;
          }
          case 105: {
            Max = input.ReadDouble();
            break;
          }
          case 113: {
            ZeroThreshold = input.ReadDouble();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 10: {
            attributes_.AddEntriesFrom(ref input, _repeated_attributes_codec);
            break;
          }
          case 17: {
            StartTimeUnixNano = input.ReadFixed64();
            break;
          }
          case 25: {
            TimeUnixNano = input.ReadFixed64();
            break;
          }
          case 33: {
            Count = input.ReadFixed64();
            break;
          }
          case 41: {
            Sum = input.ReadDouble();
            break;
          }
          case 48: {
            Scale = input.ReadSInt32();
            break;
          }
          case 57: {
            ZeroCount = input.ReadFixed64();
            break;
          }
          case 66: {
            if (positive_ == null) {
              Positive = new global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint.Types.Buckets();
            }
            input.ReadMessage(Positive);
            break;
          }
          case 74: {
            if (negative_ == null) {
              Negative = new global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint.Types.Buckets();
            }
            input.ReadMessage(Negative);
            break;
          }
          case 80: {
            Flags = input.ReadUInt32();
            break;
          }
          case 90: {
            exemplars_.AddEntriesFrom(ref input, _repeated_exemplars_codec);
            break;
          }
          case 97: {
            Min = input.ReadDouble();
            break;
          }
          case 105: {
            Max = input.ReadDouble();
            break;
          }
          case 113: {
            ZeroThreshold = input.ReadDouble();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the ExponentialHistogramDataPoint message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Buckets are a set of bucket counts, encoded in a contiguous array
      /// of counts.
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class Buckets : pb::IMessage<Buckets>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<Buckets> _parser = new pb::MessageParser<Buckets>(() => new Buckets());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<Buckets> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::OpenTelemetry.Proto.Metrics.V1.ExponentialHistogramDataPoint.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Buckets() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Buckets(Buckets other) : this() {
          offset_ = other.offset_;
          bucketCounts_ = other.bucketCounts_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public Buckets Clone() {
          return new Buckets(this);
        }

        /// <summary>Field number for the "offset" field.</summary>
        public const int OffsetFieldNumber = 1;
        private int offset_;
        /// <summary>
        /// Offset is the bucket index of the first entry in the bucket_counts array.
        ///
        /// Note: This uses a varint encoding as a simple form of compression.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int Offset {
          get { return offset_; }
          set {
            offset_ = value;
          }
        }

        /// <summary>Field number for the "bucket_counts" field.</summary>
        public const int BucketCountsFieldNumber = 2;
        private static readonly pb::FieldCodec<ulong> _repeated_bucketCounts_codec
            = pb::FieldCodec.ForUInt64(18);
        private readonly pbc::RepeatedField<ulong> bucketCounts_ = new pbc::RepeatedField<ulong>();
        /// <summary>
        /// bucket_counts is an array of count values, where bucket_counts[i] carries
        /// the count of the bucket at index (offset+i). bucket_counts[i] is the count
        /// of values greater than base^(offset+i) and less than or equal to
        /// base^(offset+i+1).
        ///
        /// Note: By contrast, the explicit HistogramDataPoint uses
        /// fixed64.  This field is expected to have many buckets,
        /// especially zeros, so uint64 has been selected to ensure
        /// varint encoding.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public pbc::RepeatedField<ulong> BucketCounts {
          get { return bucketCounts_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as Buckets);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(Buckets other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Offset != other.Offset) return false;
          if(!bucketCounts_.Equals(other.bucketCounts_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Offset != 0) hash ^= Offset.GetHashCode();
          hash ^= bucketCounts_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Offset != 0) {
            output.WriteRawTag(8);
            output.WriteSInt32(Offset);
          }
          bucketCounts_.WriteTo(output, _repeated_bucketCounts_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Offset != 0) {
            output.WriteRawTag(8);
            output.WriteSInt32(Offset);
          }
          bucketCounts_.WriteTo(ref output, _repeated_bucketCounts_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Offset != 0) {
            size += 1 + pb::CodedOutputStream.ComputeSInt32Size(Offset);
          }
          size += bucketCounts_.CalculateSize(_repeated_bucketCounts_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(Buckets other) {
          if (other == null) {
            return;
          }
          if (other.Offset != 0) {
            Offset = other.Offset;
          }
          bucketCounts_.Add(other.bucketCounts_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                Offset = input.ReadSInt32();
                break;
              }
              case 18:
              case 16: {
                bucketCounts_.AddEntriesFrom(input, _repeated_bucketCounts_codec);
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 8: {
                Offset = input.ReadSInt32();
                break;
              }
              case 18:
              case 16: {
                bucketCounts_.AddEntriesFrom(ref input, _repeated_bucketCounts_codec);
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// SummaryDataPoint is a single data point in a timeseries that describes the
  /// time-varying values of a Summary metric. The count and sum fields represent
  /// cumulative values.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class SummaryDataPoint : pb::IMessage<SummaryDataPoint>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<SummaryDataPoint> _parser = new pb::MessageParser<SummaryDataPoint>(() => new SummaryDataPoint());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<SummaryDataPoint> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::OpenTelemetry.Proto.Metrics.V1.MetricsReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SummaryDataPoint() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SummaryDataPoint(SummaryDataPoint other) : this() {
      attributes_ = other.attributes_.Clone();
      startTimeUnixNano_ = other.startTimeUnixNano_;
      timeUnixNano_ = other.timeUnixNano_;
      count_ = other.count_;
      sum_ = other.sum_;
      quantileValues_ = other.quantileValues_.Clone();
      flags_ = other.flags_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public SummaryDataPoint Clone() {
      return new SummaryDataPoint(this);
    }

    /// <summary>Field number for the "attributes" field.</summary>
    public const int AttributesFieldNumber = 7;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Common.V1.KeyValue> _repeated_attributes_codec
        = pb::FieldCodec.ForMessage(58, global::OpenTelemetry.Proto.Common.V1.KeyValue.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue> attributes_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue>();
    /// <summary>
    /// The set of key/value pairs that uniquely identify the timeseries from
    /// where this point belongs. The list may be empty (may contain 0 elements).
    /// Attribute keys MUST be unique (it is not allowed to have more than one
    /// attribute with the same key).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue> Attributes {
      get { return attributes_; }
    }

    /// <summary>Field number for the "start_time_unix_nano" field.</summary>
    public const int StartTimeUnixNanoFieldNumber = 2;
    private ulong startTimeUnixNano_;
    /// <summary>
    /// StartTimeUnixNano is optional but strongly encouraged, see the
    /// the detailed comments above Metric.
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong StartTimeUnixNano {
      get { return startTimeUnixNano_; }
      set {
        startTimeUnixNano_ = value;
      }
    }

    /// <summary>Field number for the "time_unix_nano" field.</summary>
    public const int TimeUnixNanoFieldNumber = 3;
    private ulong timeUnixNano_;
    /// <summary>
    /// TimeUnixNano is required, see the detailed comments above Metric.
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong TimeUnixNano {
      get { return timeUnixNano_; }
      set {
        timeUnixNano_ = value;
      }
    }

    /// <summary>Field number for the "count" field.</summary>
    public const int CountFieldNumber = 4;
    private ulong count_;
    /// <summary>
    /// count is the number of values in the population. Must be non-negative.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong Count {
      get { return count_; }
      set {
        count_ = value;
      }
    }

    /// <summary>Field number for the "sum" field.</summary>
    public const int SumFieldNumber = 5;
    private double sum_;
    /// <summary>
    /// sum of the values in the population. If count is zero then this field
    /// must be zero.
    ///
    /// Note: Sum should only be filled out when measuring non-negative discrete
    /// events, and is assumed to be monotonic over the values of these events.
    /// Negative events *can* be recorded, but sum should not be filled out when
    /// doing so.  This is specifically to enforce compatibility w/ OpenMetrics,
    /// see: https://github.com/prometheus/OpenMetrics/blob/v1.0.0/specification/OpenMetrics.md#summary
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double Sum {
      get { return sum_; }
      set {
        sum_ = value;
      }
    }

    /// <summary>Field number for the "quantile_values" field.</summary>
    public const int QuantileValuesFieldNumber = 6;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Metrics.V1.SummaryDataPoint.Types.ValueAtQuantile> _repeated_quantileValues_codec
        = pb::FieldCodec.ForMessage(50, global::OpenTelemetry.Proto.Metrics.V1.SummaryDataPoint.Types.ValueAtQuantile.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.SummaryDataPoint.Types.ValueAtQuantile> quantileValues_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.SummaryDataPoint.Types.ValueAtQuantile>();
    /// <summary>
    /// (Optional) list of values at different quantiles of the distribution calculated
    /// from the current snapshot. The quantiles must be strictly increasing.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Metrics.V1.SummaryDataPoint.Types.ValueAtQuantile> QuantileValues {
      get { return quantileValues_; }
    }

    /// <summary>Field number for the "flags" field.</summary>
    public const int FlagsFieldNumber = 8;
    private uint flags_;
    /// <summary>
    /// Flags that apply to this specific data point.  See DataPointFlags
    /// for the available flags and their meaning.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public uint Flags {
      get { return flags_; }
      set {
        flags_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as SummaryDataPoint);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(SummaryDataPoint other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!attributes_.Equals(other.attributes_)) return false;
      if (StartTimeUnixNano != other.StartTimeUnixNano) return false;
      if (TimeUnixNano != other.TimeUnixNano) return false;
      if (Count != other.Count) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Sum, other.Sum)) return false;
      if(!quantileValues_.Equals(other.quantileValues_)) return false;
      if (Flags != other.Flags) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= attributes_.GetHashCode();
      if (StartTimeUnixNano != 0UL) hash ^= StartTimeUnixNano.GetHashCode();
      if (TimeUnixNano != 0UL) hash ^= TimeUnixNano.GetHashCode();
      if (Count != 0UL) hash ^= Count.GetHashCode();
      if (Sum != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Sum);
      hash ^= quantileValues_.GetHashCode();
      if (Flags != 0) hash ^= Flags.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (StartTimeUnixNano != 0UL) {
        output.WriteRawTag(17);
        output.WriteFixed64(StartTimeUnixNano);
      }
      if (TimeUnixNano != 0UL) {
        output.WriteRawTag(25);
        output.WriteFixed64(TimeUnixNano);
      }
      if (Count != 0UL) {
        output.WriteRawTag(33);
        output.WriteFixed64(Count);
      }
      if (Sum != 0D) {
        output.WriteRawTag(41);
        output.WriteDouble(Sum);
      }
      quantileValues_.WriteTo(output, _repeated_quantileValues_codec);
      attributes_.WriteTo(output, _repeated_attributes_codec);
      if (Flags != 0) {
        output.WriteRawTag(64);
        output.WriteUInt32(Flags);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (StartTimeUnixNano != 0UL) {
        output.WriteRawTag(17);
        output.WriteFixed64(StartTimeUnixNano);
      }
      if (TimeUnixNano != 0UL) {
        output.WriteRawTag(25);
        output.WriteFixed64(TimeUnixNano);
      }
      if (Count != 0UL) {
        output.WriteRawTag(33);
        output.WriteFixed64(Count);
      }
      if (Sum != 0D) {
        output.WriteRawTag(41);
        output.WriteDouble(Sum);
      }
      quantileValues_.WriteTo(ref output, _repeated_quantileValues_codec);
      attributes_.WriteTo(ref output, _repeated_attributes_codec);
      if (Flags != 0) {
        output.WriteRawTag(64);
        output.WriteUInt32(Flags);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += attributes_.CalculateSize(_repeated_attributes_codec);
      if (StartTimeUnixNano != 0UL) {
        size += 1 + 8;
      }
      if (TimeUnixNano != 0UL) {
        size += 1 + 8;
      }
      if (Count != 0UL) {
        size += 1 + 8;
      }
      if (Sum != 0D) {
        size += 1 + 8;
      }
      size += quantileValues_.CalculateSize(_repeated_quantileValues_codec);
      if (Flags != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(Flags);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(SummaryDataPoint other) {
      if (other == null) {
        return;
      }
      attributes_.Add(other.attributes_);
      if (other.StartTimeUnixNano != 0UL) {
        StartTimeUnixNano = other.StartTimeUnixNano;
      }
      if (other.TimeUnixNano != 0UL) {
        TimeUnixNano = other.TimeUnixNano;
      }
      if (other.Count != 0UL) {
        Count = other.Count;
      }
      if (other.Sum != 0D) {
        Sum = other.Sum;
      }
      quantileValues_.Add(other.quantileValues_);
      if (other.Flags != 0) {
        Flags = other.Flags;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 17: {
            StartTimeUnixNano = input.ReadFixed64();
            break;
          }
          case 25: {
            TimeUnixNano = input.ReadFixed64();
            break;
          }
          case 33: {
            Count = input.ReadFixed64();
            break;
          }
          case 41: {
            Sum = input.ReadDouble();
            break;
          }
          case 50: {
            quantileValues_.AddEntriesFrom(input, _repeated_quantileValues_codec);
            break;
          }
          case 58: {
            attributes_.AddEntriesFrom(input, _repeated_attributes_codec);
            break;
          }
          case 64: {
            Flags = input.ReadUInt32();
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 17: {
            StartTimeUnixNano = input.ReadFixed64();
            break;
          }
          case 25: {
            TimeUnixNano = input.ReadFixed64();
            break;
          }
          case 33: {
            Count = input.ReadFixed64();
            break;
          }
          case 41: {
            Sum = input.ReadDouble();
            break;
          }
          case 50: {
            quantileValues_.AddEntriesFrom(ref input, _repeated_quantileValues_codec);
            break;
          }
          case 58: {
            attributes_.AddEntriesFrom(ref input, _repeated_attributes_codec);
            break;
          }
          case 64: {
            Flags = input.ReadUInt32();
            break;
          }
        }
      }
    }
    #endif

    #region Nested types
    /// <summary>Container for nested types declared in the SummaryDataPoint message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static partial class Types {
      /// <summary>
      /// Represents the value at a given quantile of a distribution.
      ///
      /// To record Min and Max values following conventions are used:
      /// - The 1.0 quantile is equivalent to the maximum value observed.
      /// - The 0.0 quantile is equivalent to the minimum value observed.
      ///
      /// See the following issue for more context:
      /// https://github.com/open-telemetry/opentelemetry-proto/issues/125
      /// </summary>
      [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
      public sealed partial class ValueAtQuantile : pb::IMessage<ValueAtQuantile>
      #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          , pb::IBufferMessage
      #endif
      {
        private static readonly pb::MessageParser<ValueAtQuantile> _parser = new pb::MessageParser<ValueAtQuantile>(() => new ValueAtQuantile());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pb::MessageParser<ValueAtQuantile> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::OpenTelemetry.Proto.Metrics.V1.SummaryDataPoint.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ValueAtQuantile() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ValueAtQuantile(ValueAtQuantile other) : this() {
          quantile_ = other.quantile_;
          value_ = other.value_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public ValueAtQuantile Clone() {
          return new ValueAtQuantile(this);
        }

        /// <summary>Field number for the "quantile" field.</summary>
        public const int QuantileFieldNumber = 1;
        private double quantile_;
        /// <summary>
        /// The quantile of a distribution. Must be in the interval
        /// [0.0, 1.0].
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public double Quantile {
          get { return quantile_; }
          set {
            quantile_ = value;
          }
        }

        /// <summary>Field number for the "value" field.</summary>
        public const int ValueFieldNumber = 2;
        private double value_;
        /// <summary>
        /// The value at the given quantile of a distribution.
        ///
        /// Quantile values must NOT be negative.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public double Value {
          get { return value_; }
          set {
            value_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override bool Equals(object other) {
          return Equals(other as ValueAtQuantile);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public bool Equals(ValueAtQuantile other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Quantile, other.Quantile)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(Value, other.Value)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override int GetHashCode() {
          int hash = 1;
          if (Quantile != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Quantile);
          if (Value != 0D) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(Value);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void WriteTo(pb::CodedOutputStream output) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          output.WriteRawMessage(this);
        #else
          if (Quantile != 0D) {
            output.WriteRawTag(9);
            output.WriteDouble(Quantile);
          }
          if (Value != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(Value);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
          if (Quantile != 0D) {
            output.WriteRawTag(9);
            output.WriteDouble(Quantile);
          }
          if (Value != 0D) {
            output.WriteRawTag(17);
            output.WriteDouble(Value);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(ref output);
          }
        }
        #endif

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public int CalculateSize() {
          int size = 0;
          if (Quantile != 0D) {
            size += 1 + 8;
          }
          if (Value != 0D) {
            size += 1 + 8;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(ValueAtQuantile other) {
          if (other == null) {
            return;
          }
          if (other.Quantile != 0D) {
            Quantile = other.Quantile;
          }
          if (other.Value != 0D) {
            Value = other.Value;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        public void MergeFrom(pb::CodedInputStream input) {
        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
          input.ReadRawMessage(this);
        #else
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 9: {
                Quantile = input.ReadDouble();
                break;
              }
              case 17: {
                Value = input.ReadDouble();
                break;
              }
            }
          }
        #endif
        }

        #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
        void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
          if ((tag & 7) == 4) {
            // Abort on any end group tag.
            return;
          }
          switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
                break;
              case 9: {
                Quantile = input.ReadDouble();
                break;
              }
              case 17: {
                Value = input.ReadDouble();
                break;
              }
            }
          }
        }
        #endif

      }

    }
    #endregion

  }

  /// <summary>
  /// A representation of an exemplar, which is a sample input measurement.
  /// Exemplars also hold information about the environment when the measurement
  /// was recorded, for example the span and trace ID of the active span when the
  /// exemplar was recorded.
  /// </summary>
  [global::System.Diagnostics.DebuggerDisplayAttribute("{ToString(),nq}")]
  public sealed partial class Exemplar : pb::IMessage<Exemplar>
  #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      , pb::IBufferMessage
  #endif
  {
    private static readonly pb::MessageParser<Exemplar> _parser = new pb::MessageParser<Exemplar>(() => new Exemplar());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pb::MessageParser<Exemplar> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::OpenTelemetry.Proto.Metrics.V1.MetricsReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Exemplar() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Exemplar(Exemplar other) : this() {
      filteredAttributes_ = other.filteredAttributes_.Clone();
      timeUnixNano_ = other.timeUnixNano_;
      spanId_ = other.spanId_;
      traceId_ = other.traceId_;
      switch (other.ValueCase) {
        case ValueOneofCase.AsDouble:
          AsDouble = other.AsDouble;
          break;
        case ValueOneofCase.AsInt:
          AsInt = other.AsInt;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public Exemplar Clone() {
      return new Exemplar(this);
    }

    /// <summary>Field number for the "filtered_attributes" field.</summary>
    public const int FilteredAttributesFieldNumber = 7;
    private static readonly pb::FieldCodec<global::OpenTelemetry.Proto.Common.V1.KeyValue> _repeated_filteredAttributes_codec
        = pb::FieldCodec.ForMessage(58, global::OpenTelemetry.Proto.Common.V1.KeyValue.Parser);
    private readonly pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue> filteredAttributes_ = new pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue>();
    /// <summary>
    /// The set of key/value pairs that were filtered out by the aggregator, but
    /// recorded alongside the original measurement. Only key/value pairs that were
    /// filtered out by the aggregator should be included
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pbc::RepeatedField<global::OpenTelemetry.Proto.Common.V1.KeyValue> FilteredAttributes {
      get { return filteredAttributes_; }
    }

    /// <summary>Field number for the "time_unix_nano" field.</summary>
    public const int TimeUnixNanoFieldNumber = 2;
    private ulong timeUnixNano_;
    /// <summary>
    /// time_unix_nano is the exact time when this exemplar was recorded
    ///
    /// Value is UNIX Epoch time in nanoseconds since 00:00:00 UTC on 1 January
    /// 1970.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ulong TimeUnixNano {
      get { return timeUnixNano_; }
      set {
        timeUnixNano_ = value;
      }
    }

    /// <summary>Field number for the "as_double" field.</summary>
    public const int AsDoubleFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public double AsDouble {
      get { return HasAsDouble ? (double) value_ : 0D; }
      set {
        value_ = value;
        valueCase_ = ValueOneofCase.AsDouble;
      }
    }
    /// <summary>Gets whether the "as_double" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAsDouble {
      get { return valueCase_ == ValueOneofCase.AsDouble; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "as_double" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAsDouble() {
      if (HasAsDouble) {
        ClearValue();
      }
    }

    /// <summary>Field number for the "as_int" field.</summary>
    public const int AsIntFieldNumber = 6;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public long AsInt {
      get { return HasAsInt ? (long) value_ : 0L; }
      set {
        value_ = value;
        valueCase_ = ValueOneofCase.AsInt;
      }
    }
    /// <summary>Gets whether the "as_int" field is set</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool HasAsInt {
      get { return valueCase_ == ValueOneofCase.AsInt; }
    }
    /// <summary> Clears the value of the oneof if it's currently set to "as_int" </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearAsInt() {
      if (HasAsInt) {
        ClearValue();
      }
    }

    /// <summary>Field number for the "span_id" field.</summary>
    public const int SpanIdFieldNumber = 4;
    private pb::ByteString spanId_ = pb::ByteString.Empty;
    /// <summary>
    /// (Optional) Span ID of the exemplar trace.
    /// span_id may be missing if the measurement is not recorded inside a trace
    /// or if the trace is not sampled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString SpanId {
      get { return spanId_; }
      set {
        spanId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "trace_id" field.</summary>
    public const int TraceIdFieldNumber = 5;
    private pb::ByteString traceId_ = pb::ByteString.Empty;
    /// <summary>
    /// (Optional) Trace ID of the exemplar trace.
    /// trace_id may be missing if the measurement is not recorded inside a trace
    /// or if the trace is not sampled.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public pb::ByteString TraceId {
      get { return traceId_; }
      set {
        traceId_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    private object value_;
    /// <summary>Enum of possible cases for the "value" oneof.</summary>
    public enum ValueOneofCase {
      None = 0,
      AsDouble = 3,
      AsInt = 6,
    }
    private ValueOneofCase valueCase_ = ValueOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public ValueOneofCase ValueCase {
      get { return valueCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void ClearValue() {
      valueCase_ = ValueOneofCase.None;
      value_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override bool Equals(object other) {
      return Equals(other as Exemplar);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public bool Equals(Exemplar other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!filteredAttributes_.Equals(other.filteredAttributes_)) return false;
      if (TimeUnixNano != other.TimeUnixNano) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.Equals(AsDouble, other.AsDouble)) return false;
      if (AsInt != other.AsInt) return false;
      if (SpanId != other.SpanId) return false;
      if (TraceId != other.TraceId) return false;
      if (ValueCase != other.ValueCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= filteredAttributes_.GetHashCode();
      if (TimeUnixNano != 0UL) hash ^= TimeUnixNano.GetHashCode();
      if (HasAsDouble) hash ^= pbc::ProtobufEqualityComparers.BitwiseDoubleEqualityComparer.GetHashCode(AsDouble);
      if (HasAsInt) hash ^= AsInt.GetHashCode();
      if (SpanId.Length != 0) hash ^= SpanId.GetHashCode();
      if (TraceId.Length != 0) hash ^= TraceId.GetHashCode();
      hash ^= (int) valueCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void WriteTo(pb::CodedOutputStream output) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      output.WriteRawMessage(this);
    #else
      if (TimeUnixNano != 0UL) {
        output.WriteRawTag(17);
        output.WriteFixed64(TimeUnixNano);
      }
      if (HasAsDouble) {
        output.WriteRawTag(25);
        output.WriteDouble(AsDouble);
      }
      if (SpanId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(SpanId);
      }
      if (TraceId.Length != 0) {
        output.WriteRawTag(42);
        output.WriteBytes(TraceId);
      }
      if (HasAsInt) {
        output.WriteRawTag(49);
        output.WriteSFixed64(AsInt);
      }
      filteredAttributes_.WriteTo(output, _repeated_filteredAttributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalWriteTo(ref pb::WriteContext output) {
      if (TimeUnixNano != 0UL) {
        output.WriteRawTag(17);
        output.WriteFixed64(TimeUnixNano);
      }
      if (HasAsDouble) {
        output.WriteRawTag(25);
        output.WriteDouble(AsDouble);
      }
      if (SpanId.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(SpanId);
      }
      if (TraceId.Length != 0) {
        output.WriteRawTag(42);
        output.WriteBytes(TraceId);
      }
      if (HasAsInt) {
        output.WriteRawTag(49);
        output.WriteSFixed64(AsInt);
      }
      filteredAttributes_.WriteTo(ref output, _repeated_filteredAttributes_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(ref output);
      }
    }
    #endif

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public int CalculateSize() {
      int size = 0;
      size += filteredAttributes_.CalculateSize(_repeated_filteredAttributes_codec);
      if (TimeUnixNano != 0UL) {
        size += 1 + 8;
      }
      if (HasAsDouble) {
        size += 1 + 8;
      }
      if (HasAsInt) {
        size += 1 + 8;
      }
      if (SpanId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(SpanId);
      }
      if (TraceId.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(TraceId);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(Exemplar other) {
      if (other == null) {
        return;
      }
      filteredAttributes_.Add(other.filteredAttributes_);
      if (other.TimeUnixNano != 0UL) {
        TimeUnixNano = other.TimeUnixNano;
      }
      if (other.SpanId.Length != 0) {
        SpanId = other.SpanId;
      }
      if (other.TraceId.Length != 0) {
        TraceId = other.TraceId;
      }
      switch (other.ValueCase) {
        case ValueOneofCase.AsDouble:
          AsDouble = other.AsDouble;
          break;
        case ValueOneofCase.AsInt:
          AsInt = other.AsInt;
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    public void MergeFrom(pb::CodedInputStream input) {
    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
      input.ReadRawMessage(this);
    #else
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 17: {
            TimeUnixNano = input.ReadFixed64();
            break;
          }
          case 25: {
            AsDouble = input.ReadDouble();
            break;
          }
          case 34: {
            SpanId = input.ReadBytes();
            break;
          }
          case 42: {
            TraceId = input.ReadBytes();
            break;
          }
          case 49: {
            AsInt = input.ReadSFixed64();
            break;
          }
          case 58: {
            filteredAttributes_.AddEntriesFrom(input, _repeated_filteredAttributes_codec);
            break;
          }
        }
      }
    #endif
    }

    #if !GOOGLE_PROTOBUF_REFSTRUCT_COMPATIBILITY_MODE
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    [global::System.CodeDom.Compiler.GeneratedCode("protoc", null)]
    void pb::IBufferMessage.InternalMergeFrom(ref pb::ParseContext input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
      if ((tag & 7) == 4) {
        // Abort on any end group tag.
        return;
      }
      switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, ref input);
            break;
          case 17: {
            TimeUnixNano = input.ReadFixed64();
            break;
          }
          case 25: {
            AsDouble = input.ReadDouble();
            break;
          }
          case 34: {
            SpanId = input.ReadBytes();
            break;
          }
          case 42: {
            TraceId = input.ReadBytes();
            break;
          }
          case 49: {
            AsInt = input.ReadSFixed64();
            break;
          }
          case 58: {
            filteredAttributes_.AddEntriesFrom(ref input, _repeated_filteredAttributes_codec);
            break;
          }
        }
      }
    }
    #endif

  }

  #endregion

}

#endregion Designer generated code
