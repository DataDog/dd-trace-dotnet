// <copyright file="VulnerabilityStatsTests.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

using System;
using Datadog.Trace.Iast;
using FluentAssertions;
using Xunit;

namespace Datadog.Trace.Security.Unit.Tests.IAST
{
    public class VulnerabilityStatsTests
    {
        [Fact]
        public void GivenSomeVulnerabilityStats_WhenManipulated_DataIsCoherent()
        {
            VulnerabilityTypeUtils.Count.Should().Be(Enum.GetValues(typeof(VulnerabilityType)).Length, "VulnerabilityTypeUtils.Count should hold the number of different vulnerability types defined in VulnerabilityType enum");
            VulnerabilityStats.Length.Should().Be(VulnerabilityTypeUtils.Count);

            var empty = new VulnerabilityStats();
            empty.Route.Should().BeNull();
            for (int index = 0; index < VulnerabilityStats.Length; index++)
            {
                empty[index].Should().Be(0);
            }

            var route = "route";
            var stats = new VulnerabilityStats(route);
            stats.Route.Should().Be(route);

            ushort sqlI = 31000;
            ushort weakHash = 25000;
            ushort ssrf = 25;
            stats[(int)VulnerabilityType.SqlInjection] = sqlI;
            stats[(int)VulnerabilityType.WeakHash] = weakHash;
            stats[(int)VulnerabilityType.Ssrf] = ssrf;

            for (int index = 0; index < VulnerabilityStats.Length; index++)
            {
                if (index == (int)VulnerabilityType.SqlInjection)
                {
                    stats[index].Should().Be(sqlI);
                }
                else if (index == (int)VulnerabilityType.WeakHash)
                {
                    stats[index].Should().Be(weakHash);
                }
                else if (index == (int)VulnerabilityType.Ssrf)
                {
                    stats[index].Should().Be(ssrf);
                }
                else
                {
                    stats[index].Should().Be(0);
                }
            }

            var stats2 = new VulnerabilityStats(route);
            stats2[(int)VulnerabilityType.SqlInjection] = (ushort)(sqlI + 10);
            stats2[(int)VulnerabilityType.WeakHash] = (ushort)(10);
            stats2[(int)VulnerabilityType.Ssrf] = (ushort)(ssrf + 10);
            stats.TransferNewVulns(ref stats2);

            for (int index = 0; index < VulnerabilityStats.Length; index++)
            {
                if (index == (int)VulnerabilityType.SqlInjection)
                {
                    stats[index].Should().Be(stats2[index]);
                }
                else if (index == (int)VulnerabilityType.WeakHash)
                {
                    stats[index].Should().Be(weakHash);
                }
                else if (index == (int)VulnerabilityType.Ssrf)
                {
                    stats[index].Should().Be(stats2[index]);
                }
                else
                {
                    stats[index].Should().Be(0);
                }
            }
        }
    }
}
