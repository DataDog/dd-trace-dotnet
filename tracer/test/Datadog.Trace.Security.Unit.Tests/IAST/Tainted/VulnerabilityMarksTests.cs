// <copyright file="VulnerabilityMarksTests.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

using System.Linq;
using Datadog.Trace.Iast;
using FluentAssertions;
using Xunit;

namespace Datadog.Trace.Security.Unit.Tests.IAST.Tainted;

public class VulnerabilityMarksTests
{
    [Fact]
    public void DefaultMarkIsNone()
    {
        var range = new Range(0, 0);
        Assert.Equal(SecureMarks.None, range.SecureMarks);
    }

    [Fact]
    public void SetMarkOnArrayOfRanges()
    {
        Range[] ranges =
        [
            new Range(0, 0),
            new Range(1, 2),
            new Range(3, 4, null, SecureMarks.None)
        ];

        var newRanges = Ranges.CopyWithMark(ranges, SecureMarks.Xss);
        foreach (var range in newRanges)
        {
            Assert.Equal(SecureMarks.Xss, range.SecureMarks);
        }
    }

    [Theory]
    [InlineData((byte)SecureMarks.None, null, 14)]
    [InlineData((byte)SecureMarks.Ssrf, null, 7)]
    [InlineData((byte)SecureMarks.Xss, null, 8)]
    [InlineData((byte)SecureMarks.Xss | (byte)SecureMarks.Ssrf, null, 5)]
    [InlineData((byte)SecureMarks.None, new byte[] { (byte)SourceType.SqlRowValue }, 11)]
    [InlineData((byte)SecureMarks.None, new byte[] { (byte)SourceType.RequestBody }, 11)]
    [InlineData((byte)SecureMarks.None, new byte[] { (byte)SourceType.SqlRowValue, (byte)SourceType.RequestBody }, 8)]
    [InlineData((byte)SecureMarks.Xss, new byte[] { (byte)SourceType.SqlRowValue }, 6)]
    public void GivenRanges_WhenFiltered_SecureRangesAreRemoved(byte secureMarks, byte[] secureOrigins, int expectedRangeCount)
    {
        var marks = (SecureMarks)secureMarks;
        var origins = secureOrigins?.Select(o => (SourceType)o).ToArray();

        Source request = new Source(SourceType.RequestQuery, "request", null);
        Source sqlRow = new Source(SourceType.SqlRowValue, "sql", null);
        Source body = new Source(SourceType.RequestBody, "body", null);
        Range[] ranges =
        [
            new Range(2, 4),
            new Range(12, 2, request),
            new Range(14, 2, request, SecureMarks.Xss),
            new Range(16, 2, request, SecureMarks.Xss | SecureMarks.Ssrf),
            new Range(18, 2, sqlRow),
            new Range(20, 2, sqlRow, SecureMarks.Ssrf),
            new Range(22, 2, sqlRow, SecureMarks.Xss | SecureMarks.Ssrf),
            new Range(24, 2, body),
            new Range(26, 2, body, SecureMarks.Ssrf),
            new Range(28, 2, body, SecureMarks.Xss | SecureMarks.Ssrf),
            new Range(30, 1),
            new Range(32, 2, null, SecureMarks.Ssrf),
            new Range(34, 2, null, SecureMarks.Xss),
            new Range(36, 2, null, SecureMarks.Xss | SecureMarks.Ssrf)
        ];

        var newRanges = Ranges.GetUnsafeRanges(ranges, marks, origins);
        newRanges.Should().NotBeNull();
        newRanges.Length.Should().Be(expectedRangeCount);

        foreach (var range in newRanges)
        {
            (range.SecureMarks & marks).Should().Be(SecureMarks.None);
            if (range.Source is not null && secureOrigins is not null)
            {
                origins.Contains(range.Source.Origin).Should().BeFalse();
            }
        }
    }
}
