// <copyright file="VulnerabilityBatchTests.Bundle.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Runtime.InteropServices;
using Datadog.Trace.AppSec.Waf;
using Datadog.Trace.Configuration;
using Datadog.Trace.Iast;
using Datadog.Trace.Iast.SensitiveData;
using Datadog.Trace.TestHelpers;
using Datadog.Trace.TestHelpers.FluentAssertionsExtensions.Json;
using Datadog.Trace.Vendors.Newtonsoft.Json;
using Datadog.Trace.Vendors.Newtonsoft.Json.Linq;
using FluentAssertions;
using Xunit;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Datadog.Trace.Security.Unit.Tests.IAST.Tainted;

/// <summary>
/// VulnerabilityBatchTests for COMMAND_INJECTION
/// </summary>
public partial class VulnerabilityBatchTests
{
#pragma warning disable SA1401 // Fields should be private
    public static List<object[]> TestData = GetTestData();
#pragma warning restore SA1401 // Fields should be private

    private const double _regexTimeout = 0;
    private static JsonSerializerSettings _serializerSettings = VulnerabilityBatch.CreateSerializerSettings(Trace.Iast.Settings.IastSettings.TruncationMaxValueLengthDefault, true);
    private static EvidenceRedactor _redactor = Utils.GetDefaultRedactor(_regexTimeout);

    [Theory]
    [MemberData(nameof(TestData))]
    public void YmlBundledTest(string type, string description, string context, string input, string expected)
    {
        if (type == "SOURCES")
        {
            ExecuteSourcesTest(description, context, input, expected);
        }
        else if (type == "VULNERABILITIES")
        {
            ExecuteVulnerabilitiesTest(description, context, input, expected);
        }
        else
        {
            throw new System.Exception($"Unknown yml bundled test type {type}");
        }
    }

    private static List<object[]> GetTestData()
    {
        // This file should regularly be updated from here https://github.com/DataDog/experimental/blob/main/teams/asm/iast/redaction/suite/evidence-redaction-suite.yml

        List<object[]> testData = new List<object[]>();
        string yamlContent = ResourceHelper.ReadAllText<VulnerabilityBatchTests>("evidence-redaction-suite.yml");

        var deserializer = new DeserializerBuilder().WithNamingConvention(CamelCaseNamingConvention.Instance).Build();
        var suite = deserializer.Deserialize<TestSuite>(yamlContent);
        if (string.IsNullOrEmpty(yamlContent) || suite == null || suite.Suite.Count == 0)
        {
            throw new System.Exception("Unable to deserialize evidence-redaction-suite.yml file properly (empty content)");
        }

        foreach (var test in suite.Suite)
        {
            var parametersList = CombineParameters(test.Parameters);
            foreach (var parameters in parametersList)
            {
                var description = ReplaceParameters(test.Description, parameters);
                var context = ReplaceParameters(test.Context, parameters);
                var input = ReplaceParameters(test.Input, parameters);
                var expected = ReplaceParameters(test.Expected, parameters);

                testData.Add(new object[] { test.Type, description, context, input, expected });
            }
        }

        return testData;
    }

    private static List<Dictionary<string, string>> CombineParameters(Dictionary<string, List<string>> parameters)
    {
        var res = new List<Dictionary<string, string>>();

        if (parameters == null || parameters.Count == 0)
        {
            res.Add(new Dictionary<string, string>());
        }
        else
        {
            Dictionary<string, string> tuple = new Dictionary<string, string>();
            res = ExpandTuples(parameters.ToList(), parameters.Count - 1);
        }

        return res;
    }

    private static List<Dictionary<string, string>> ExpandTuples(List<KeyValuePair<string, List<string>>> parameters, int index)
    {
        List<Dictionary<string, string>> res = new List<Dictionary<string, string>>();
        if (index < 0)
        {
            return res;
        }
        else
        {
            var restTuples = ExpandTuples(parameters, index - 1);
            var currentParam = parameters[index];
            foreach (var value in currentParam.Value)
            {
                if (restTuples.Count == 0)
                {
                    Dictionary<string, string> tuples = new Dictionary<string, string>();
                    tuples[currentParam.Key] = value;
                    res.Add(tuples);
                }
                else
                {
                    foreach (var restTuple in restTuples)
                    {
                        Dictionary<string, string> tuples = new Dictionary<string, string>(restTuple);
                        tuples[currentParam.Key] = value;
                        res.Add(tuples);
                    }
                }
            }
        }

        return res;
    }

    private static Dictionary<string, string> ExpandParameter(KeyValuePair<string, List<string>> parameter)
    {
        Dictionary<string, string> res = new Dictionary<string, string>();
        foreach (var value in parameter.Value)
        {
            res[parameter.Key] = value;
        }

        return res;
    }

    private static string ReplaceParameters(string text, Dictionary<string, string> parameters)
    {
        if (text != null && parameters != null)
        {
            foreach (var parameter in parameters)
            {
                text = text.Replace(parameter.Key, parameter.Value);
            }
        }

        return text;
    }

    private void ExecuteSourcesTest(string description, string context, string input, string expected)
    {
        var sources = JsonConvert.DeserializeObject<List<Source>>(input, _serializerSettings);
        foreach (var source in sources)
        {
            _redactor.Process(source);
        }

        var json = JsonConvert.SerializeObject(sources, Formatting.Indented, _serializerSettings);
        json.Should().BeJsonEquivalentTo(expected, _sourcesScrubber);
    }

    private void ExecuteVulnerabilitiesTest(string description, string context, string input, string expected)
    {
        IntegrationId? integrationId = GetIntegrationId(context);
        dynamic rawInput = JsonConvert.DeserializeObject(input);
        var batch = Utils.GetRedactedBatch(_regexTimeout);
        foreach (var raw in rawInput)
        {
            var type = raw.type.ToString();
            var location = GetLocation(raw.location);
            var evidence = GetEvidence(raw.evidence);
            var vulnerability = new Vulnerability(type, location, evidence, integrationId);
            batch.Add(vulnerability);
        }

        var json = batch.ToJson();
        var metaStructJson = VulnerabilityBatchMetaStructToJson(batch);

        json.Should().BeJsonEquivalentTo(expected, _vulnerabilitiesScrubber);
        metaStructJson.Should().BeJsonEquivalentTo(expected, _vulnerabilitiesScrubber);
    }

    private Location GetLocation(dynamic raw)
    {
        if (raw == null) { return new Location(); }

        var stackFile = raw.stackFile?.ToString();
        var methodName = raw.methodName?.ToString();
        var line = raw.line?.Value;
        var spanId = raw.line?.Value;
        var methodTypeName = raw.methodTypeName?.ToString();

        return new Location(methodTypeName, methodName, line, spanId);
    }

    private Source GetSource(dynamic raw)
    {
        if (raw == null) { return null; }

        var origin = SourceTypeUtils.FromString(raw.origin?.ToString());
        var name = raw.name?.ToString();
        var value = raw.value?.ToString();

        return new Source(origin, name, value);
    }

    private Evidence GetEvidence(dynamic raw)
    {
        if (raw == null) { return new Evidence(); }
        var value = raw.value?.ToString();
        var ranges = new List<Range>();
        if (raw.ranges != null)
        {
            foreach (var rawRange in raw.ranges)
            {
                var start = rawRange.start?.Value;
                var length = rawRange.length?.Value;
                var source = GetSource(rawRange.source);
                var range = new Range((int)start, (int)length, source);
                ranges.Add(range);
            }
        }

        var rangeArray = ranges.Count > 0 ? ranges.ToArray() : null;
        return new Evidence(value, rangeArray);
    }

    private IntegrationId? GetIntegrationId(string context)
    {
        if (context == null) { return null; }
        dynamic raw = JsonConvert.DeserializeObject(context);
        var db = raw.DATABASE;
        if (db == null) { return null; }
        return db.ToString() switch
        {
            "ORACLE" => IntegrationId.Oracle,
            "POSTGRESQL" => IntegrationId.Npgsql,
            "MYSQL" => IntegrationId.MySql,
            "MARIADB" => IntegrationId.MySql,
            "SQLITE" => IntegrationId.Sqlite,
            _ => null
        };
    }

    public class TestSuite
    {
        public string Version { get; set; }

        public List<Test> Suite { get; set; }
    }

    public class Test
    {
        public string Type { get; set; }

        public string Description { get; set; }

        public string Context { get; set; }

        public Dictionary<string, List<string>> Parameters { get; set; }

        public string Input { get; set; }

        public string Expected { get; set; }
    }
}
