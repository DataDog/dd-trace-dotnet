// <copyright file="VulnerabilityBatchTests.Bundle.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Runtime.InteropServices;
using Datadog.Trace.Iast;
using Datadog.Trace.Iast.SensitiveData;
using Datadog.Trace.TestHelpers;
using Datadog.Trace.TestHelpers.FluentAssertionsExtensions.Json;
using Datadog.Trace.Vendors.Newtonsoft.Json;
using FluentAssertions;
using Xunit;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Datadog.Trace.Security.Unit.Tests.IAST.Tainted;

/// <summary>
/// VulnerabilityBatchTests for COMMAND_INJECTION
/// </summary>
public partial class VulnerabilityBatchTests
{
    private static JsonSerializerSettings _serializerSettings = VulnerabilityBatch.JsonRedactionSettings;
    private static EvidenceRedactor _redactor = Utils.GetDefaultRedactor();

    [Fact]
    public void YamlTestBundle()
    {
        List<string> successfull = new List<string>();
        List<string> failed = new List<string>();
        string yamlContent = ResourceHelper.ReadAllText<VulnerabilityBatchTests>("evidence-redaction-suite.yml");

        var deserializer = new DeserializerBuilder().WithNamingConvention(CamelCaseNamingConvention.Instance).Build();
        var suite = deserializer.Deserialize<TestSuite>(yamlContent);

        foreach (var test in suite.Suite)
        {
            var parametersList = CombineParameters(test.Parameters);
            foreach (var parameters in parametersList)
            {
                var description = ReplaceParameters(test.Description, parameters);
                var context = ReplaceParameters(test.Context, parameters);
                var input = ReplaceParameters(test.Input, parameters);
                var expected = ReplaceParameters(test.Expected, parameters);

                try
                {
                    if (test.Type == "SOURCES")
                    {
                        ExecuteSourcesTest(description, context, input, expected, parameters);
                    }
                    else if (test.Type == "VULNERABILITIES")
                    {
                        ExecuteVulnerabilitiesTest(description, context, input, expected, parameters);
                    }

                    var txt = $"PASSED: {description}";
                    successfull.Add(txt);
                }
                catch (Exception err)
                {
                    var txt = $"FAILED: {description} : {err}";
                    failed.Add(txt);
                }
            }
        }

        // Produce the output
        var separator = Environment.NewLine + "  ";
        if (failed.Count > 0)
        {
            throw new Exception($"{failed.Count} out of {failed.Count + successfull.Count} sub test FAILED. {separator} {string.Join(separator, failed)}");
        }
        else
        {
            Console.WriteLine($"{successfull.Count} sub test PASSED. {separator} {string.Join(separator, successfull)}");
        }
    }

    private List<Dictionary<string, string>> CombineParameters(Dictionary<string, List<string>> parameters)
    {
        var res = new List<Dictionary<string, string>>();

        if (parameters == null || parameters.Count == 0)
        {
            res.Add(new Dictionary<string, string>());
        }
        else
        {
            Dictionary<string, string> tuple = new Dictionary<string, string>();
            res = ExpandTuples(parameters.ToList(), parameters.Count - 1);
        }

        return res;
    }

    private List<Dictionary<string, string>> ExpandTuples(List<KeyValuePair<string, List<string>>> parameters, int index)
    {
        List<Dictionary<string, string>> res = new List<Dictionary<string, string>>();
        if (index < 0)
        {
            return res;
        }
        else
        {
            var restTuples = ExpandTuples(parameters, index - 1);
            var currentParam = parameters[index];
            foreach (var value in currentParam.Value)
            {
                if (restTuples.Count == 0)
                {
                    Dictionary<string, string> tuples = new Dictionary<string, string>();
                    tuples[currentParam.Key] = value;
                    res.Add(tuples);
                }
                else
                {
                    foreach (var restTuple in restTuples)
                    {
                        Dictionary<string, string> tuples = new Dictionary<string, string>(restTuple);
                        tuples[currentParam.Key] = value;
                        res.Add(tuples);
                    }
                }
            }
        }

        return res;
    }

    private Dictionary<string, string> ExpandParameter(KeyValuePair<string, List<string>> parameter)
    {
        Dictionary<string, string> res = new Dictionary<string, string>();
        foreach (var value in parameter.Value)
        {
            res[parameter.Key] = value;
        }

        return res;
    }

    private string ReplaceParameters(string text, Dictionary<string, string> parameters)
    {
        if (text != null && parameters != null)
        {
            foreach (var parameter in parameters)
            {
                text = text.Replace(parameter.Key, parameter.Value);
            }
        }

        return text;
    }

    private void ExecuteSourcesTest(string description, string context, string input, string expected, Dictionary<string, string> parameters)
    {
        var sources = JsonConvert.DeserializeObject<List<Source>>(input, _serializerSettings);
        foreach (var source in sources)
        {
            _redactor.Process(source);
        }

        var json = JsonConvert.SerializeObject(sources, Formatting.Indented, _serializerSettings);
        json.Should().BeJsonEquivalentTo(expected, _defaultScrubber);
    }

    private void ExecuteVulnerabilitiesTest(string description, string context, string input, string expected, Dictionary<string, string> parameters)
    {
        var vulnerabilities = JsonConvert.DeserializeObject<List<Vulnerability>>(input, _serializerSettings);
        var batch = Utils.GetRedactedBatch();
        foreach (var vulnerability in vulnerabilities)
        {
            batch.Add(vulnerability);
        }

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(expected, _defaultScrubber);
    }

    public class TestSuite
    {
        public string Version { get; set; }

        public List<Test> Suite { get; set; }
    }

    public class Test
    {
        public string Type { get; set; }

        public string Description { get; set; }

        public string Context { get; set; }

        public Dictionary<string, List<string>> Parameters { get; set; }

        public string Input { get; set; }

        public string Expected { get; set; }
    }
}
