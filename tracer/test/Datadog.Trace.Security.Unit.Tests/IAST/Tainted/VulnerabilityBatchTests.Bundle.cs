// <copyright file="VulnerabilityBatchTests.Bundle.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

using System.Collections.Generic;
using System.ComponentModel;
using System.Linq;
using System.Runtime.InteropServices;
using Datadog.Trace.Configuration;
using Datadog.Trace.Iast;
using Datadog.Trace.Iast.SensitiveData;
using Datadog.Trace.TestHelpers;
using Datadog.Trace.TestHelpers.FluentAssertionsExtensions.Json;
using Datadog.Trace.Vendors.Newtonsoft.Json;
using Datadog.Trace.Vendors.Newtonsoft.Json.Linq;
using FluentAssertions;
using Xunit;
using YamlDotNet.Serialization;
using YamlDotNet.Serialization.NamingConventions;

namespace Datadog.Trace.Security.Unit.Tests.IAST.Tainted;

/// <summary>
/// VulnerabilityBatchTests for COMMAND_INJECTION
/// </summary>
public partial class VulnerabilityBatchTests
{
    private static JsonSerializerSettings _serializerSettings = VulnerabilityBatch.JsonRedactionSettings;
    private static EvidenceRedactor _redactor = Utils.GetDefaultRedactor();

    [Fact]
    public void YamlTestBundle()
    {
        List<string> successfull = new List<string>();
        List<string> failed = new List<string>();
        string yamlContent = ResourceHelper.ReadAllText<VulnerabilityBatchTests>("evidence-redaction-suite.yml");

        var deserializer = new DeserializerBuilder().WithNamingConvention(CamelCaseNamingConvention.Instance).Build();
        var suite = deserializer.Deserialize<TestSuite>(yamlContent);

        foreach (var test in suite.Suite)
        {
            var parametersList = CombineParameters(test.Parameters);
            foreach (var parameters in parametersList)
            {
                var description = ReplaceParameters(test.Description, parameters);
                var context = ReplaceParameters(test.Context, parameters);
                var input = ReplaceParameters(test.Input, parameters);
                var expected = ReplaceParameters(test.Expected, parameters);

                try
                {
                    if (test.Type == "SOURCES")
                    {
                        ExecuteSourcesTest(description, context, input, expected, parameters);
                    }
                    else if (test.Type == "VULNERABILITIES")
                    {
                        ExecuteVulnerabilitiesTest(description, context, input, expected, parameters);
                    }

                    var txt = $"PASSED: {description}";
                    successfull.Add(txt);
                }
                catch (System.Exception err)
                {
                    var txt = $"FAILED: {description} : {err}";
                    failed.Add(txt);
                }
            }
        }

        // Produce the output
        var separator = System.Environment.NewLine + "  ";
        if (failed.Count > 0)
        {
            throw new System.Exception($"{failed.Count} out of {failed.Count + successfull.Count} sub test FAILED. {separator} {string.Join(separator, failed)}");
        }
        else
        {
            System.Console.WriteLine($"{successfull.Count} sub test PASSED. {separator} {string.Join(separator, successfull)}");
        }
    }

    private void ExecuteSourcesTest(string description, string context, string input, string expected, Dictionary<string, string> parameters)
    {
        var sources = JsonConvert.DeserializeObject<List<Source>>(input, _serializerSettings);
        foreach (var source in sources)
        {
            _redactor.Process(source);
        }

        var json = JsonConvert.SerializeObject(sources, Formatting.Indented, _serializerSettings);
        json.Should().BeJsonEquivalentTo(expected, _defaultScrubber);
    }

    private void ExecuteVulnerabilitiesTest(string description, string context, string input, string expected, Dictionary<string, string> parameters)
    {
        IntegrationId? integrationId = GetIntegrationId(context);
        dynamic rawInput = JsonConvert.DeserializeObject(input);
        var batch = Utils.GetRedactedBatch();
        foreach (var raw in rawInput)
        {
            var type = raw.type.ToString();
            var location = GetLocation(raw.location);
            var evidence = GetEvidence(raw.evidence);
            var vulnerability = new Vulnerability(type, location, evidence, integrationId);
            batch.Add(vulnerability);
        }

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(expected, _defaultScrubber);
    }

    private List<Dictionary<string, string>> CombineParameters(Dictionary<string, List<string>> parameters)
    {
        var res = new List<Dictionary<string, string>>();

        if (parameters == null || parameters.Count == 0)
        {
            res.Add(new Dictionary<string, string>());
        }
        else
        {
            Dictionary<string, string> tuple = new Dictionary<string, string>();
            res = ExpandTuples(parameters.ToList(), parameters.Count - 1);
        }

        return res;
    }

    private List<Dictionary<string, string>> ExpandTuples(List<KeyValuePair<string, List<string>>> parameters, int index)
    {
        List<Dictionary<string, string>> res = new List<Dictionary<string, string>>();
        if (index < 0)
        {
            return res;
        }
        else
        {
            var restTuples = ExpandTuples(parameters, index - 1);
            var currentParam = parameters[index];
            foreach (var value in currentParam.Value)
            {
                if (restTuples.Count == 0)
                {
                    Dictionary<string, string> tuples = new Dictionary<string, string>();
                    tuples[currentParam.Key] = value;
                    res.Add(tuples);
                }
                else
                {
                    foreach (var restTuple in restTuples)
                    {
                        Dictionary<string, string> tuples = new Dictionary<string, string>(restTuple);
                        tuples[currentParam.Key] = value;
                        res.Add(tuples);
                    }
                }
            }
        }

        return res;
    }

    private Dictionary<string, string> ExpandParameter(KeyValuePair<string, List<string>> parameter)
    {
        Dictionary<string, string> res = new Dictionary<string, string>();
        foreach (var value in parameter.Value)
        {
            res[parameter.Key] = value;
        }

        return res;
    }

    private string ReplaceParameters(string text, Dictionary<string, string> parameters)
    {
        if (text != null && parameters != null)
        {
            foreach (var parameter in parameters)
            {
                text = text.Replace(parameter.Key, parameter.Value);
            }
        }

        return text;
    }

    private Location GetLocation(dynamic raw)
    {
        if (raw == null) { return new Location(); }

        var stackFile = raw.stackFile?.ToString();
        var methodName = raw.methodName?.ToString();
        var line = raw.line?.Value;
        var spanId = raw.line?.Value;
        var methodTypeName = raw.methodTypeName?.ToString();

        return new Location(stackFile, methodName, line, spanId, methodTypeName);
    }

    private Source GetSource(dynamic raw)
    {
        if (raw == null) { return null; }

        var origin = SourceType.FromString(raw.origin?.ToString());
        var name = raw.name?.ToString();
        var value = raw.value?.ToString();

        return new Source((byte)origin, name, value);
    }

    private Evidence GetEvidence(dynamic raw)
    {
        if (raw == null) { return new Evidence(); }
        var value = raw.value?.ToString();
        var ranges = new List<Range>();
        if (raw.ranges != null)
        {
            foreach (var rawRange in raw.ranges)
            {
                var start = rawRange.start?.Value;
                var length = rawRange.length?.Value;
                var source = GetSource(rawRange.source);
                var range = new Range((int)start, (int)length, source);
                ranges.Add(range);
            }
        }

        var rangeArray = ranges.Count > 0 ? ranges.ToArray() : null;
        return new Evidence(value, rangeArray);
    }

    private IntegrationId? GetIntegrationId(string context)
    {
        if (context == null) { return null; }
        dynamic raw = JsonConvert.DeserializeObject(context);
        var db = raw.DATABASE;
        if (db == null) { return null; }
        return db.ToString() switch
        {
            "ORACLE" => IntegrationId.Oracle,
            "POSTGRESQL" => IntegrationId.Npgsql,
            "MYSQL" => IntegrationId.MySql,
            "MARIADB" => IntegrationId.MySql,
            _ => null
        };
    }

    public class TestSuite
    {
        public string Version { get; set; }

        public List<Test> Suite { get; set; }
    }

    public class Test
    {
        public string Type { get; set; }

        public string Description { get; set; }

        public string Context { get; set; }

        public Dictionary<string, List<string>> Parameters { get; set; }

        public string Input { get; set; }

        public string Expected { get; set; }
    }
}
