// <copyright file="VulnerabilityBatchTests.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

using System.Text.RegularExpressions;
using Datadog.Trace.Iast;
using Datadog.Trace.TestHelpers.FluentAssertionsExtensions;
using Datadog.Trace.Vendors.Newtonsoft.Json;
using Datadog.Trace.Vendors.Newtonsoft.Json.Linq;
using FluentAssertions;
using Xunit;

namespace Datadog.Trace.Security.Unit.Tests.IAST.Tainted;

public class VulnerabilityBatchTests
{
    [Fact]
    public void GivenAnVulnerabilityBatch_WhenAddVulnerability_VulnerabilityIsCorrectlyAdded()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(2, "name", "value");
        var source2 = new Source(3, "name2", "value2");
        var ranges = new Range[] { new Range(0, 2, source), new Range(2, 2, source2) };
        var evidence = new Evidence("sql_query", ranges);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        batch.Add(vulnerability);

        batch.Sources.Count.Should().Be(2);
        batch.Sources[0].GetInternalId().Should().Be(0);
        batch.Sources[1].GetInternalId().Should().Be(1);

        batch.Vulnerabilities.Should().BeEquivalentTo(new[]
        {
            new
            {
                Evidence = new
                {
                    ValueParts = new[]
                    {
                        new { Source = 0, Value = "sq" },
                        new { Source = 1, Value = "l_" },
                    }
                }
            }
        });
    }

    [Fact]
    public void GivenAnVulnerabilityBatch_WhenAddVulnerability_VulnerabilityIsCorrectlyAdded2()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(2, "name", "value");
        var ranges = new Range[] { new Range(0, 2, source), new Range(2, 2, source) };
        var evidence = new Evidence("sql_query", ranges);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        batch.Add(vulnerability);

        batch.Sources.Count.Should().Be(1);
        batch.Sources[0].GetInternalId().Should().Be(0);

        batch.Vulnerabilities.Should().BeEquivalentTo(new[]
        {
            new
            {
                Evidence = new
                {
                    ValueParts = new[]
                    {
                        new { Source = 0, Value = "sq" },
                        new { Source = 0, Value = "l_" },
                    }
                }
            }
        });
    }

    [Fact]
    public void GivenAnVulnerabilityBatch_WhenAddVulnerability_VulnerabilityIsCorrectlyAdded3()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(2, "name", "value");
        var source2 = new Source(2, "name", "value");
        var ranges = new Range[] { new Range(0, 2, source), new Range(2, 2, source2) };
        var evidence = new Evidence("sql_query", ranges);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        batch.Add(vulnerability);

        batch.Sources.Count.Should().Be(1);
        batch.Sources[0].GetInternalId().Should().Be(0);

        batch.Vulnerabilities.Should().BeEquivalentTo(new[]
        {
            new
            {
                Evidence = new
                {
                    ValueParts = new[]
                    {
                        new { Source = 0, Value = "sq" },
                        new { Source = 0, Value = "l_" },
                    }
                }
            }
        });
    }

    [Fact]
    public void GivenAnVulnerabilityBatch_WhenAddTwoVulnerabilities_VulnerabilitiesAreCorrectlyAdded()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(2, "name", "value");
        var source2 = new Source(3, "name2", "value2");
        var ranges = new Range[] { new Range(0, 2, source), new Range(2, 2, source2) };
        var ranges2 = new Range[] { new Range(2, 2, source2) };
        var evidence = new Evidence("sql_query", ranges);
        var evidence2 = new Evidence("filename", ranges2);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        var vulnerability2 = new Vulnerability("pathtraversal", new Location(), evidence2);
        batch.Add(vulnerability);
        batch.Add(vulnerability2);

        batch.Vulnerabilities.Count.Should().Be(2);
        batch.Sources.Count.Should().Be(2);
        batch.Sources[0].GetInternalId().Should().Be(0);
        batch.Sources[1].GetInternalId().Should().Be(1);

        batch.Vulnerabilities.Should().BeEquivalentTo(new[]
        {
            new
            {
                Evidence = new
                {
                    ValueParts = new[]
                    {
                        new { Source = 0, Value = "sq" },
                        new { Source = 1, Value = "l_" },
                    }
                }
            },
            new
            {
                Evidence = new
                {
                    ValueParts = new[]
                    {
                        new { Source = 1, Value = "le" },
                    }
                }
            }
        });
    }

    [Fact]
    public void GivenAnVulnerabilityBatch_WhenAddTwoVulnerabilities_JSONIsCorrect()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(2, "name", "value");
        var source2 = new Source(3, "name2", "value2");
        var ranges = new Range[] { new Range(0, 2, source), new Range(2, 2, source2) };
        var ranges2 = new Range[] { new Range(2, 2, source2) };
        var evidence = new Evidence("sql_query", ranges);
        var evidence2 = new Evidence("filename", ranges2);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        var vulnerability2 = new Vulnerability("pathtraversal", new Location(), evidence2);
        batch.Add(vulnerability);
        batch.Add(vulnerability2);

        var json = batch.ToString();

        var expectedJson = @"{
	        ""vulnerabilities"": [
		        {
			        ""type"": ""sqli"",
			        ""hash"": -507016161,
			        ""location"": {},
			        ""evidence"": {
				        ""value"": ""sql_query"",
				        ""valueParts"": [
					        {
						        ""value"": ""sq"",
						        ""source"": 0
					        },
					        {
						        ""value"": ""l_"",
						        ""source"": 1
					        }
				        ]
			        }
		        },
		        {
			        ""type"": ""pathtraversal"",
			        ""hash"": -1083869249,
			        ""location"": {},
			        ""evidence"": {
				        ""value"": ""filename"",
				        ""valueParts"": [
					        {
						        ""value"": ""le"",
						        ""source"": 1
					        }
				        ]
			        }
		        }
	        ],
	        ""sources"": [
		        {
			        ""origin"": ""http.request.parameter.name"",
			        ""name"": ""name"",
			        ""value"": ""value""
		        },
		        {
			        ""origin"": ""http.request.parameter.value"",
			        ""name"": ""name2"",
			        ""value"": ""value2""
		        }
	        ]
        }";

        FormatTestJson(json).Should().Be(FormatTestJson(expectedJson));
    }

    private string FormatTestJson(string json)
    {
        Regex hashRegex = new(@"(\S)*""hash"":(-){0,1}([0-9]){1,12},");
        json = json.Replace("\n", string.Empty).Replace("\r", string.Empty).Replace(" ", string.Empty).Replace("\t", string.Empty);
        return hashRegex.Replace(json, string.Empty);
    }
}
