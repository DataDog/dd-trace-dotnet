// <copyright file="VulnerabilityBatchTests.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

using System.Text;
using Datadog.Trace.AppSec.Rasp;
using Datadog.Trace.Iast;
using Datadog.Trace.TestHelpers.FluentAssertionsExtensions.Json;
using Datadog.Trace.Vendors.Newtonsoft.Json;
using FluentAssertions;
using Xunit;
using Xunit.Abstractions;
using YamlDotNet.Core.Tokens;

namespace Datadog.Trace.Security.Unit.Tests.IAST.Tainted;

/// <summary>
/// Basic VulnerabilityBatchTests
/// </summary>
public partial class VulnerabilityBatchTests
{
    private static System.Func<string, string, bool> _sourcesScrubber = Utils.GetRegexScrubber("$[*].pattern", "$[*].truncated");
    private static System.Func<string, string, bool> _vulnerabilitiesScrubber = Utils.GetRegexScrubber("$.vulnerabilities[*].hash", "$.vulnerabilities[*].location");
    private readonly ITestOutputHelper _output = null;

    public VulnerabilityBatchTests(ITestOutputHelper output)
    {
        _output = output;
    }

    [Fact]
    public void GivenAVulnerabilityBatch_WhenAddVulnerability_VulnerabilityIsCorrectlyAdded()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(SourceType.RequestParameterName, "name", "sqlvalue1");
        var source2 = new Source(SourceType.RequestParameterValue, "name2", "sql_value2");
        var ranges = new Range[] { new Range(0, 2, source), new Range(2, 2, source2) };
        var evidence = new Evidence("sql_query", ranges);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        var metaStructJson = VulnerabilityBatchMetaStructToJson(batch);

        const string testJson =
            """
            {
              "vulnerabilities": [
                {
                  "type": "sqli",
                  "location": {},
                  "evidence": {
                    "valueParts": [
                      { "source": 0,"value": "sq" },
                      { "source": 1, "value": "l_" },
                      { "value": "query" }
                    ]
                  }
                }
              ],
              "sources": [
                { "origin": "http.request.parameter.name", "name": "name", "value": "sqlvalue1" },
                { "origin": "http.request.parameter", "name": "name2", "value": "sql_value2" },
              ]
            }
            """;

        json.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
        metaStructJson.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
    }

    [Fact]
    public void GivenAVulnerabilityBatch_WhenAddVulnerability_VulnerabilityIsCorrectlyAdded2()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(SourceType.RequestParameterName, "name", "value");
        var ranges = new Range[] { new Range(1, 1, source), new Range(2, 2, source) };
        var evidence = new Evidence("sql_query", ranges);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        var metaStructJson = VulnerabilityBatchMetaStructToJson(batch);

        const string testJson =
            """
            {
              "vulnerabilities": [
                {
                  "type": "sqli",
                  "location": {},
                  "evidence": {
                    "valueParts": [
                      { "value": "s" },
                      { "source": 0,"value": "q" },
                      { "source": 0, "value": "l_" },
                      { "value": "query" }
                    ]
                  }
                }
              ],
              "sources": [
                { "origin": "http.request.parameter.name", "name": "name", "value": "value" },
              ]
            }
            """;

        json.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
        metaStructJson.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
    }

    [Fact]
    public void GivenAVulnerabilityBatch_WhenAddVulnerability_VulnerabilityIsCorrectlyAdded3()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(SourceType.RequestParameterName, "name", "value");
        var source2 = new Source(SourceType.RequestParameterName, "name", "value");
        var ranges = new Range[] { new Range(0, 2, source), new Range(2, 2, source2) };
        var evidence = new Evidence("sql_query", ranges);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        var metaStructJson = VulnerabilityBatchMetaStructToJson(batch);

        const string testJson =
            """
            {
              "vulnerabilities": [
                {
                  "type": "sqli",
                  "location": {},
                  "evidence": {
                    "valueParts": [
                      { "source": 0,"value": "sq" },
                      { "source": 0, "value": "l_" },
                      { "value": "query" }
                    ]
                  }
                }
              ],
              "sources": [
                { "origin": "http.request.parameter.name", "name": "name", "value": "value" },
              ]
            }
            """;

        json.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
        metaStructJson.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
    }

    [Fact]
    public void GivenAVulnerabilityBatch_WhenAddTwoVulnerabilities_VulnerabilitiesAreCorrectlyAdded()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(SourceType.RequestParameterName, "name", "value");
        var source2 = new Source(SourceType.RequestParameterValue, "name2", "value2");
        var ranges = new Range[] { new Range(0, 2, source), new Range(2, 2, source2) };
        var ranges2 = new Range[] { new Range(2, 2, source2) };
        var evidence = new Evidence("sql_query", ranges);
        var evidence2 = new Evidence("filename", ranges2);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        var vulnerability2 = new Vulnerability("pathtraversal", new Location(), evidence2);
        batch.Add(vulnerability);
        batch.Add(vulnerability2);

        batch.Vulnerabilities.Count.Should().Be(2);
        batch.Sources.Count.Should().Be(2);
        batch.Sources[0].GetInternalId().Should().Be(0);
        batch.Sources[1].GetInternalId().Should().Be(1);

        var json = batch.ToJson();
        var metaStructJson = VulnerabilityBatchMetaStructToJson(batch);

        const string testJson =
            """
            {
              "vulnerabilities": [
                {
                  "type": "sqli",
                  "location": {},
                  "evidence": {
                  "valueParts": [
                    { "source": 0,"value": "sq" },
                    { "source": 1, "value": "l_" },
                    { "value": "query" }
                  ]
                }
              },
                {
                  "type": "pathtraversal",
                  "location": {},
                  "evidence": {
                  "valueParts": [
                    { "value": "fi" },
                    { "source": 1,"value": "le" },
                    { "value": "name" }
                  ]
                }
              }
              ],
              "sources": [
                  { "origin": "http.request.parameter.name", "name": "name", "value": "value" },
                  { "origin": "http.request.parameter", "name": "name2", "value": "value2" },
              ]
            }
            """;

        json.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
        metaStructJson.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
    }

    [Fact]
    public void GivenAnEvidence_WhenGetValueParts_ValuePartsIsCorrect2()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(SourceType.RequestParameterName, "name", "value");
        var ranges = new Range[] { new Range(2, 2, source), new Range(6, 2, source) };
        var evidence = new Evidence("sql_query", ranges);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        var metaStructJson = VulnerabilityBatchMetaStructToJson(batch);

        const string testJson =
            """
            {
              "vulnerabilities": [
                {
                  "type": "sqli",
                  "location": {},
                  "evidence": {
                    "valueParts": [
                      { "value": "sq" },
                      { "source": 0, "value": "l_" },
                      { "value": "qu" },
                      { "source": 0, "value": "er" },
                      { "value": "y" }
                    ]
                  }
                }
              ],
              "sources": [
                { "origin": "http.request.parameter.name", "name": "name", "value": "value" },
              ]
            }
            """;

        json.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
        metaStructJson.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
    }

    [Fact]
    public void GivenAnEvidence_WhenGetValueParts_ValuePartsIsCorrect3()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(SourceType.RequestParameterName, "name", "value");
        var evidence = new Evidence("sql_query", null);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        var metaStructJson = VulnerabilityBatchMetaStructToJson(batch);

        const string testJson =
            """
            {
              "vulnerabilities": [
                {
                  "type": "sqli",
                  "location": {},
                  "evidence": { "value": "sql_query" }
                }
              ]
            }
            """;

        json.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
        metaStructJson.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
    }

    [Fact]
    public void GivenAnEvidence_WhenGetValueParts_ValuePartsIsCorrect4()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(SourceType.RequestParameterName, "name", "value");
        Range emptyRange = new(0, 0, source);
        var ranges = new Range[] { emptyRange };
        var evidence = new Evidence("sql_query", ranges);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        var metaStructJson = VulnerabilityBatchMetaStructToJson(batch);

        const string testJson =
            """
            {
              "vulnerabilities": [
                {
                  "type": "sqli",
                  "location": {},
                  "evidence": {
                    "valueParts": [
                      { "value": "", "source": 0 },
                      { "value": "sql_query" }
                    ]
                  }
                }
              ],
              "sources": [
                {
                  "origin": "http.request.parameter.name",
                  "name": "name",
                  "value": "value"
                }
              ]
            }
            """;

        json.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
        metaStructJson.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
    }

    [Fact]
    public void GivenAnEvidence_WhenGetValueParts_ValuePartsIsCorrect5()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(SourceType.RequestParameterName, "name", "value");
        var ranges = new Range[] { new Range(0, 2, source), new Range(2, 2, source) };
        var evidence = new Evidence("sql_query", ranges);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        var metaStructJson = VulnerabilityBatchMetaStructToJson(batch);

        const string testJson =
            """
            {
              "vulnerabilities": [
                {
                  "type": "sqli",
                  "location": {},
                  "evidence": {
                    "valueParts": [
                      { "value": "sq", "source": 0 },
                      { "value": "l_", "source": 0 },
                      { "value": "query" }
                    ]
                  }
                }
              ],
              "sources": [
                {
                  "origin": "http.request.parameter.name",
                  "name": "name",
                  "value": "value"
                }
              ]
            }
            """;

        json.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
        metaStructJson.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
    }

    [Fact]
    public void GivenAnEvidence_WhenGetValueParts_ValuePartsIsCorrect7()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(SourceType.RequestParameterName, "name", "value");
        var source2 = new Source(SourceType.RequestParameterValue, "name2", "value2");
        var ranges = new Range[] { new Range(1, 1, source), new Range(2, 2, source2) };
        var evidence = new Evidence("sql_query", ranges);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        var metaStructJson = VulnerabilityBatchMetaStructToJson(batch);

        const string testJson =
            """
            {
              "vulnerabilities": [
                {
                  "type": "sqli",
                  "location": {},
                  "evidence": {
                    "valueParts": [
                      { "value": "s" },
                      { "value": "q", "source": 0 },
                      { "value": "l_", "source": 1 },
                      { "value": "query" }
                    ]
                  }
                }
              ],
              "sources": [
                { "origin": "http.request.parameter.name", "name": "name", "value": "value" },
                { "origin": "http.request.parameter", "name": "name2", "value": "value2" },
              ]
            }
            """;

        json.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
        metaStructJson.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
    }

    [Fact]
    public void GivenAnEvidence_WhenGetValueParts_ValuePartsIsCorrect8()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(SourceType.RequestParameterName, "name", "value");
        var source2 = new Source(SourceType.RequestParameterValue, "name2", "value2");
        var ranges = new Range[] { new Range(0, 5, source), new Range(5, 4, source2) };
        var evidence = new Evidence("sql_query", ranges);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        var metaStructJson = VulnerabilityBatchMetaStructToJson(batch);

        const string testJson =
            """
            {
              "vulnerabilities": [
                {
                  "type": "sqli",
                  "location": {},
                  "evidence": {
                    "valueParts": [
                      { "value": "sql_q", "source": 0 },
                      { "value": "uery", "source": 1 }
                    ]
                  }
                }
              ],
              "sources": [
                { "origin": "http.request.parameter.name", "name": "name", "value": "value" },
                { "origin": "http.request.parameter", "name": "name2", "value": "value2" }
              ]
            }
            """;

        json.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
        metaStructJson.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
    }

    [Fact]
    public void GivenAnEvidenceWithNullChars_WhenSerializing_JsonHasNoNullchars()
    {
        var batch = new VulnerabilityBatch();
        var source = new Source(SourceType.RequestParameterName, "name", "val\0ue");
        var source2 = new Source(SourceType.RequestParameterValue, "name2", "value2");
        var ranges = new Range[] { new Range(0, 5, source) };
        var evidence = new Evidence("val\0ue", ranges);
        var vulnerability = new Vulnerability("sqli", new Location(), evidence);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        var metaStructJson = VulnerabilityBatchMetaStructToJson(batch);

        const string testJson =
            """
            {
              "vulnerabilities": [
                {
                  "type": "sqli",
                  "location": {},
                  "evidence": {
                    "valueParts": [
                      { "value": "value", "source": 0 },
                    ]
                  }
                }
              ],
              "sources": [
                { "origin": "http.request.parameter.name", "name": "name", "value": "value" },
              ]
            }
            """;

        json.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
        metaStructJson.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
    }

    [Fact]
    public void GivenOneLongEvidenceValueVuln_WhenSerializing_JsonIsTruncated()
    {
        var batch = new VulnerabilityBatch();
        var evidence = new Evidence(GenerateLargeString());
        batch.Add(new Vulnerability("WEAK_HASH", 1042880134, new Location("foo", "fooMethod", 1, 123456), evidence));

        var json = batch.ToTruncatedJson();
        var metaStructJson = VulnerabilityBatchTruncatedMetaStructToJson(batch);

        const string testJson =
            """
            {
              "vulnerabilities": [
                {
                  "type": "WEAK_HASH",
                  "evidence": {
                    "value": "MAX SIZE EXCEEDED"
                  },
                  "hash":1042880134,
                  "location": {
                    "spanId": 123456,
                    "line": 1,
                    "method": "fooMethod",
                    "path": "foo"
                  }
                }
              ]
            }
            """;

        json.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
        metaStructJson.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
    }

    [Fact]
    public void GivenTwoLongEvidenceValueVulns_WhenSerializing_JsonIsTruncated()
    {
        var batch = new VulnerabilityBatch();
        var evidence = new Evidence(GenerateLargeString());
        batch.Add(new Vulnerability("WEAK_HASH", 1042880134, new Location("foo", "fooMethod", 1, 123456), evidence));
        batch.Add(new Vulnerability("WEAK_HASH", 1042880134, new Location("foo", "fooMethod", 1, 123456), evidence));

        var json = batch.ToTruncatedJson();
        var metaStructJson = VulnerabilityBatchTruncatedMetaStructToJson(batch);

        const string testJson =
            """
            {
              "vulnerabilities": [
                {
                  "evidence": {
                    "value": "MAX SIZE EXCEEDED"
                  },
                  "hash": 1042880134,
                  "location": {
                    "spanId": 123456,
                    "line": 1,
                    "method": "fooMethod",
                    "path": "foo"
                  },
                  "type": "WEAK_HASH"
                },
                {
                  "evidence": {
                    "value": "MAX SIZE EXCEEDED"
                  },
                  "hash": 1042880134,
                  "location": {
                    "spanId": 123456,
                    "line": 1,
                    "method": "fooMethod",
                    "path": "foo"
                  },
                  "type": "WEAK_HASH"
                }
              ]
            }
            """;

        json.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
        metaStructJson.Should().BeJsonEquivalentTo(testJson, _vulnerabilitiesScrubber);
    }

    [Fact]
    public void GivenLotsOfVulns_WhenSerializing_JsonIsTruncated()
    {
        var batch = new VulnerabilityBatch();
        for (var i = 0; i < 80; i++)
        {
            batch.Add(GenerateBigVulnerability());
        }

        var json = batch.ToJson();
        Assert.True(batch.IsTruncated());

        // Clear the truncated value
        batch.GetType()!.GetField("_isTruncated", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)!.SetValue(batch, false);

        var metaStructJson = VulnerabilityBatchMetaStructToJson(batch);
        Assert.True(batch.IsTruncated());

        json.Should().NotContain("source");
        metaStructJson.Should().NotContain("source");
        CountGenericEvidenceOccurrences(json).Should().Be(batch.Vulnerabilities.Count);
        CountGenericEvidenceOccurrences(metaStructJson).Should().Be(batch.Vulnerabilities.Count);
    }

    private static string GenerateLargeString()
    {
        int targetSize = 26 * 1024;
        StringBuilder sb = new StringBuilder();
        System.Random random = new System.Random();
        while (sb.Length < targetSize)
        {
            sb.Append(random.Next());
        }

        return sb.ToString();
    }

    private static Vulnerability GenerateBigVulnerability()
    {
        var largeString = GenerateLargeString();
        return new Vulnerability(
            "WEAK_HASH",
            new Location("foo", "fooMethod", 1, 1042880134),
            new Evidence(largeString, [new Range(0, largeString.Length, new Source(SourceType.RequestParameterValue, "key2", largeString))]));
    }

    private static int CountGenericEvidenceOccurrences(string input)
    {
        var pattern = new System.Text.RegularExpressions.Regex(@"""evidence""\:\s+\{\s+""value"":\s+""MAX SIZE EXCEEDED""\s+\}", System.Text.RegularExpressions.RegexOptions.Compiled);
        var matches = pattern.Matches(input);
        return matches.Count;
    }

    private static string VulnerabilityBatchMetaStructToJson(VulnerabilityBatch vulnerabilityBatch)
    {
        return JsonConvert.SerializeObject(MetaStructHelper.ByteArrayToObject(vulnerabilityBatch.ToMessagePack()), Formatting.Indented);
    }

    private static string VulnerabilityBatchTruncatedMetaStructToJson(VulnerabilityBatch vulnerabilityBatch)
    {
        return JsonConvert.SerializeObject(MetaStructHelper.ByteArrayToObject(vulnerabilityBatch.ToTruncatedMessagePack(MetaStructHelper.VulnerabilityBatchToDictionary(vulnerabilityBatch))), Formatting.Indented);
    }
}
