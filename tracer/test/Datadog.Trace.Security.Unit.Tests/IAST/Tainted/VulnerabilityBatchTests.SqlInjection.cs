// <copyright file="VulnerabilityBatchTests.SqlInjection.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

using Datadog.Trace.Configuration;
using Datadog.Trace.Iast;
using Datadog.Trace.TestHelpers.FluentAssertionsExtensions.Json;
using FluentAssertions;
using Xunit;

namespace Datadog.Trace.Security.Unit.Tests.IAST.Tainted;

/// <summary>
/// VulnerabilityBatchTests for SQL_INJECTION
/// </summary>
public partial class VulnerabilityBatchTests
{
    [Fact]
    public void GivenASqlQueryWithoutSensitiveSource_WhenSerialized_JsonIsRedacted()
    {
        var batch = Utils.GetRedactedBatch();
        var source = new Source(2, "table", "users");
        var ranges = new Range[] { new Range(14, 5, source) };
        var evidence = new Evidence("select * from users", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter.name", "name": "table", "value": "users" }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                    "valueParts": [
                      { "value": "select * from " },
                      { "source": 0, "value": "users" }
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Fact]
    public void GivenASqlQueryWithSensitiveSource_WhenSerialized_JsonIsRedacted()
    {
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "secret", "users");
        var ranges = new Range[] { new Range(14, 5, source) };
        var evidence = new Evidence("select * from users", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "secret", "redacted": true }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                    "valueParts": [
                      { "value": "select * from " },
                      { "source": 0, "redacted": true }
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("SqlClient", "john")]
    [InlineData("SqlClient", "username with ðŸŒ‰ surrogate")]
    [InlineData("Oracle", "john")]
    [InlineData("Oracle", "username with ðŸŒ‰ surrogate")]
    [InlineData("Npgsql", "john")]
    [InlineData("Npgsql", "username with ðŸŒ‰ surrogate")]
    [InlineData("MySql", "john")]
    [InlineData("MySql", "username with ðŸŒ‰ surrogate")]
    public void GivenASqlQueryWithStringLiteral_WhenSerialized_JsonIsRedacted(string database, string literal)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "table", "users");
        var ranges = new Range[] { new Range(14, 5, source) };
        var evidence = new Evidence($"select * from users where username = '{literal}' and last_name = 'another surrogate ðŸ˜ƒ'", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "table", "value": "users" }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                    "valueParts": [
                      { "value": "select * from " },
                      { "source": 0, "value": "users" },
                      { "value": " where username = '" },
                      { "redacted": true },
                      { "value": "' and last_name = '" },
                      { "redacted": true },
                      { "value": "'" }
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("SqlClient")]
    [InlineData("Oracle")]
    [InlineData("Npgsql")]
    [InlineData("MySql")]
    public void GivenASqlQueryWithEscapedStringLiteral_WhenSerialized_JsonIsRedacted1(string database)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "table", "users");
        var ranges = new Range[] { new Range(14, 5, source) };
        var evidence = new Evidence($"select * from users where username = 'I''m an escaped string'", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "table", "value": "users" }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select * from " },
                      { "source": 0, "value": "users" },
                      { "value": " where username = '" },
                      { "redacted": true },
                      { "value": "'" }
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("MySql")]
    public void GivenASqlQueryWithEscapedStringLiteral_WhenSerialized_JsonIsRedacted2(string database)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "table", "users");
        var ranges = new Range[] { new Range(14, 5, source) };
        var evidence = new Evidence($"select * from users where username = \"I\\\"m an escaped string\"", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "table", "value": "users" }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select * from " },
                      { "source": 0, "value": "users" },
                      { "value": " where username = \"" },
                      { "redacted": true },
                      { "value": "\"" }
                    ]
                              }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("Oracle")]
    public void GivenASqlQueryWithEscapedStringLiteral_WhenSerialized_JsonIsRedacted3(string database)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "table", "users");
        var ranges = new Range[] { new Range(14, 5, source) };
        var evidence = new Evidence($"select * from users where username = q'<I'm an escaped string>'", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "table", "value": "users" }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select * from " },
                      { "source": 0, "value": "users" },
                      { "value": " where username = q'<" },
                      { "redacted": true },
                      { "value": ">'" }
                    ]
                              }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("Npgsql")]
    public void GivenASqlQueryWithEscapedStringLiteral_WhenSerialized_JsonIsRedacted4(string database)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "table", "users");
        var ranges = new Range[] { new Range(14, 5, source) };
        var evidence = new Evidence($"select * from users where username = $$I'm an escaped string$$", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "table", "value": "users" }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select * from " },
                      { "source": 0, "value": "users" },
                      { "value": " where username = $$" },
                      { "redacted": true },
                      { "value": "$$" }
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("Npgsql")]
    public void GivenASqlQueryWithEscapedStringLiteral_WhenSerialized_JsonIsRedacted5(string database)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "table", "users");
        var ranges = new Range[] { new Range(14, 5, source) };
        var evidence = new Evidence($"select * from users where username = $escape$I'm an escaped string$escape$", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "table", "value": "users" }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select * from " },
                      { "source": 0, "value": "users" },
                      { "value": " where username = $escape$" },
                      { "redacted": true },
                      { "value": "$escape$" }
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("SqlClient", "0")]
    [InlineData("Oracle", "0")]
    [InlineData("Npgsql", "0")]
    [InlineData("MySql", "0")]
    [InlineData("SqlClient", "12345")]
    [InlineData("Oracle", "12345")]
    [InlineData("Npgsql", "12345")]
    [InlineData("MySql", "12345")]
    [InlineData("SqlClient", "+12345")]
    [InlineData("Oracle", "+12345")]
    [InlineData("Npgsql", "+12345")]
    [InlineData("MySql", "+12345")]
    [InlineData("SqlClient", "-12345")]
    [InlineData("Oracle", "-12345")]
    [InlineData("Npgsql", "-12345")]
    [InlineData("MySql", "-12345")]
    [InlineData("SqlClient", "12.345")]
    [InlineData("Oracle", "12.345")]
    [InlineData("Npgsql", "12.345")]
    [InlineData("MySql", "12.345")]
    [InlineData("SqlClient", ".2345")]
    [InlineData("Oracle", ".2345")]
    [InlineData("Npgsql", ".2345")]
    [InlineData("MySql", ".2345")]
    [InlineData("SqlClient", "12.345E3")]
    [InlineData("Oracle", "12.345E3")]
    [InlineData("Npgsql", "12.345E3")]
    [InlineData("MySql", "12.345E3")]
    [InlineData("SqlClient", "12.345E+3")]
    [InlineData("Oracle", "12.345E+3")]
    [InlineData("Npgsql", "12.345E+3")]
    [InlineData("MySql", "12.345E+3")]
    [InlineData("SqlClient", "12.345E-3")]
    [InlineData("Oracle", "12.345E-3")]
    [InlineData("Npgsql", "12.345E-3")]
    [InlineData("MySql", "12.345E-3")]
    [InlineData("SqlClient", "12E-3")]
    [InlineData("Oracle", "12E-3")]
    [InlineData("Npgsql", "12E-3")]
    [InlineData("MySql", "12E-3")]
    [InlineData("SqlClient", "X'12AE'")]
    [InlineData("Oracle", "X'12AE'")]
    [InlineData("Npgsql", "X'12AE'")]
    [InlineData("MySql", "X'12AE'")]
    [InlineData("SqlClient", "B'0011'")]
    [InlineData("Oracle", "B'0011'")]
    [InlineData("Npgsql", "B'0011'")]
    [InlineData("MySql", "B'0011'")]
    [InlineData("SqlClient", "0b0011")]
    [InlineData("Oracle", "0b0011")]
    [InlineData("Npgsql", "0b0011")]
    [InlineData("MySql", "0b0011")]
    public void GivenASqlQueryWithNumericLiteral_WhenSerialized_JsonIsRedacted(string database, string literal)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "table", "users");
        var ranges = new Range[] { new Range(14, 5, source) };
        var evidence = new Evidence($"select * from users where user_colum_12345 = {literal}", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "table", "value": "users" }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select * from " },
                      { "source": 0, "value": "users" },
                      { "value": " where user_colum_12345 = " },
                      { "redacted": true }
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("SqlClient")]
    [InlineData("Oracle")]
    [InlineData("Npgsql")]
    [InlineData("MySql")]
    public void GivenASqlQueryWithBlockComment_WhenSerialized_JsonIsRedacted(string database)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "table", "users");
        var ranges = new Range[] { new Range(14, 5, source) };
        var evidence = new Evidence($"select * from users/*\nThis is a block comment\n*/", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "table", "value": "users" }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select * from " },
                      { "source": 0, "value": "users" },
                      { "value": "/*" },
                      { "redacted": true },
                      { "value": "*/" }
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("SqlClient")]
    [InlineData("Oracle")]
    [InlineData("Npgsql")]
    [InlineData("MySql")]
    public void GivenASqlQueryWithLineComment_WhenSerialized_JsonIsRedacted(string database)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "table", "users");
        var ranges = new Range[] { new Range(14, 5, source) };
        var evidence = new Evidence($"select * from users -- This is a line comment", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "table", "value": "users" }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select * from " },
                      { "source": 0, "value": "users" },
                      { "value": " --" },
                      { "redacted": true }
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("SqlClient")]
    [InlineData("Oracle")]
    [InlineData("Npgsql")]
    [InlineData("MySql")]
    public void GivenASqlQueryWithStringLiteralMatchigTaintedRange_WhenSerialized_JsonIsRedacted(string database)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "username", "john");
        var ranges = new Range[] { new Range(38, 4, source) };
        var evidence = new Evidence($"select * from users where username = 'john'", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "username", "redacted": true }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select * from users where username = '" },
                      { "source": 0, "redacted": true },
                      { "value": "'" }
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("SqlClient")]
    [InlineData("Oracle")]
    [InlineData("Npgsql")]
    [InlineData("MySql")]
    public void GivenASqlQueryWithNumericLiteralMatchingTaintedRange_WhenSerialized_JsonIsRedacted(string database)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "user_id", "123");
        var ranges = new Range[] { new Range(36, 3, source) };
        var evidence = new Evidence($"select * from users where user_id = 123", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "user_id", "redacted": true }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select * from users where user_id = " },
                      { "source": 0, "redacted": true },
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("SqlClient")]
    [InlineData("Oracle")]
    [InlineData("Npgsql")]
    [InlineData("MySql")]
    public void GivenASqlQueryWithStringLiteralOverlappingSensitiveSource_WhenSerialized_JsonIsRedacted(string database)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "password", "12345");
        var ranges = new Range[] { new Range(38, 5, source) };
        var evidence = new Evidence($"select * from users where password = '12345'", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "password", "redacted": true }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select * from users where password = '" },
                      { "source": 0, "redacted": true },
                      { "value": "'" }
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("SqlClient")]
    [InlineData("Oracle")]
    [InlineData("Npgsql")]
    [InlineData("MySql")]
    public void GivenASqlQueryWithStringLiteralPartiallyOverlappingSensitiveSource_WhenSerialized_JsonIsRedacted(string database)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "password", "12345");
        var ranges = new Range[] { new Range(38, 5, source) };
        var evidence = new Evidence($"select * from users where password = '12345:{{xyz}}'", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "password", "redacted": true }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select * from users where password = '" },
                      { "source": 0, "redacted": true },
                      { "redacted": true },
                      { "value": "'" }
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("SqlClient")]
    [InlineData("Oracle")]
    [InlineData("Npgsql")]
    [InlineData("MySql")]
    public void GivenASqlQueryWithStringLiteralPartiallyOverlappingTaintedRange_WhenSerialized_JsonIsRedacted(string database)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "password", "12345");
        var ranges = new Range[] { new Range(38, 5, source) };
        var evidence = new Evidence($"select * from users where password = '12345:{{xyz}}'", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "password", "redacted": true }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select * from users where password = '" },
                      { "source": 0, "redacted": true },
                      { "redacted": true },
                      { "value": "'" }
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("SqlClient")]
    [InlineData("Oracle")]
    [InlineData("Npgsql")]
    [InlineData("MySql")]
    public void GivenASqlQueryWithStringLiteralAndTaintedRangeCrossingBoundaries_WhenSerialized_JsonIsRedacted(string database)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "clause", "john");
        var ranges = new Range[] { new Range(26, 17, source) };
        var evidence = new Evidence($"select * from users where username = 'john'", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "clause", "redacted": true }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select * from users where " },
                      { "source": 0, "redacted": true }
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("SqlClient")]
    [InlineData("Oracle")]
    [InlineData("Npgsql")]
    [InlineData("MySql")]
    public void GivenASqlQueryWithStringLiteralAndWeirdTaintedRangeCrossingBoundaries_WhenSerialized_JsonIsRedacted(string database)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source = new Source(3, "clause", "john");
        var ranges = new Range[] { new Range(26, 16, source) };
        var evidence = new Evidence($"select * from users where username = 'john:ADMIN_ROLE'", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "clause", "redacted": true }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select * from users where " },
                      { "source": 0, "redacted": true },
                      { "redacted": true },
                      { "value": "'" }
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }

    [Theory]
    [InlineData("SqlClient")]
    [InlineData("Oracle")]
    [InlineData("Npgsql")]
    public void GivenASqlQueryWithMultipleRangesAndLiterals_WhenSerialized_JsonIsRedacted(string database)
    {
        var integrationId = (IntegrationId)System.Enum.Parse(typeof(IntegrationId), database);
        var batch = Utils.GetRedactedBatch();
        var source2 = new Source(3, "last_name", "doe");
        var source3 = new Source(3, "password", "super_secure");
        var ranges = new Range[]
        {
            new Range(60, 4, new Source(3, "first_name", "john")),
            new Range(65, 3, new Source(3, "last_name", "doe")),
            new Range(89, 12, new Source(3, "password", "super_secure")),
        };
        var evidence = new Evidence($"select id as \"super user id\"\n\tfrom users\n\twhere username = 'john:doe' and password LIKE 'super_secure%' and user_id_123 > 00000", ranges);
        var vulnerability = new Vulnerability("SQL_INJECTION", new Location(), evidence, integrationId);
        batch.Add(vulnerability);

        var json = batch.ToJson();
        json.Should().BeJsonEquivalentTo(
            """
            {
              "sources": [
                { "origin": "http.request.parameter", "name": "first_name", "redacted": true },
                { "origin": "http.request.parameter", "name": "last_name", "redacted": true },
                { "origin": "http.request.parameter", "name": "password", "redacted": true }
              ],
              "vulnerabilities": [
                {
                  "type": "SQL_INJECTION",
                  "evidence": {
                  "valueParts": [
                      { "value": "select id as \"super user id\"\n\tfrom users\n\twhere username = '" },
                      { "source": 0, "redacted": true },
                      { "redacted": true },
                      { "source": 1, "redacted": true },
                      { "value": "' and password LIKE '" },
                      { "source": 2, "redacted": true },
                      { "redacted": true },
                      { "value": "' and user_id_123 > " },
                      { "redacted": true } 
                    ]
                  }
                }
              ]
            }
            """,
            _defaultScrubber);
    }
}
