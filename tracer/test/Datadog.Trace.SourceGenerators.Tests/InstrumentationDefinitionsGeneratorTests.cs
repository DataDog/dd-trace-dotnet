// <copyright file="InstrumentationDefinitionsGeneratorTests.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

using Datadog.Trace.SourceGenerators.InstrumentationDefinitions;
using Datadog.Trace.SourceGenerators.InstrumentationDefinitions.Diagnostics;
using Xunit;

namespace Datadog.Trace.SourceGenerators.Tests
{
    public class InstrumentationDefinitionsGeneratorTests
    {
        [Fact]
        public void DoesNotGenerateDefinitionsIfThereAreNone()
        {
            const string input = @"using Datadog.Trace.SourceGenerators;

namespace MyTests
{
    public class TestList 
    { 
    }
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(input);
            Assert.Empty(output);
            Assert.Empty(diagnostics);
        }

        [Fact]
        public void CanGenerateIntegrationDefinitionForStandardInstrumentation()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
    AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            const string expected = @"// <auto-generated/>
#nullable enable

namespace Datadog.Trace.ClrProfiler
{
    internal static partial class InstrumentationDefinitions
    {
        private static NativeCallTargetDefinition[] GetDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {
                // Kafka
                new(""Confluent.Kafka"", ""Confluent.Kafka.Producer`2"", ""Produce"",  new[] { ""System.Void"", ""Confluent.Kafka.TopicPartition"", ""Confluent.Kafka.Message`2[!0,!1]"", ""System.Action`1[Confluent.Kafka.DeliveryReport`2[!0,!1]]"" }, 1, 4, 0, 1, 65535, 65535, assemblyFullName, ""Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka.KafkaProduceSyncIntegration""),
            };

        private static NativeCallTargetDefinition[] GetDerivedDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {
            };
    }
}
";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Equal(expected, output);
            Assert.Empty(diagnostics);
        }

        [Fact]
        public void CanGenerateMultipleIntegrationDefinitionsForStandardInstrumentation()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
    AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}

[InstrumentMethod(
    AssemblyName = ""Confluent.Kafka"",
    TypeName = ""Confluent.Kafka.Producer`2"",
    MethodName = ""ProduceAsync"",
    ReturnTypeName = KafkaConstants.TaskDeliveryReportTypeName,
    ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, ClrNames.CancellationToken },
    MinimumVersion = ""1.4.0"",
    MaximumVersion = ""1.*.*"",
    IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceAsyncIntegration
{
}
";

            const string expected = @"// <auto-generated/>
#nullable enable

namespace Datadog.Trace.ClrProfiler
{
    internal static partial class InstrumentationDefinitions
    {
        private static NativeCallTargetDefinition[] GetDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {
                // Kafka
                new(""Confluent.Kafka"", ""Confluent.Kafka.Producer`2"", ""Produce"",  new[] { ""System.Void"", ""Confluent.Kafka.TopicPartition"", ""Confluent.Kafka.Message`2[!0,!1]"", ""System.Action`1[Confluent.Kafka.DeliveryReport`2[!0,!1]]"" }, 1, 4, 0, 1, 65535, 65535, assemblyFullName, ""Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka.KafkaProduceSyncIntegration""),
                new(""Confluent.Kafka"", ""Confluent.Kafka.Producer`2"", ""ProduceAsync"",  new[] { ""System.Threading.Tasks.Task`1[Confluent.Kafka.DeliveryReport`2[!0,!1]]"", ""Confluent.Kafka.TopicPartition"", ""Confluent.Kafka.Message`2[!0,!1]"", ""System.Threading.CancellationToken"" }, 1, 4, 0, 1, 65535, 65535, assemblyFullName, ""Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka.KafkaProduceAsyncIntegration""),
            };

        private static NativeCallTargetDefinition[] GetDerivedDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {
            };
    }
}
";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Equal(expected, output);
            Assert.Empty(diagnostics);
        }

        [Fact]
        public void CanGenerateMultipleIntegrationDefinitionWhenHaveMultipleTypes()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
    AssemblyName = ""Confluent.Kafka"",
    TypeNames = new[] { ""Confluent.Kafka.Producer`2"", ""Confluent.Kafka.AsyncProducer`2"" },
    MethodName = ""Produce"",
    ReturnTypeName = ClrNames.Void,
    ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
    MinimumVersion = ""1.4.0"",
    MaximumVersion = ""1.*.*"",
    IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}
";

            const string expected = @"// <auto-generated/>
#nullable enable

namespace Datadog.Trace.ClrProfiler
{
    internal static partial class InstrumentationDefinitions
    {
        private static NativeCallTargetDefinition[] GetDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {
                // Kafka
                new(""Confluent.Kafka"", ""Confluent.Kafka.AsyncProducer`2"", ""Produce"",  new[] { ""System.Void"", ""Confluent.Kafka.TopicPartition"", ""Confluent.Kafka.Message`2[!0,!1]"", ""System.Action`1[Confluent.Kafka.DeliveryReport`2[!0,!1]]"" }, 1, 4, 0, 1, 65535, 65535, assemblyFullName, ""Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka.KafkaProduceSyncIntegration""),
                new(""Confluent.Kafka"", ""Confluent.Kafka.Producer`2"", ""Produce"",  new[] { ""System.Void"", ""Confluent.Kafka.TopicPartition"", ""Confluent.Kafka.Message`2[!0,!1]"", ""System.Action`1[Confluent.Kafka.DeliveryReport`2[!0,!1]]"" }, 1, 4, 0, 1, 65535, 65535, assemblyFullName, ""Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka.KafkaProduceSyncIntegration""),
            };

        private static NativeCallTargetDefinition[] GetDerivedDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {
            };
    }
}
";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Equal(expected, output);
            Assert.Empty(diagnostics);
        }

        [Fact]
        public void CanGenerateMultipleIntegrationDefinitionsWhenUsingDerivedIntegrationType()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
    AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}

[InstrumentMethod(
    AssemblyName = ""Confluent.Kafka"",
    TypeName = ""Confluent.Kafka.Producer`2"",
    MethodName = ""ProduceAsync"",
    ReturnTypeName = KafkaConstants.TaskDeliveryReportTypeName,
    ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, ClrNames.CancellationToken },
    MinimumVersion = ""1.4.0"",
    MaximumVersion = ""1.*.*"",
    CallTargetIntegrationType = IntegrationType.Derived,
    IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceAsyncIntegration
{
}
";

            const string expected = @"// <auto-generated/>
#nullable enable

namespace Datadog.Trace.ClrProfiler
{
    internal static partial class InstrumentationDefinitions
    {
        private static NativeCallTargetDefinition[] GetDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {
                // Kafka
                new(""Confluent.Kafka"", ""Confluent.Kafka.Producer`2"", ""Produce"",  new[] { ""System.Void"", ""Confluent.Kafka.TopicPartition"", ""Confluent.Kafka.Message`2[!0,!1]"", ""System.Action`1[Confluent.Kafka.DeliveryReport`2[!0,!1]]"" }, 1, 4, 0, 1, 65535, 65535, assemblyFullName, ""Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka.KafkaProduceSyncIntegration""),
            };

        private static NativeCallTargetDefinition[] GetDerivedDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {
                // Kafka
                new(""Confluent.Kafka"", ""Confluent.Kafka.Producer`2"", ""ProduceAsync"",  new[] { ""System.Threading.Tasks.Task`1[Confluent.Kafka.DeliveryReport`2[!0,!1]]"", ""Confluent.Kafka.TopicPartition"", ""Confluent.Kafka.Message`2[!0,!1]"", ""System.Threading.CancellationToken"" }, 1, 4, 0, 1, 65535, 65535, assemblyFullName, ""Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka.KafkaProduceAsyncIntegration""),
            };
    }
}
";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Equal(expected, output);
            Assert.Empty(diagnostics);
        }

        [Fact]
        public void CanGenerateAdoNetIntegration()
        {
            const string input = @"
using Datadog.Trace.ClrProfiler.AutoInstrumentation.AdoNet;
using Datadog.Trace.Configuration;
using static Datadog.Trace.ClrProfiler.AutoInstrumentation.AdoNet.AdoNetClientInstrumentMethodAttribute;

/********************************************************************************
 * MySql
 ********************************************************************************/
#pragma warning disable SA1118 // parameter spans multiple lines
[assembly: AdoNetClientInstrumentMethod(
    AssemblyName = ""MySql.Data"",
    TypeName = ""MySql.Data.MySqlClient.MySqlCommand"",
    MinimumVersion = ""6.7.0"",
    MaximumVersion = ""6.*.*"",
    IntegrationName = ""MySql""
    DataReaderType = ""MySql.Data.MySqlClient.MySqlDataReader"",
    DataReaderTaskType = ""System.Threading.Tasks.Task`1<MySql.Data.MySqlClient.MySqlDataReader>"",
    SignatureAttributes = new[]
    {
        typeof(CommandExecuteNonQueryAttribute),
        typeof(CommandExecuteReaderAttribute),
    })]
";

            const string expected = @"// <auto-generated/>
#nullable enable

namespace Datadog.Trace.ClrProfiler
{
    internal static partial class InstrumentationDefinitions
    {
        private static NativeCallTargetDefinition[] GetDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {
                // MySql
                new(""MySql.Data"", ""MySql.Data.MySqlClient.MySqlCommand"", ""ExecuteNonQuery"",  new[] { ""System.Int32"" }, 6, 7, 0, 6, 65535, 65535, assemblyFullName, ""Datadog.Trace.ClrProfiler.AutoInstrumentation.AdoNet.CommandExecuteNonQueryIntegration""),
                new(""MySql.Data"", ""MySql.Data.MySqlClient.MySqlCommand"", ""ExecuteReader"",  new[] { ""MySql.Data.MySqlClient.MySqlDataReader"" }, 6, 7, 0, 6, 65535, 65535, assemblyFullName, ""Datadog.Trace.ClrProfiler.AutoInstrumentation.AdoNet.CommandExecuteReaderIntegration""),
            };

        private static NativeCallTargetDefinition[] GetDerivedDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {
            };
    }
}
";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.AdoNetInstrumentationAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(diagnostics);
            Assert.Equal(expected, output);
        }

        [Fact]
        public void AddsDiagnosticForMissingAssembly()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
    // AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == MissingRequiredPropertyDiagnostic.Id);
        }

        [Fact]
        public void AddsDiagnosticForMissingTypeName()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        // TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == MissingRequiredPropertyDiagnostic.Id);
        }

        [Fact]
        public void AddsDiagnosticForMissingMethodName()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        // MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == MissingRequiredPropertyDiagnostic.Id);
        }

        [Fact]
        public void AddsDiagnosticForMissingReturnTypeName()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        // ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == MissingRequiredPropertyDiagnostic.Id);
        }

        [Fact]
        public void AddsDiagnosticForMissingMinVersion()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        // MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == MissingRequiredPropertyDiagnostic.Id);
        }

        [Theory]
        [InlineData("-1.2.0")]
        [InlineData("1..")]
        [InlineData("1.0.")]
        public void AddsDiagnosticForInvalidMinVersionFormat(string minVersion)
        {
            var input = $@"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] {{ KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName }},
        MinimumVersion = ""{minVersion}"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{{ 
}}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == InvalidVersionFormatDiagnostic.Id);
        }

        [Theory]
        [InlineData("-1.2.0")]
        [InlineData("1..")]
        [InlineData("1.0.")]
        public void AddsDiagnosticForInvalidMaxVersionFormat(string maxVersion)
        {
            var input = $@"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] {{ KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName }},
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""{maxVersion}"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{{ 
}}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == InvalidVersionFormatDiagnostic.Id);
        }

        [Fact]
        public void AddsDiagnosticForMissingMaxVersion()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        // MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == MissingRequiredPropertyDiagnostic.Id);
        }

        [Fact]
        public void AddsDiagnosticForMissingIntegrationName()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"")]
        // IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == MissingRequiredPropertyDiagnostic.Id);
        }

        public static class SourceHelper
        {
            public const string InstrumentMethodAttribute = @"using Datadog.Trace.ClrProfiler;
using System;
using System.ComponentModel;

namespace Datadog.Trace.ClrProfiler;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false)]
[Browsable(false)]
[EditorBrowsable(EditorBrowsableState.Never)]
internal class InstrumentMethodAttribute : Attribute
{
    public string AssemblyName
    {
        get
        {
            switch (AssemblyNames?.Length ?? 0)
            {
                case 0:
                    return null;
                case 1:
                    return AssemblyNames[0];
                default:
                    throw new InvalidOperationException(""Multiple assemblies are not supported using this property. Use AssemblyNames property instead."");
                    return null;
            }
        }
        set => AssemblyNames = new[] { value };
    }

    public string[] AssemblyNames { get; set; }
    public string TypeName
    {
        get
        {
            switch (TypeNames?.Length ?? 0)
            {
                case 0:
                    return null;
                case 1:
                    return TypeNames[0];
                default:
                    ThrowHelper.ThrowNotSupportedException(""Multiple type names are not supported using this property. Use TypeNames property instead."");
                    return null;
            }
        }
        set => TypeNames = new[] { value };
    }
    public string[] TypeNames { get; set; }
    public string MethodName { get; set; }
    public string ReturnTypeName { get; set; }
    public string[] ParameterTypeNames { get; set; }
    // public IntegrationVersionRange VersionRange { get; } = new IntegrationVersionRange();
    public string MinimumVersion { get; set; }
    public string MaximumVersion { get; set; }
    public string IntegrationName { get; set; }
    public Type CallTargetType { get; set; }
    public IntegrationType CallTargetIntegrationType { get; set; };
}

internal enum IntegrationType
{
    /// <summary>
    /// Default calltarget integration
    /// </summary>
    Default = 0,

    /// <summary>
    /// Derived calltarget integration
    /// </summary>
    Derived = 1
}
";

            public const string KafkaConstants = @"
using System;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

internal static class KafkaConstants
{
    internal const string IntegrationName = ""Kafka"";
    internal const string ConsumeOperationName = ""kafka.consume"";
    internal const string ProduceOperationName = ""kafka.produce"";
    internal const string TopicPartitionTypeName = ""Confluent.Kafka.TopicPartition"";
    internal const string MessageTypeName = ""Confluent.Kafka.Message`2[!0,!1]"";
    internal const string ConsumeResultTypeName = ""Confluent.Kafka.ConsumeResult`2[!0,!1]"";
    internal const string ActionOfDeliveryReportTypeName = ""System.Action`1[Confluent.Kafka.DeliveryReport`2[!0,!1]]"";
    internal const string TaskDeliveryReportTypeName = ""System.Threading.Tasks.Task`1[Confluent.Kafka.DeliveryReport`2[!0,!1]]"";
    internal const string ServiceName = ""kafka"";
}";

            public const string ClrNames = @"
namespace Datadog.Trace.ClrProfiler
{
    internal static class ClrNames
    {
        public const string Ignore = ""_"";

        public const string Void = ""System.Void"";
        public const string Object = ""System.Object"";
        public const string Bool = ""System.Boolean"";
        public const string String = ""System.String"";

        public const string SByte = ""System.SByte"";
        public const string Byte = ""System.Byte"";

        public const string Int16 = ""System.Int16"";
        public const string Int32 = ""System.Int32"";
        public const string Int64 = ""System.Int64"";

        public const string UInt16 = ""System.UInt16"";
        public const string UInt32 = ""System.UInt32"";
        public const string UInt64 = ""System.UInt64"";

        public const string TimeSpan = ""System.TimeSpan"";

        public const string Stream = ""System.IO.Stream"";

        public const string Task = ""System.Threading.Tasks.Task"";
        public const string CancellationToken = ""System.Threading.CancellationToken"";

        // ReSharper disable once InconsistentNaming
        public const string IAsyncResult = ""System.IAsyncResult"";
        public const string AsyncCallback = ""System.AsyncCallback"";

        public const string HttpRequestMessage = ""System.Net.Http.HttpRequestMessage"";
        public const string HttpResponseMessage = ""System.Net.Http.HttpResponseMessage"";
        public const string HttpResponseMessageTask = ""System.Threading.Tasks.Task`1<System.Net.Http.HttpResponseMessage>"";

        public const string GenericTask = ""System.Threading.Tasks.Task`1"";
        public const string IgnoreGenericTask = ""System.Threading.Tasks.Task`1<_>"";
        public const string GenericParameterTask = ""System.Threading.Tasks.Task`1<T>"";
        public const string ObjectTask = ""System.Threading.Tasks.Task`1<System.Object>"";
        public const string Int32Task = ""System.Threading.Tasks.Task`1<System.Int32>"";

        public const string Type = ""System.Type"";
    }
}";

            public const string AdoNetInstrumentationAttribute = @"
using System;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.AdoNet
{
    /// <summary>
    /// Attribute that indicates that the decorated class is meant to intercept a method
    /// by modifying the method body with callbacks. Used to generate the integration definitions file.
    /// </summary>
    [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
    internal sealed class AdoNetClientInstrumentMethodAttribute : Attribute
    {
        /// <summary>
        /// Gets or sets the name of the assembly that contains the target method to be intercepted.
        /// Required.
        /// </summary>
        public string AssemblyName { get; set; }

        /// <summary>
        /// Gets or sets the name of the type that contain the target method to be intercepted.
        /// Required.
        /// </summary>
        public string TypeName { get; set; }

        /// <summary>
        /// Gets or sets the target minimum version.
        /// </summary>
        public string MinimumVersion { get; set; }

        /// <summary>
        /// Gets or sets the target maximum version.
        /// </summary>
        public string MaximumVersion { get; set; }

        /// <summary>
        /// Gets or sets the integration name. Allows to group several integration with a single integration name.
        /// </summary>
        public string IntegrationName { get; set; }

        /// <summary>
        /// Gets or sets the DataReader type to use with target signatures that require it
        /// Required.
        /// </summary>
        public string DataReaderType { get; set; }

        /// <summary>
        /// Gets or sets the DataReader type to use with target signatures that require it
        /// Required.
        /// </summary>
        public string DataReaderTaskType { get; set; }

        /// <summary>
        /// Gets or sets the names of attributes decorated with <see cref=""AdoNetTargetSignatureAttribute""/>.
        /// Describes all the signatures to instrument
        /// Required.
        /// </summary>
        public Type[] SignatureAttributes { get; set; }

        [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
        internal class AdoNetTargetSignatureAttribute : Attribute
        {
            internal enum AdoNetTargetSignatureReturnType
            {
                /// <summary>
                ///  Uses the fixed return type specified in <see cref=""AdoNetTargetSignatureAttribute.ReturnTypeName"" />
                /// </summary>
                Default,

                /// <summary>
                ///  Uses the return type specified in <see cref=""AdoNetClientInstrumentMethodAttribute.DataReaderType"" />
                /// </summary>
                DataReaderType,

                /// <summary>
                ///  Uses the return type specified in <see cref=""AdoNetClientInstrumentMethodAttribute.DataReaderTaskType"" />
                /// </summary>
                DataReaderTaskType,
            }

            /// <summary>
            /// Gets or sets the name of the target method to be intercepted.
            /// If null, default to the name of the decorated method.
            /// </summary>
            public string MethodName { get; set; }

            /// <summary>
            /// Gets or sets the return type name
            /// </summary>
            public string ReturnTypeName { get; set; }

            /// <summary>
            /// Gets or sets the parameters type array for the target method to be intercepted.
            /// </summary>
            public string[] ParameterTypeNames { get; set; }

            /// <summary>
            /// Gets or sets the CallTarget Class used to instrument the method
            /// </summary>
            public Type CallTargetType { get; set; }

            /// <summary>
            /// Gets or sets the CallTarget integration type
            /// </summary>
            public IntegrationType CallTargetIntegrationType { get; set; } = IntegrationType.Default;

            /// <summary>
            /// Gets or sets the return type to use with this signature
            /// </summary>
            public AdoNetTargetSignatureReturnType ReturnType { get; set; } = AdoNetTargetSignatureReturnType.Default;
        }

        [AdoNetTargetSignature(
            MethodName = ""ExecuteNonQuery"",
            ReturnTypeName = ""System.Int32"",
            CallTargetType = typeof(CommandExecuteNonQueryIntegration),
            CallTargetIntegrationType = IntegrationType.Default)]
        [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
        internal class CommandExecuteNonQueryAttribute : Attribute
        {
        }

        [AdoNetTargetSignature(
            MethodName = ""ExecuteReader"",
            ReturnType = AdoNetTargetSignatureAttribute.AdoNetTargetSignatureReturnType.DataReaderType,
            CallTargetType = typeof(CommandExecuteReaderIntegration))]
        [AttributeUsage(AttributeTargets.Class, AllowMultiple = true, Inherited = false)]
        internal class CommandExecuteReaderAttribute : Attribute
        {
        }
    }

    public class CommandExecuteNonQueryIntegration
    {
    }
    public class CommandExecuteReaderIntegration
    {
    }
}
";
        }
    }
}
