// <copyright file="InstrumentationDefinitionsGeneratorTests.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

using Datadog.Trace.SourceGenerators.InstrumentationDefinitions;
using Datadog.Trace.SourceGenerators.InstrumentationDefinitions.Diagnostics;
using Xunit;

namespace Datadog.Trace.SourceGenerators.Tests
{
    public class InstrumentationDefinitionsGeneratorTests
    {
        [Fact]
        public void DoesNotGenerateDefinitionsIfThereAreNone()
        {
            const string input = @"using Datadog.Trace.SourceGenerators;

namespace MyTests
{
    public class TestList 
    { 
    }
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(input);
            Assert.Empty(output);
            Assert.Empty(diagnostics);
        }

        [Fact]
        public void CanGenerateIntegrationDefinitionForStandardInstrumentation()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
    AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            const string expected = @"// <auto-generated/>
#nullable enable

namespace Datadog.Trace.ClrProfiler
{
    internal static partial class InstrumentationDefinitions
    {
        private static NativeCallTargetDefinition[] GetDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {
                // Kafka
                new(""Confluent.Kafka"", ""Confluent.Kafka.Producer`2"", ""Produce"",  new[] { ""System.Void"", ""Confluent.Kafka.TopicPartition"", ""Confluent.Kafka.Message`2[!0,!1]"", ""System.Action`1[Confluent.Kafka.DeliveryReport`2[!0,!1]]"" }, 1, 4, 0, 1, 65535, 65535, assemblyFullName, ""Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka.KafkaProduceSyncIntegration""),
            };

        private static NativeCallTargetDefinition[] GetDerivedDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {
            };
    }
}
";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Equal(expected, output);
            Assert.Empty(diagnostics);
        }

        [Fact]
        public void CanGenerateMultipleIntegrationDefinitionsForStandardInstrumentation()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
    AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}

[InstrumentMethod(
    AssemblyName = ""Confluent.Kafka"",
    TypeName = ""Confluent.Kafka.Producer`2"",
    MethodName = ""ProduceAsync"",
    ReturnTypeName = KafkaConstants.TaskDeliveryReportTypeName,
    ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, ClrNames.CancellationToken },
    MinimumVersion = ""1.4.0"",
    MaximumVersion = ""1.*.*"",
    IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceAsyncIntegration
{
}
";

            const string expected = @"// <auto-generated/>
#nullable enable

namespace Datadog.Trace.ClrProfiler
{
    internal static partial class InstrumentationDefinitions
    {
        private static NativeCallTargetDefinition[] GetDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {
                // Kafka
                new(""Confluent.Kafka"", ""Confluent.Kafka.Producer`2"", ""Produce"",  new[] { ""System.Void"", ""Confluent.Kafka.TopicPartition"", ""Confluent.Kafka.Message`2[!0,!1]"", ""System.Action`1[Confluent.Kafka.DeliveryReport`2[!0,!1]]"" }, 1, 4, 0, 1, 65535, 65535, assemblyFullName, ""Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka.KafkaProduceSyncIntegration""),
                new(""Confluent.Kafka"", ""Confluent.Kafka.Producer`2"", ""ProduceAsync"",  new[] { ""System.Threading.Tasks.Task`1[Confluent.Kafka.DeliveryReport`2[!0,!1]]"", ""Confluent.Kafka.TopicPartition"", ""Confluent.Kafka.Message`2[!0,!1]"", ""System.Threading.CancellationToken"" }, 1, 4, 0, 1, 65535, 65535, assemblyFullName, ""Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka.KafkaProduceAsyncIntegration""),
            };

        private static NativeCallTargetDefinition[] GetDerivedDefinitionsArray()
            => new NativeCallTargetDefinition[]
            {
            };
    }
}
";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Equal(expected, output);
            Assert.Empty(diagnostics);
        }

        [Fact]
        public void AddsDiagnosticForMissingAssembly()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
    // AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == MissingRequiredPropertyDiagnostic.Id);
        }

        [Fact]
        public void AddsDiagnosticForMissingTypeName()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        // TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == MissingRequiredPropertyDiagnostic.Id);
        }

        [Fact]
        public void AddsDiagnosticForMissingMethodName()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        // MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == MissingRequiredPropertyDiagnostic.Id);
        }

        [Fact]
        public void AddsDiagnosticForMissingReturnTypeName()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        // ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == MissingRequiredPropertyDiagnostic.Id);
        }

        [Fact]
        public void AddsDiagnosticForMissingMinVersion()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        // MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == MissingRequiredPropertyDiagnostic.Id);
        }

        [Theory]
        [InlineData("-1.2.0")]
        [InlineData("1..")]
        [InlineData("1.0.")]
        public void AddsDiagnosticForInvalidMinVersionFormat(string minVersion)
        {
            var input = $@"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] {{ KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName }},
        MinimumVersion = ""{minVersion}"",
        MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{{ 
}}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == InvalidVersionFormatDiagnostic.Id);
        }

        [Theory]
        [InlineData("-1.2.0")]
        [InlineData("1..")]
        [InlineData("1.0.")]
        public void AddsDiagnosticForInvalidMaxVersionFormat(string maxVersion)
        {
            var input = $@"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] {{ KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName }},
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""{maxVersion}"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{{ 
}}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == InvalidVersionFormatDiagnostic.Id);
        }

        [Fact]
        public void AddsDiagnosticForMissingMaxVersion()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        // MaximumVersion = ""1.*.*"",
        IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == MissingRequiredPropertyDiagnostic.Id);
        }

        [Fact]
        public void AddsDiagnosticForMissingIntegrationName()
        {
            const string input = @"
using System;
using Datadog.Trace.ClrProfiler;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

[InstrumentMethod(
        AssemblyName = ""Confluent.Kafka"",
        TypeName = ""Confluent.Kafka.Producer`2"",
        MethodName = ""Produce"",
        ReturnTypeName = ClrNames.Void,
        ParameterTypeNames = new[] { KafkaConstants.TopicPartitionTypeName, KafkaConstants.MessageTypeName, KafkaConstants.ActionOfDeliveryReportTypeName },
        MinimumVersion = ""1.4.0"",
        MaximumVersion = ""1.*.*"")]
        // IntegrationName = KafkaConstants.IntegrationName)]
public class KafkaProduceSyncIntegration
{ 
}";

            var (diagnostics, output) = TestHelpers.GetGeneratedOutput<InstrumentationDefinitionsGenerator>(
                SourceHelper.InstrumentMethodAttribute,
                SourceHelper.ClrNames,
                SourceHelper.KafkaConstants,
                input);
            Assert.Empty(output);
            Assert.Contains(diagnostics, diag => diag.Id == MissingRequiredPropertyDiagnostic.Id);
        }

        public static class SourceHelper
        {
            public const string InstrumentMethodAttribute = @"using Datadog.Trace.ClrProfiler;
using System;
using System.ComponentModel;

namespace Datadog.Trace.ClrProfiler;

[AttributeUsage(AttributeTargets.Class | AttributeTargets.Assembly, AllowMultiple = true, Inherited = false)]
[Browsable(false)]
[EditorBrowsable(EditorBrowsableState.Never)]
internal class InstrumentMethodAttribute : Attribute
{
    public string AssemblyName
    {
        get
        {
            switch (AssemblyNames?.Length ?? 0)
            {
                case 0:
                    return null;
                case 1:
                    return AssemblyNames[0];
                default:
                    throw new InvalidOperationException(""Multiple assemblies are not supported using this property. Use AssemblyNames property instead."");
                    return null;
            }
        }
        set => AssemblyNames = new[] { value };
    }

    public string[] AssemblyNames { get; set; }
    public string TypeName { get; set; }
    public string MethodName { get; set; }
    public string ReturnTypeName { get; set; }
    public string[] ParameterTypeNames { get; set; }
    // public IntegrationVersionRange VersionRange { get; } = new IntegrationVersionRange();
    public string MinimumVersion { get; set; }
    public string MaximumVersion { get; set; }
    public string IntegrationName { get; set; }
    public Type CallTargetType { get; set; }
    public int CallTargetIntegrationType { get; set; };
}";

            public const string KafkaConstants = @"
using System;

namespace Datadog.Trace.ClrProfiler.AutoInstrumentation.Kafka;

internal static class KafkaConstants
{
    internal const string IntegrationName = ""Kafka"";
    internal const string ConsumeOperationName = ""kafka.consume"";
    internal const string ProduceOperationName = ""kafka.produce"";
    internal const string TopicPartitionTypeName = ""Confluent.Kafka.TopicPartition"";
    internal const string MessageTypeName = ""Confluent.Kafka.Message`2[!0,!1]"";
    internal const string ConsumeResultTypeName = ""Confluent.Kafka.ConsumeResult`2[!0,!1]"";
    internal const string ActionOfDeliveryReportTypeName = ""System.Action`1[Confluent.Kafka.DeliveryReport`2[!0,!1]]"";
    internal const string TaskDeliveryReportTypeName = ""System.Threading.Tasks.Task`1[Confluent.Kafka.DeliveryReport`2[!0,!1]]"";
    internal const string ServiceName = ""kafka"";
}";

            public const string ClrNames = @"
namespace Datadog.Trace.ClrProfiler
{
    internal static class ClrNames
    {
        public const string Ignore = ""_"";

        public const string Void = ""System.Void"";
        public const string Object = ""System.Object"";
        public const string Bool = ""System.Boolean"";
        public const string String = ""System.String"";

        public const string SByte = ""System.SByte"";
        public const string Byte = ""System.Byte"";

        public const string Int16 = ""System.Int16"";
        public const string Int32 = ""System.Int32"";
        public const string Int64 = ""System.Int64"";

        public const string UInt16 = ""System.UInt16"";
        public const string UInt32 = ""System.UInt32"";
        public const string UInt64 = ""System.UInt64"";

        public const string TimeSpan = ""System.TimeSpan"";

        public const string Stream = ""System.IO.Stream"";

        public const string Task = ""System.Threading.Tasks.Task"";
        public const string CancellationToken = ""System.Threading.CancellationToken"";

        // ReSharper disable once InconsistentNaming
        public const string IAsyncResult = ""System.IAsyncResult"";
        public const string AsyncCallback = ""System.AsyncCallback"";

        public const string HttpRequestMessage = ""System.Net.Http.HttpRequestMessage"";
        public const string HttpResponseMessage = ""System.Net.Http.HttpResponseMessage"";
        public const string HttpResponseMessageTask = ""System.Threading.Tasks.Task`1<System.Net.Http.HttpResponseMessage>"";

        public const string GenericTask = ""System.Threading.Tasks.Task`1"";
        public const string IgnoreGenericTask = ""System.Threading.Tasks.Task`1<_>"";
        public const string GenericParameterTask = ""System.Threading.Tasks.Task`1<T>"";
        public const string ObjectTask = ""System.Threading.Tasks.Task`1<System.Object>"";
        public const string Int32Task = ""System.Threading.Tasks.Task`1<System.Int32>"";

        public const string Type = ""System.Type"";
    }
}";
        }
    }
}
