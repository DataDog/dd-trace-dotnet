// <copyright file="TelemetryMetricGeneratorTests.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

using Datadog.Trace.SourceGenerators.TelemetryMetric;
using Datadog.Trace.SourceGenerators.TelemetryMetric.Diagnostics;
using FluentAssertions;
using FluentAssertions.Execution;
using Xunit;

namespace Datadog.Trace.SourceGenerators.Tests;

public class TelemetryMetricGeneratorTests
{
    [Fact] // edge case, not actually useful
    public void CanGenerateExtensionWithNoMembers()
    {
        const string input = """
            using Datadog.Trace.SourceGenerators;
            namespace MyTests.TestMetricNameSpace;

            [TelemetryMetricType("Count")]
            public enum TestMetric
            { 
            }
            """;

        const string expected = """
            // <auto-generated/>
            #nullable enable

            namespace MyTests.TestMetricNameSpace;
            internal static partial class TestMetricExtensions
            {
                /// <summary>
                /// The number of members in the enum.
                /// </summary>
                public const int Length = 0;

                /// <summary>
                /// Gets the metric name for the provided metric
                /// </summary>
                /// <param name="metric">The metric to get the name for</param>
                /// <returns>The datadog metric name</returns>
                public static string GetName(this MyTests.TestMetricNameSpace.TestMetric metric)
                    => metric switch
                    {
                        _ => null!,
                    };

                /// <summary>
                /// Gets whether the metric is a "common" metric, used by all tracers
                /// </summary>
                /// <param name="metric">The metric to check</param>
                /// <returns>True if the metric is a "common" metric, used by all languages</returns>
                public static bool IsCommon(this MyTests.TestMetricNameSpace.TestMetric metric)
                    => metric switch
                    {
                        _ => false,
                    };

                /// <summary>
                /// Gets the number of tags the metric should have
                /// </summary>
                /// <param name="metric">The metric to check</param>
                /// <returns>The number of tags the metric should have</returns>
                public static int ExpectedTags(this MyTests.TestMetricNameSpace.TestMetric metric)
                    => metric switch
                    {
                        _ => 0,
                    };

                /// <summary>
                /// Gets the custom namespace for the provided metric
                /// </summary>
                /// <param name="metric">The metric to get the name for</param>
                /// <returns>The datadog metric name</returns>
                public static string? GetNamespace(this MyTests.TestMetricNameSpace.TestMetric metric)
                    => metric switch
                    {
                        _ => null,
                    };
            }
            """;

        var (diagnostics, output) = TestHelpers.GetGeneratedOutput<TelemetryMetricGenerator>(input);
        using var scope = new AssertionScope();
        diagnostics.Should().BeEmpty();
        output.Should().Be(expected);
    }

    [Fact]
    public void CanGenerateExtensionWith1Member()
    {
        const string input = """
            using Datadog.Trace.SourceGenerators;
            namespace MyTests.TestMetricNameSpace;

            [TelemetryMetricType("Count")]
            public enum TestMetric
            { 
                [TelemetryMetric("some.metric", 1)]
                SomeMetric,
            }
            """;

        const string expected = """
            // <auto-generated/>
            #nullable enable

            namespace MyTests.TestMetricNameSpace;
            internal static partial class TestMetricExtensions
            {
                /// <summary>
                /// The number of members in the enum.
                /// </summary>
                public const int Length = 1;

                /// <summary>
                /// Gets the metric name for the provided metric
                /// </summary>
                /// <param name="metric">The metric to get the name for</param>
                /// <returns>The datadog metric name</returns>
                public static string GetName(this MyTests.TestMetricNameSpace.TestMetric metric)
                    => metric switch
                    {
                        MyTests.TestMetricNameSpace.TestMetric.SomeMetric => "some.metric",
                        _ => null!,
                    };

                /// <summary>
                /// Gets whether the metric is a "common" metric, used by all tracers
                /// </summary>
                /// <param name="metric">The metric to check</param>
                /// <returns>True if the metric is a "common" metric, used by all languages</returns>
                public static bool IsCommon(this MyTests.TestMetricNameSpace.TestMetric metric)
                    => metric switch
                    {
                        MyTests.TestMetricNameSpace.TestMetric.SomeMetric => true,
                        _ => false,
                    };

                /// <summary>
                /// Gets the number of tags the metric should have
                /// </summary>
                /// <param name="metric">The metric to check</param>
                /// <returns>The number of tags the metric should have</returns>
                public static int ExpectedTags(this MyTests.TestMetricNameSpace.TestMetric metric)
                    => metric switch
                    {
                        MyTests.TestMetricNameSpace.TestMetric.SomeMetric => 1,
                        _ => 0,
                    };

                /// <summary>
                /// Gets the custom namespace for the provided metric
                /// </summary>
                /// <param name="metric">The metric to get the name for</param>
                /// <returns>The datadog metric name</returns>
                public static string? GetNamespace(this MyTests.TestMetricNameSpace.TestMetric metric)
                    => metric switch
                    {
                        _ => null,
                    };
            }
            """;

        var (diagnostics, output) = TestHelpers.GetGeneratedOutput<TelemetryMetricGenerator>(input);
        using var scope = new AssertionScope();
        diagnostics.Should().BeEmpty();
        output.Should().Be(expected);
    }

    [Fact]
    public void CanGenerateExtensionWith3Members()
    {
        const string input = """
            using Datadog.Trace.SourceGenerators;
            namespace MyTests.TestMetricNameSpace;

            [TelemetryMetricType("Count")]
            public enum TestMetric
            { 
                [TelemetryMetric("some.metric", 1)]
                SomeMetric,
                [TelemetryMetric("another.metric", 2, false)]
                AnotherMetric,
                [TelemetryMetric("other.metric", 3, false, "ASM")]
                OtherMetric,
            }
            """;

        const string expected = """
            // <auto-generated/>
            #nullable enable

            namespace MyTests.TestMetricNameSpace;
            internal static partial class TestMetricExtensions
            {
                /// <summary>
                /// The number of members in the enum.
                /// </summary>
                public const int Length = 3;

                /// <summary>
                /// Gets the metric name for the provided metric
                /// </summary>
                /// <param name="metric">The metric to get the name for</param>
                /// <returns>The datadog metric name</returns>
                public static string GetName(this MyTests.TestMetricNameSpace.TestMetric metric)
                    => metric switch
                    {
                        MyTests.TestMetricNameSpace.TestMetric.SomeMetric => "some.metric",
                        MyTests.TestMetricNameSpace.TestMetric.AnotherMetric => "another.metric",
                        MyTests.TestMetricNameSpace.TestMetric.OtherMetric => "other.metric",
                        _ => null!,
                    };

                /// <summary>
                /// Gets whether the metric is a "common" metric, used by all tracers
                /// </summary>
                /// <param name="metric">The metric to check</param>
                /// <returns>True if the metric is a "common" metric, used by all languages</returns>
                public static bool IsCommon(this MyTests.TestMetricNameSpace.TestMetric metric)
                    => metric switch
                    {
                        MyTests.TestMetricNameSpace.TestMetric.SomeMetric => true,
                        MyTests.TestMetricNameSpace.TestMetric.AnotherMetric => false,
                        MyTests.TestMetricNameSpace.TestMetric.OtherMetric => false,
                        _ => false,
                    };

                /// <summary>
                /// Gets the number of tags the metric should have
                /// </summary>
                /// <param name="metric">The metric to check</param>
                /// <returns>The number of tags the metric should have</returns>
                public static int ExpectedTags(this MyTests.TestMetricNameSpace.TestMetric metric)
                    => metric switch
                    {
                        MyTests.TestMetricNameSpace.TestMetric.SomeMetric => 1,
                        MyTests.TestMetricNameSpace.TestMetric.AnotherMetric => 2,
                        MyTests.TestMetricNameSpace.TestMetric.OtherMetric => 3,
                        _ => 0,
                    };

                /// <summary>
                /// Gets the custom namespace for the provided metric
                /// </summary>
                /// <param name="metric">The metric to get the name for</param>
                /// <returns>The datadog metric name</returns>
                public static string? GetNamespace(this MyTests.TestMetricNameSpace.TestMetric metric)
                    => metric switch
                    {
                        MyTests.TestMetricNameSpace.TestMetric.OtherMetric => "ASM",
                        _ => null,
                    };
            }
            """;

        var (diagnostics, output) = TestHelpers.GetGeneratedOutput<TelemetryMetricGenerator>(input);
        using var scope = new AssertionScope();
        diagnostics.Should().BeEmpty();
        output.Should().Be(expected);
    }

    [Theory]
    [InlineData(@"null")]
    [InlineData("\"\"")]
    public void CantUseAnEmptyMetricType(string metricType)
    {
        var input = $$"""
            using Datadog.Trace.SourceGenerators;
            namespace MyTests.TestMetricNameSpace;

            [TelemetryMetricType({{metricType}})]
            public enum TestMetric
            { 
                [TelemetryMetric("some.metric", 1)]
                SomeMetric,
                [TelemetryMetric("another.metric", 2, false)]
                AnotherMetric,
                [TelemetryMetric("other.metric", 3, false, "ASM")]
                OtherMetric,
            }
            """;

        var (diagnostics, output) = TestHelpers.GetGeneratedOutput<TelemetryMetricGenerator>(input);
        diagnostics.Should().Contain(diag => diag.Id == MissingMetricTypeDiagnostic.Id);
    }

    [Theory]
    [InlineData(@"null")]
    [InlineData("\"\"")]
    public void CantUseAnEmptyMetricName(string name)
    {
        var input = $$"""
            using Datadog.Trace.SourceGenerators;
            namespace MyTests.TestMetricNameSpace;

            [TelemetryMetricType("Count")]
            public enum TestMetric
            { 
                [TelemetryMetric({{name}}, 1)]
                SomeMetric,
            }
            """;

        var (diagnostics, output) = TestHelpers.GetGeneratedOutput<TelemetryMetricGenerator>(input);
        diagnostics.Should().Contain(diag => diag.Id == RequiredValuesMissingDiagnostic.Id);
    }

    [Theory]
    [InlineData("\"some.metric\", 1")]
    [InlineData("\"some.metric\", 2, false")]
    [InlineData("\"some.metric\", 2, false, \"ASM\"")]
    public void CantUseDuplicateValues(string metricDefinition)
    {
        var input = $$"""
            using Datadog.Trace.SourceGenerators;
            namespace MyTests.TestMetricNameSpace;

            [TelemetryMetricType("Count")]
            public enum TestMetric
            { 
                [TelemetryMetric({{metricDefinition}})]
                SomeMetric,
                [TelemetryMetric({{metricDefinition}})]
                OtherMetric,
            }
            """;

        var (diagnostics, output) = TestHelpers.GetGeneratedOutput<TelemetryMetricGenerator>(input);
        diagnostics.Should().Contain(diag => diag.Id == DuplicateMetricValueDiagnostic.Id);
    }
}
