// <copyright file="ConfigurationKeyGeneratorTests.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

using System;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using System.Threading;
using FluentAssertions;
using FluentAssertions.Execution;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Text;
using Xunit;

namespace Datadog.Trace.SourceGenerators.Tests;

public class ConfigurationKeyGeneratorTests
{
    [Fact]
    public void GeneratesConfigKeyStructsFromSupportedConfigurations()
    {
        const string supportedConfigJson = """
            {
              "supportedConfigurations": {
                "DD_TRACE_ENABLED": {
                  "version": "A"
                },
                "DD_SERVICE": {
                  "version": "A"
                },
                "DD_ENV": {
                  "version": "A"
                }
              }
            }
            """;

        const string expected = """
            // <auto-generated/>

            using Datadog.Trace.Configuration.ConfigurationSources.Registry;
            #nullable enable

            namespace Datadog.Trace.Configuration.ConfigurationSources.Registry.Generated;

            /// <summary>
            /// Configuration key for DD_ENV
            /// </summary>
            internal readonly partial struct ConfigKeyDdEnv : IConfigKey
            {
                internal const string Key = "DD_ENV";

                /// <inheritdoc/>
                [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                public string GetKey() => Key;
            }

            /// <summary>
            /// Configuration key for DD_SERVICE
            /// </summary>
            internal readonly partial struct ConfigKeyDdService : IConfigKey
            {
                internal const string Key = "DD_SERVICE";

                /// <inheritdoc/>
                [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                public string GetKey() => Key;
            }

            /// <summary>
            /// Configuration key for DD_TRACE_ENABLED
            /// </summary>
            internal readonly partial struct ConfigKeyDdTraceEnabled : IConfigKey
            {
                internal const string Key = "DD_TRACE_ENABLED";

                /// <inheritdoc/>
                [System.Runtime.CompilerServices.MethodImpl(System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining)]
                public string GetKey() => Key;
            }


            """;

        var (diagnostics, output) = RunGenerator(supportedConfigJson);

        using var s = new AssertionScope();
        diagnostics.Should().BeEmpty();
        output.Should().Be(expected);
    }

    [Fact]
    public void GeneratesConfigKeyWithUnderscoresConvertedToPascalCase()
    {
        const string supportedConfigJson = """
            {
              "supportedConfigurations": {
                "DD_TRACE_SAMPLE_RATE": {
                  "version": "A"
                }
              }
            }
            """;

        var (diagnostics, output) = RunGenerator(supportedConfigJson);

        using var s = new AssertionScope();
        diagnostics.Should().BeEmpty();
        output.Should().Contain("struct ConfigKeyDdTraceSampleRate : IConfigKey");
        output.Should().Contain("internal const string Key = \"DD_TRACE_SAMPLE_RATE\";");
    }

    [Fact]
    public void GeneratesEmptyOutputWhenNoConfigurationsProvided()
    {
        const string supportedConfigJson = """
            {
              "supportedConfigurations": {
              }
            }
            """;

        const string expected = """
            // <auto-generated/>

            using Datadog.Trace.Configuration.ConfigurationSources.Registry;
            #nullable enable

            namespace Datadog.Trace.Configuration.ConfigurationSources.Registry.Generated;


            """;

        var (diagnostics, output) = RunGenerator(supportedConfigJson);

        using var s = new AssertionScope();
        diagnostics.Should().BeEmpty();
        output.Should().Be(expected);
    }

    [Fact]
    public void ReportsDiagnosticWhenConfigurationFileNotFound()
    {
        // No additional files provided - use empty string
        var (diagnostics, output) = RunGeneratorWithoutFile();

        using var s = new AssertionScope();
        diagnostics.Should().ContainSingle()
                   .Which.Should().Match<Diagnostic>(d =>
                       d.Id == "DDSG0003" &&
                       d.Severity == DiagnosticSeverity.Error &&
                       d.GetMessage().Contains("supported-configurations.json"));

        // Should still generate empty output to avoid compilation errors
        output.Should().Contain("namespace Datadog.Trace.Configuration.ConfigurationSources.Registry.Generated;");
    }

    [Fact]
    public void HandlesDuplicateKeysGracefully()
    {
        const string supportedConfigJson = """
            {
              "supportedConfigurations": {
                "DD_SERVICE": {
                  "version": "A"
                },
                "DD_SERVICE": {
                  "version": "B"
                }
              }
            }
            """;

        var (diagnostics, output) = RunGenerator(supportedConfigJson);

        using var s = new AssertionScope();
        diagnostics.Should().BeEmpty();
        // Should only generate one struct for DD_SERVICE
        output.Should().Contain("struct ConfigKeyDdService : IConfigKey");
        var count = output.Split(new[] { "struct ConfigKeyDdService" }, StringSplitOptions.None).Length - 1;
        count.Should().Be(1, "duplicate keys should be deduplicated");
    }

    [Fact]
    public void GeneratesKeysInAlphabeticalOrder()
    {
        const string supportedConfigJson = """
            {
              "supportedConfigurations": {
                "DD_VERSION": {
                  "version": "A"
                },
                "DD_ENV": {
                  "version": "A"
                },
                "DD_SERVICE": {
                  "version": "A"
                }
              }
            }
            """;

        var (diagnostics, output) = RunGenerator(supportedConfigJson);

        using var s = new AssertionScope();
        diagnostics.Should().BeEmpty();

        // Keys should be in alphabetical order: DD_ENV, DD_SERVICE, DD_VERSION
        var envIndex = output.IndexOf("ConfigKeyDdEnv");
        var serviceIndex = output.IndexOf("ConfigKeyDdService");
        var versionIndex = output.IndexOf("ConfigKeyDdVersion");

        envIndex.Should().BeGreaterThan(0);
        serviceIndex.Should().BeGreaterThan(envIndex);
        versionIndex.Should().BeGreaterThan(serviceIndex);
    }

    [Fact]
    public void HandlesComplexConfigurationKeys()
    {
        const string supportedConfigJson = """
            {
              "supportedConfigurations": {
                "DD_TRACE_AGENT_URL": {
                  "version": "A"
                },
                "DD_INSTRUMENTATION_TELEMETRY_ENABLED": {
                  "version": "A"
                }
              }
            }
            """;

        var (diagnostics, output) = RunGenerator(supportedConfigJson);

        using var s = new AssertionScope();
        diagnostics.Should().BeEmpty();
        output.Should().Contain("struct ConfigKeyDdTraceAgentUrl : IConfigKey");
        output.Should().Contain("struct ConfigKeyDdInstrumentationTelemetryEnabled : IConfigKey");
        output.Should().Contain("internal const string Key = \"DD_TRACE_AGENT_URL\";");
        output.Should().Contain("internal const string Key = \"DD_INSTRUMENTATION_TELEMETRY_ENABLED\";");
    }

    [Fact]
    public void GeneratesPartialStructs()
    {
        const string supportedConfigJson = """
            {
              "supportedConfigurations": {
                "DD_SERVICE": {
                  "version": "A"
                }
              }
            }
            """;

        var (diagnostics, output) = RunGenerator(supportedConfigJson);

        using var s = new AssertionScope();
        diagnostics.Should().BeEmpty();
        output.Should().Contain("internal readonly partial struct ConfigKeyDdService");
    }

    [Fact]
    public void ImplementsIConfigKeyInterface()
    {
        const string supportedConfigJson = """
            {
              "supportedConfigurations": {
                "DD_SERVICE": {
                  "version": "A"
                }
              }
            }
            """;

        var (diagnostics, output) = RunGenerator(supportedConfigJson);

        using var s = new AssertionScope();
        diagnostics.Should().BeEmpty();
        output.Should().Contain(": IConfigKey");
        output.Should().Contain("public string GetKey() => Key;");
    }

    [Fact]
    public void IncludesXmlDocumentation()
    {
        const string supportedConfigJson = """
            {
              "supportedConfigurations": {
                "DD_SERVICE": {
                  "version": "A"
                }
              }
            }
            """;

        var (diagnostics, output) = RunGenerator(supportedConfigJson);

        using var s = new AssertionScope();
        diagnostics.Should().BeEmpty();
        output.Should().Contain("/// <summary>");
        output.Should().Contain("/// Configuration key for DD_SERVICE");
        output.Should().Contain("/// </summary>");
        output.Should().Contain("/// <inheritdoc/>");
    }

    private static (ImmutableArray<Diagnostic> Diagnostics, string Output) RunGenerator(string jsonContent)
    {
        var syntaxTree = CSharpSyntaxTree.ParseText(string.Empty);
        var references = AppDomain.CurrentDomain.GetAssemblies()
                                  .Where(_ => !_.IsDynamic && !string.IsNullOrWhiteSpace(_.Location))
                                  .Select(_ => MetadataReference.CreateFromFile(_.Location))
                                  .Concat(new[] { MetadataReference.CreateFromFile(typeof(ConfigurationKeyGenerator).Assembly.Location) });

        var compilation = CSharpCompilation.Create(
            "Datadog.Trace.Generated",
            new[] { syntaxTree },
            references,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        var generator = new ConfigurationKeyGenerator().AsSourceGenerator();

        var additionalText = new TestAdditionalText("/path/to/supported-configurations.json", jsonContent);

        var opts = new GeneratorDriverOptions(
            disabledOutputs: IncrementalGeneratorOutputKind.None,
            trackIncrementalGeneratorSteps: true);

        var driver = CSharpGeneratorDriver.Create(
            new[] { generator },
            additionalTexts: new[] { additionalText },
            driverOptions: opts);

        var runResult = driver.RunGenerators(compilation).GetRunResult();

        var output = runResult.GeneratedTrees.Length > 0
            ? runResult.GeneratedTrees[0].ToString()
            : string.Empty;

        return (runResult.Diagnostics, output);
    }

    private static (ImmutableArray<Diagnostic> Diagnostics, string Output) RunGeneratorWithoutFile()
    {
        var syntaxTree = CSharpSyntaxTree.ParseText(string.Empty);
        var references = AppDomain.CurrentDomain.GetAssemblies()
                                  .Where(_ => !_.IsDynamic && !string.IsNullOrWhiteSpace(_.Location))
                                  .Select(_ => MetadataReference.CreateFromFile(_.Location))
                                  .Concat(new[] { MetadataReference.CreateFromFile(typeof(ConfigurationKeyGenerator).Assembly.Location) });

        var compilation = CSharpCompilation.Create(
            "Datadog.Trace.Generated",
            new[] { syntaxTree },
            references,
            new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));

        var generator = new ConfigurationKeyGenerator().AsSourceGenerator();

        var opts = new GeneratorDriverOptions(
            disabledOutputs: IncrementalGeneratorOutputKind.None,
            trackIncrementalGeneratorSteps: true);

        // No additional texts provided
        var driver = CSharpGeneratorDriver.Create(
            new[] { generator },
            additionalTexts: Array.Empty<AdditionalText>(),
            driverOptions: opts);

        var runResult = driver.RunGenerators(compilation).GetRunResult();

        var output = runResult.GeneratedTrees.Length > 0
            ? runResult.GeneratedTrees[0].ToString()
            : string.Empty;

        return (runResult.Diagnostics, output);
    }

    private class TestAdditionalText : AdditionalText
    {
        private readonly string _text;

        public TestAdditionalText(string path, string text)
        {
            Path = path;
            _text = text;
        }

        public override string Path { get; }

        public override SourceText GetText(CancellationToken cancellationToken = default)
            => SourceText.From(_text, Encoding.UTF8);
    }
}
