// <copyright file="VendoredDependency.cs" company="Datadog">
// Unless explicitly stated otherwise all files in this repository are licensed under the Apache 2 License.
// This product includes software developed at Datadog (https://www.datadoghq.com/). Copyright 2017 Datadog, Inc.
// </copyright>

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;

namespace UpdateVendors
{
    public class VendoredDependency
    {
        private const string AutoGeneratedMessage = @"//------------------------------------------------------------------------------
// <auto-generated />
// This file was automatically generated by the UpdateVendors tool.
//------------------------------------------------------------------------------
";

        static VendoredDependency()
        {
            Add(
                libraryName: "Serilog",
                version: "2.10.0",
                downloadUrl: "https://github.com/serilog/serilog/archive/v2.10.0.zip",
                pathToSrc: new[] { "serilog-2.10.0", "src", "Serilog" },
                transform: filePath => RewriteCsFileWithStandardTransform(filePath, originalNamespace: "Serilog"));

            Add(
                libraryName: "Serilog.Sinks.File",
                version: "4.1.0",
                downloadUrl: "https://github.com/serilog/serilog-sinks-file/archive/v4.1.0.zip",
                pathToSrc: new[] { "serilog-sinks-file-4.1.0", "src", "Serilog.Sinks.File" },
                transform: filePath => RewriteCsFileWithStandardTransform(filePath, originalNamespace: "Serilog"));

            Add(
                libraryName: "StatsdClient",
                version: "6.0.0",
                downloadUrl: "https://github.com/DataDog/dogstatsd-csharp-client/archive/6.0.0.zip",
                pathToSrc: new[] { "dogstatsd-csharp-client-6.0.0", "src", "StatsdClient" },
                transform: filePath => RewriteCsFileWithStandardTransform(filePath, originalNamespace: "StatsdClient"));

            Add(
                libraryName: "MessagePack",
                version: "1.9.3",
                downloadUrl: "https://github.com/neuecc/MessagePack-CSharp/archive/v1.9.3.zip",
                pathToSrc: new[] { "MessagePack-CSharp-1.9.3", "src", "MessagePack" },
                transform: filePath => RewriteCsFileWithStandardTransform(filePath, originalNamespace: "MessagePack"));

            Add(
                libraryName: "Newtonsoft.Json",
                version: "12.0.1",
                downloadUrl: "https://github.com/JamesNK/Newtonsoft.Json/archive/12.0.1.zip",
                pathToSrc: new[] { "Newtonsoft.Json-12.0.1", "src", "Newtonsoft.Json" },
                transform: filePath => RewriteCsFileWithStandardTransform(filePath, originalNamespace: "Newtonsoft.Json"));
            
            Add(
                libraryName: "dnlib",
                version: "3.4.0",
                downloadUrl: "https://github.com/0xd4d/dnlib/archive/refs/tags/v3.4.0.zip",
                pathToSrc: new[] { "dnlib-3.4.0", "src" },
                transform: filePath => RewriteCsFileWithStandardTransform(filePath, originalNamespace: "dnlib"));


            Add(
                libraryName: "Datadog.Sketches",
                version: "1.0.0",
                downloadUrl: "https://github.com/DataDog/sketches-dotnet/archive/v1.0.0.zip",
                pathToSrc: new[] { "sketches-dotnet-1.0.0", "src", "Datadog.Sketches" },
                // Perform standard CS file transform with additional '#nullable enable' directive at the beginning of the files, since the vendored project was built with <Nullable>enable</Nullable>
                transform: filePath => RewriteCsFileWithStandardTransform(filePath, originalNamespace: "Datadog.Sketches", AddNullableDirectiveTransform));
        }

        public static List<VendoredDependency> All { get; set; } = new List<VendoredDependency>();

        public string LibraryName { get; set; }

        public string Version { get; set; }

        public string DownloadUrl { get; set; }

        public string[] PathToSrc { get; set; }

        public Action<string> Transform { get; set; }

        private static void Add(
            string libraryName,
            string version,
            string downloadUrl,
            string[] pathToSrc,
            Action<string> transform)
        {
            All.Add(new VendoredDependency()
            {
                LibraryName = libraryName,
                Version = version,
                DownloadUrl = downloadUrl,
                PathToSrc = pathToSrc,
                Transform = transform,
            });
        }

        private static string AddNullableDirectiveTransform(string filePath, string content)
        {
            if (!content.Contains("#nullable"))
            {
                return "#nullable enable" + Environment.NewLine + content;
            }

            return content;
        }

        private static void RewriteCsFileWithStandardTransform(string filePath, string originalNamespace, Func<string, string, string> extraTransform = null)
        {
            if (string.Equals(Path.GetExtension(filePath), ".cs", StringComparison.OrdinalIgnoreCase))
            {
                RewriteFileWithTransform(
                    filePath,
                    content =>
                    {
                        if (extraTransform != null)
                        {
                            content = extraTransform(filePath, content);
                        }

                        // Disable analyzer
                        var builder = new StringBuilder(AutoGeneratedMessage, content.Length * 2);
                        builder.AppendLine(GenerateWarningDisablePragma());
                        builder.Append(content);

                        // Special Newtonsoft.Json processing
                        if (originalNamespace.Equals("Newtonsoft.Json"))
                        {
                            builder.Replace($"using ErrorEventArgs = Newtonsoft.Json.Serialization.ErrorEventArgs", "using ErrorEventArgs = Datadog.Trace.Vendors.Newtonsoft.Json.Serialization.ErrorEventArgs");

                            if (content.Contains("using Newtonsoft.Json.Serialization;"))
                            {
                                builder.Replace($"Func<", $"System.Func<");
                                builder.Replace($"Action<", $"System.Action<");
                            }
                        }


                        if (originalNamespace.Equals("dnlib"))
                        {
                            // dnlib's only targets net461 and netstandard2.0. 
                            // For our needs, it's more correct to consider `NETSTANDARD` as 'everything not .NET Framework'
                            builder.Replace("#if NETSTANDARD", "#if !NETFRAMEWORK");
                        }
                        // Prevent namespace conflicts
                        builder.Replace($"using {originalNamespace}", $"using Datadog.Trace.Vendors.{originalNamespace}");
                        builder.Replace($"namespace {originalNamespace}", $"namespace Datadog.Trace.Vendors.{originalNamespace}");
                        builder.Replace($"[CLSCompliant(false)]", $"// [CLSCompliant(false)]");

                        // Fix namespace conflicts in `using alias` directives. For example, transform:
                        //      using Foo = dnlib.A.B.C;
                        // To:
                        //      using Foo = Datadog.Trace.Vendors.dnlib.A.B.C;
                        string result =
                            Regex.Replace(
                                builder.ToString(),
                                @$"using\s+(\S+)\s+=\s+{Regex.Escape(originalNamespace)}.(.*);",
                                match => $"using {match.Groups[1].Value} = Datadog.Trace.Vendors.{originalNamespace}.{match.Groups[2].Value};");

                        
                        
                        // Don't expose anything we don't intend to
                        // by replacing all "public" access modifiers with "internal"
                        return Regex.Replace(
                            result,
                            @"public(\s+((abstract|sealed|static|unsafe)\s+)*?(partial\s+)?(partial\s+)?(class|readonly\s+struct|struct|interface|enum|delegate))",
                            match => $"internal{match.Groups[1]}");
                    });
            }
        }

        static string GenerateWarningDisablePragma() =>
            "#pragma warning disable " +
            "CS0618, " +      // Type or member is obsolete 
            "CS0649, " +      // Field is never assigned to, and will always have its default value 
            "CS1574, " +      // XML comment has a cref attribute that could not be resolved
            "CS1580, " +      // Invalid type for parameter in XML comment cref attribute 
            "CS1581, " +      // Invalid return type in XML comment cref attribute
            "CS1584, " +      // XML comment has syntactically incorrect cref attribute
            "SYSLIB0011, " +  // BinaryFormatter serialization is obsolete and should not be used. 
            "SYSLIB0032";     // Recovery from corrupted process state exceptions is not supported; HandleProcessCorruptedStateExceptionsAttribute is ignored."

        private static void RewriteFileWithTransform(string filePath, Func<string, string> transform)
        {
            var fileContent = File.ReadAllText(filePath);
            fileContent = transform(fileContent);
            // Normalize text to use CRLF line endings so we have deterministic results
            fileContent = fileContent.Replace("\r\n", "\n").Replace("\n", "\r\n");
            File.WriteAllText(
                filePath,
                fileContent,
                new UTF8Encoding(encoderShouldEmitUTF8Identifier: false));
        }
    }
}
