#ifndef EVALUATORS_READER_H
#define EVALUATORS_READER_H

/* Generated by flatcc 0.6.1 FlatBuffers schema compiler for C by dvide.com */

#ifndef FLATBUFFERS_COMMON_READER_H
#include "flatbuffers_common_reader.h"
#endif
#ifndef EVALUATOR_IDS_READER_H
#include "evaluator_ids_reader.h"
#endif
#include "flatcc/flatcc_flatbuffers.h"
#ifndef __alignas_is_defined
#include <stdalign.h>
#endif
#include "flatcc/flatcc_prologue.h"
#ifndef flatbuffers_identifier
#define flatbuffers_identifier 0
#endif
#ifndef flatbuffers_extension
#define flatbuffers_extension "bin"
#endif


typedef const struct dd_wls_StrEvaluator_table *dd_wls_StrEvaluator_table_t;
typedef struct dd_wls_StrEvaluator_table *dd_wls_StrEvaluator_mutable_table_t;
typedef const flatbuffers_uoffset_t *dd_wls_StrEvaluator_vec_t;
typedef flatbuffers_uoffset_t *dd_wls_StrEvaluator_mutable_vec_t;
typedef const struct dd_wls_UNumEvaluator_table *dd_wls_UNumEvaluator_table_t;
typedef struct dd_wls_UNumEvaluator_table *dd_wls_UNumEvaluator_mutable_table_t;
typedef const flatbuffers_uoffset_t *dd_wls_UNumEvaluator_vec_t;
typedef flatbuffers_uoffset_t *dd_wls_UNumEvaluator_mutable_vec_t;
typedef const struct dd_wls_NumEvaluator_table *dd_wls_NumEvaluator_table_t;
typedef struct dd_wls_NumEvaluator_table *dd_wls_NumEvaluator_mutable_table_t;
typedef const flatbuffers_uoffset_t *dd_wls_NumEvaluator_vec_t;
typedef flatbuffers_uoffset_t *dd_wls_NumEvaluator_mutable_vec_t;
#ifndef dd_wls_StrEvaluator_file_identifier
#define dd_wls_StrEvaluator_file_identifier 0
#endif
/* deprecated, use dd_wls_StrEvaluator_file_identifier */
#ifndef dd_wls_StrEvaluator_identifier
#define dd_wls_StrEvaluator_identifier 0
#endif
#define dd_wls_StrEvaluator_type_hash ((flatbuffers_thash_t)0xf3fc72ff)
#define dd_wls_StrEvaluator_type_identifier "\xff\x72\xfc\xf3"
#ifndef dd_wls_StrEvaluator_file_extension
#define dd_wls_StrEvaluator_file_extension "bin"
#endif
#ifndef dd_wls_UNumEvaluator_file_identifier
#define dd_wls_UNumEvaluator_file_identifier 0
#endif
/* deprecated, use dd_wls_UNumEvaluator_file_identifier */
#ifndef dd_wls_UNumEvaluator_identifier
#define dd_wls_UNumEvaluator_identifier 0
#endif
#define dd_wls_UNumEvaluator_type_hash ((flatbuffers_thash_t)0x9b8b78f)
#define dd_wls_UNumEvaluator_type_identifier "\x8f\xb7\xb8\x09"
#ifndef dd_wls_UNumEvaluator_file_extension
#define dd_wls_UNumEvaluator_file_extension "bin"
#endif
#ifndef dd_wls_NumEvaluator_file_identifier
#define dd_wls_NumEvaluator_file_identifier 0
#endif
/* deprecated, use dd_wls_NumEvaluator_file_identifier */
#ifndef dd_wls_NumEvaluator_identifier
#define dd_wls_NumEvaluator_identifier 0
#endif
#define dd_wls_NumEvaluator_type_hash ((flatbuffers_thash_t)0x899e7e72)
#define dd_wls_NumEvaluator_type_identifier "\x72\x7e\x9e\x89"
#ifndef dd_wls_NumEvaluator_file_extension
#define dd_wls_NumEvaluator_file_extension "bin"
#endif

/**  These are the supported comparison operators for Numeric evaluators:
 *  CMP_EQ : Compare equal `==`
 *  CMP_GT : Compare Greater Than `>`
 *  CMP_GTE : Compare Greater Than Equal `>=`
 *  CMP_LT : Compare Lower Than `<`
 *  CMP_LTE : Compare Lower Than Equal `<=` */
typedef int8_t dd_wls_CmpTypeNUM_enum_t;
__flatbuffers_define_integer_type(dd_wls_CmpTypeNUM, dd_wls_CmpTypeNUM_enum_t, 8)
#define dd_wls_CmpTypeNUM_CMP_EQ ((dd_wls_CmpTypeNUM_enum_t)INT8_C(0))
#define dd_wls_CmpTypeNUM_CMP_GT ((dd_wls_CmpTypeNUM_enum_t)INT8_C(1))
#define dd_wls_CmpTypeNUM_CMP_GTE ((dd_wls_CmpTypeNUM_enum_t)INT8_C(2))
#define dd_wls_CmpTypeNUM_CMP_LT ((dd_wls_CmpTypeNUM_enum_t)INT8_C(3))
#define dd_wls_CmpTypeNUM_CMP_LTE ((dd_wls_CmpTypeNUM_enum_t)INT8_C(4))
#define dd_wls_CmpTypeNUM_CMP_COUNT ((dd_wls_CmpTypeNUM_enum_t)INT8_C(5))

static inline const char *dd_wls_CmpTypeNUM_name(dd_wls_CmpTypeNUM_enum_t value)
{
    switch (value) {
    case dd_wls_CmpTypeNUM_CMP_EQ: return "CMP_EQ";
    case dd_wls_CmpTypeNUM_CMP_GT: return "CMP_GT";
    case dd_wls_CmpTypeNUM_CMP_GTE: return "CMP_GTE";
    case dd_wls_CmpTypeNUM_CMP_LT: return "CMP_LT";
    case dd_wls_CmpTypeNUM_CMP_LTE: return "CMP_LTE";
    case dd_wls_CmpTypeNUM_CMP_COUNT: return "CMP_COUNT";
    default: return "";
    }
}

static inline int dd_wls_CmpTypeNUM_is_known_value(dd_wls_CmpTypeNUM_enum_t value)
{
    switch (value) {
    case dd_wls_CmpTypeNUM_CMP_EQ: return 1;
    case dd_wls_CmpTypeNUM_CMP_GT: return 1;
    case dd_wls_CmpTypeNUM_CMP_GTE: return 1;
    case dd_wls_CmpTypeNUM_CMP_LT: return 1;
    case dd_wls_CmpTypeNUM_CMP_LTE: return 1;
    case dd_wls_CmpTypeNUM_CMP_COUNT: return 1;
    default: return 0;
    }
}

/**  These are the supported comparison operators for String evaluators:
 *  CMP_PREFIX : Compare if the string starts with the value
 *  CMP_SUFFIX : Compare if the string ends with the value
 *  CMP_CONTAINS : Compare if the string contains the value
 *  CMP_EXACT : Compare if the string is exactly equal to the value */
typedef int8_t dd_wls_CmpTypeSTR_enum_t;
__flatbuffers_define_integer_type(dd_wls_CmpTypeSTR, dd_wls_CmpTypeSTR_enum_t, 8)
#define dd_wls_CmpTypeSTR_CMP_PREFIX ((dd_wls_CmpTypeSTR_enum_t)INT8_C(0))
#define dd_wls_CmpTypeSTR_CMP_SUFFIX ((dd_wls_CmpTypeSTR_enum_t)INT8_C(1))
#define dd_wls_CmpTypeSTR_CMP_CONTAINS ((dd_wls_CmpTypeSTR_enum_t)INT8_C(2))
#define dd_wls_CmpTypeSTR_CMP_EXACT ((dd_wls_CmpTypeSTR_enum_t)INT8_C(3))
#define dd_wls_CmpTypeSTR_CMP_COUNT ((dd_wls_CmpTypeSTR_enum_t)INT8_C(4))

static inline const char *dd_wls_CmpTypeSTR_name(dd_wls_CmpTypeSTR_enum_t value)
{
    switch (value) {
    case dd_wls_CmpTypeSTR_CMP_PREFIX: return "CMP_PREFIX";
    case dd_wls_CmpTypeSTR_CMP_SUFFIX: return "CMP_SUFFIX";
    case dd_wls_CmpTypeSTR_CMP_CONTAINS: return "CMP_CONTAINS";
    case dd_wls_CmpTypeSTR_CMP_EXACT: return "CMP_EXACT";
    case dd_wls_CmpTypeSTR_CMP_COUNT: return "CMP_COUNT";
    default: return "";
    }
}

static inline int dd_wls_CmpTypeSTR_is_known_value(dd_wls_CmpTypeSTR_enum_t value)
{
    switch (value) {
    case dd_wls_CmpTypeSTR_CMP_PREFIX: return 1;
    case dd_wls_CmpTypeSTR_CMP_SUFFIX: return 1;
    case dd_wls_CmpTypeSTR_CMP_CONTAINS: return 1;
    case dd_wls_CmpTypeSTR_CMP_EXACT: return 1;
    case dd_wls_CmpTypeSTR_CMP_COUNT: return 1;
    default: return 0;
    }
}


/**  EvaluatorType is a union of all the evaluators supported by the policy engine.
 *  NOTE: StrArrEvaluator is not supported yet, but it is reserved for future use. */
typedef uint8_t dd_wls_EvaluatorType_union_type_t;
__flatbuffers_define_integer_type(dd_wls_EvaluatorType, dd_wls_EvaluatorType_union_type_t, 8)
__flatbuffers_define_union(flatbuffers_, dd_wls_EvaluatorType)
/**  Represents a String evaluator
 *  Each evaluator has an ID, a comparison type and a value to compare against. */
#define dd_wls_EvaluatorType_NONE ((dd_wls_EvaluatorType_union_type_t)UINT8_C(0))
#define dd_wls_EvaluatorType_StrEvaluator ((dd_wls_EvaluatorType_union_type_t)UINT8_C(1))
#define dd_wls_EvaluatorType_NumEvaluator ((dd_wls_EvaluatorType_union_type_t)UINT8_C(2))
#define dd_wls_EvaluatorType_UNumEvaluator ((dd_wls_EvaluatorType_union_type_t)UINT8_C(3))

static inline const char *dd_wls_EvaluatorType_type_name(dd_wls_EvaluatorType_union_type_t type)
{
    switch (type) {
    case dd_wls_EvaluatorType_NONE: return "NONE";
    case dd_wls_EvaluatorType_StrEvaluator: return "StrEvaluator";
    case dd_wls_EvaluatorType_NumEvaluator: return "NumEvaluator";
    case dd_wls_EvaluatorType_UNumEvaluator: return "UNumEvaluator";
    default: return "";
    }
}

static inline int dd_wls_EvaluatorType_is_known_type(dd_wls_EvaluatorType_union_type_t type)
{
    switch (type) {
    case dd_wls_EvaluatorType_NONE: return 1;
    case dd_wls_EvaluatorType_StrEvaluator: return 1;
    case dd_wls_EvaluatorType_NumEvaluator: return 1;
    case dd_wls_EvaluatorType_UNumEvaluator: return 1;
    default: return 0;
    }
}


struct dd_wls_StrEvaluator_table { uint8_t unused__; };

static inline size_t dd_wls_StrEvaluator_vec_len(dd_wls_StrEvaluator_vec_t vec)
__flatbuffers_vec_len(vec)
static inline dd_wls_StrEvaluator_table_t dd_wls_StrEvaluator_vec_at(dd_wls_StrEvaluator_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(dd_wls_StrEvaluator_table_t, vec, i, 0)
__flatbuffers_table_as_root(dd_wls_StrEvaluator)

/**  The ID is a unique identifier for the evaluator. */
__flatbuffers_define_scalar_field(0, dd_wls_StrEvaluator, id, dd_wls_StringEvaluators, dd_wls_StringEvaluators_enum_t, INT8_C(0))
/**  The comparison type is used to determine how to compare the value against the evaluator's value. */
__flatbuffers_define_scalar_field(1, dd_wls_StrEvaluator, cmp, dd_wls_CmpTypeSTR, dd_wls_CmpTypeSTR_enum_t, INT8_C(0))
/**  The value is the value to compare against. */
__flatbuffers_define_string_field(2, dd_wls_StrEvaluator, value, 0)

/**  Represents a String evaluator that can accept multiple values.
 *  Represents an unsigned Numeric evaluator
 *  This evaluator is used for unsigned numeric comparisons. */
struct dd_wls_UNumEvaluator_table { uint8_t unused__; };

static inline size_t dd_wls_UNumEvaluator_vec_len(dd_wls_UNumEvaluator_vec_t vec)
__flatbuffers_vec_len(vec)
static inline dd_wls_UNumEvaluator_table_t dd_wls_UNumEvaluator_vec_at(dd_wls_UNumEvaluator_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(dd_wls_UNumEvaluator_table_t, vec, i, 0)
__flatbuffers_table_as_root(dd_wls_UNumEvaluator)

/**  Each evaluator has an ID, a comparison type and a value to compare against. */
__flatbuffers_define_scalar_field(0, dd_wls_UNumEvaluator, id, dd_wls_NumericEvaluators, dd_wls_NumericEvaluators_enum_t, INT8_C(0))
/**  The comparison type is used to determine how to compare the value against the evaluator's value. */
__flatbuffers_define_scalar_field(1, dd_wls_UNumEvaluator, cmp, dd_wls_CmpTypeNUM, dd_wls_CmpTypeNUM_enum_t, INT8_C(0))
/**  The value is an unsigned long. */
__flatbuffers_define_scalar_field(2, dd_wls_UNumEvaluator, value, flatbuffers_uint64, uint64_t, UINT64_C(0))

/**  Represents a signed Numeric evaluator
 *  This evaluator is used for signed numeric comparisons. */
struct dd_wls_NumEvaluator_table { uint8_t unused__; };

static inline size_t dd_wls_NumEvaluator_vec_len(dd_wls_NumEvaluator_vec_t vec)
__flatbuffers_vec_len(vec)
static inline dd_wls_NumEvaluator_table_t dd_wls_NumEvaluator_vec_at(dd_wls_NumEvaluator_vec_t vec, size_t i)
__flatbuffers_offset_vec_at(dd_wls_NumEvaluator_table_t, vec, i, 0)
__flatbuffers_table_as_root(dd_wls_NumEvaluator)

/**  Each evaluator has an ID, a comparison type and a value to compare against. */
__flatbuffers_define_scalar_field(0, dd_wls_NumEvaluator, id, dd_wls_NumericEvaluators, dd_wls_NumericEvaluators_enum_t, INT8_C(0))
/**  The comparison type is used to determine how to compare the value against the evaluator's value. */
__flatbuffers_define_scalar_field(1, dd_wls_NumEvaluator, cmp, dd_wls_CmpTypeNUM, dd_wls_CmpTypeNUM_enum_t, INT8_C(0))
/**  The value is a signed long. */
__flatbuffers_define_scalar_field(2, dd_wls_NumEvaluator, value, flatbuffers_int64, int64_t, INT64_C(0))


#include "flatcc/flatcc_epilogue.h"
#endif /* EVALUATORS_READER_H */
